# Content Negotiation - Multiple Representations of Resources

## Introduction

**Content negotiation** is the process where client and server agree on the best representation format for a resource. The same resource can be returned as JSON, XML, CSV, HTML, or other formats based on client preferences.

**Key principle:** One resource, multiple representations. The client tells the server what it wants; the server responds accordingly.

---

## Why Content Negotiation?

### Without Content Negotiation

```javascript
// Different endpoints for different formats?
GET /api/users.json    → JSON
GET /api/users.xml     → XML
GET /api/users.csv     → CSV

// Problems:
// ❌ Multiple endpoints for same resource
// ❌ URL pollution
// ❌ Hard to maintain
// ❌ Not RESTful
```

### With Content Negotiation

```javascript
// Same endpoint, different formats
GET /api/users
Accept: application/json        → JSON

GET /api/users
Accept: application/xml         → XML

GET /api/users
Accept: text/csv                → CSV

// Benefits:
// ✅ Clean URLs
// ✅ Single endpoint
// ✅ Client chooses format
// ✅ RESTful principle
```

---

## Accept Header

Client specifies preferred response format.

### Basic Usage

```http
GET /api/users/42
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "John Doe"
}
```

```http
GET /api/users/42
Accept: application/xml

HTTP/1.1 200 OK
Content-Type: application/xml

<user>
  <id>42</id>
  <name>John Doe</name>
</user>
```

### Multiple Media Types

Client can specify multiple acceptable formats.

```http
GET /api/users/42
Accept: application/json, application/xml

# Server chooses first supported format (JSON)
```

### Quality Values (q parameter)

Specify preference with quality values (0-1).

```http
Accept: application/json;q=1.0, application/xml;q=0.8, text/csv;q=0.5

# Preference order:
# 1. JSON (q=1.0) - most preferred
# 2. XML (q=0.8)
# 3. CSV (q=0.5) - least preferred
```

**Default:** `q=1.0` if not specified.

```http
# Same as:
Accept: application/json;q=1.0
Accept: application/json
```

### Wildcards

```http
# Accept any JSON type
Accept: application/*+json

# Accept any format
Accept: */*

# Accept any text format
Accept: text/*
```

---

## Content-Type Header

Server specifies the actual format being sent.

```http
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  "id": 42,
  "name": "John Doe"
}
```

### Common Media Types

| Media Type | Description | File Extension |
|------------|-------------|----------------|
| `application/json` | JSON | `.json` |
| `application/xml` | XML | `.xml` |
| `text/csv` | CSV | `.csv` |
| `text/html` | HTML | `.html` |
| `text/plain` | Plain text | `.txt` |
| `application/pdf` | PDF | `.pdf` |
| `image/png` | PNG image | `.png` |
| `image/jpeg` | JPEG image | `.jpg` |
| `application/octet-stream` | Binary data | - |
| `multipart/form-data` | File upload | - |

### Vendor-Specific Media Types

```http
# GitHub API
Accept: application/vnd.github.v3+json

# Custom API
Accept: application/vnd.myapi.v1+json
Accept: application/vnd.myapi.user+json
```

---

## Implementation Examples

### Basic JSON/XML Support

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  const accept = req.headers.accept || 'application/json';
  
  if (accept.includes('application/xml')) {
    // Return XML
    const xml = `
      <user>
        <id>${user.id}</id>
        <name>${user.name}</name>
        <email>${user.email}</email>
      </user>
    `;
    
    return res
      .type('application/xml')
      .send(xml);
  }
  
  if (accept.includes('application/json')) {
    // Return JSON (default)
    return res
      .type('application/json')
      .json(user);
  }
  
  // Format not supported
  return res.status(406).json({
    error: 'Not Acceptable',
    message: 'Supported formats: application/json, application/xml'
  });
});
```

### Using Express res.format()

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.format({
    'application/json': () => {
      res.json(user);
    },
    
    'application/xml': () => {
      const xml = `
        <user>
          <id>${user.id}</id>
          <name>${user.name}</name>
          <email>${user.email}</email>
        </user>
      `;
      res.type('application/xml').send(xml);
    },
    
    'text/csv': () => {
      const csv = `id,name,email\n${user.id},${user.name},${user.email}`;
      res.type('text/csv').send(csv);
    },
    
    'text/html': () => {
      const html = `
        <html>
          <body>
            <h1>${user.name}</h1>
            <p>Email: ${user.email}</p>
          </body>
        </html>
      `;
      res.type('text/html').send(html);
    },
    
    'default': () => {
      // No acceptable format found
      res.status(406).json({
        error: 'Not Acceptable',
        message: 'Supported formats: application/json, application/xml, text/csv, text/html'
      });
    }
  });
});
```

### Negotiation Middleware

```javascript
function contentNegotiation(supportedFormats) {
  return (req, res, next) => {
    const accept = req.headers.accept || 'application/json';
    
    // Parse Accept header
    const acceptedTypes = accept.split(',').map(type => {
      const [mediaType, ...params] = type.trim().split(';');
      const qParam = params.find(p => p.trim().startsWith('q='));
      const q = qParam ? parseFloat(qParam.split('=')[1]) : 1.0;
      
      return { mediaType: mediaType.trim(), q };
    });
    
    // Sort by quality value (highest first)
    acceptedTypes.sort((a, b) => b.q - a.q);
    
    // Find first supported format
    for (const { mediaType } of acceptedTypes) {
      if (supportedFormats.includes(mediaType)) {
        req.negotiatedFormat = mediaType;
        return next();
      }
      
      // Handle wildcards
      if (mediaType === '*/*' && supportedFormats.length > 0) {
        req.negotiatedFormat = supportedFormats[0];
        return next();
      }
    }
    
    // No acceptable format
    return res.status(406).json({
      error: 'Not Acceptable',
      message: `Supported formats: ${supportedFormats.join(', ')}`,
      acceptedFormats: supportedFormats
    });
  };
}

// Usage
app.get('/api/users/:id',
  contentNegotiation(['application/json', 'application/xml', 'text/csv']),
  async (req, res) => {
    const user = await db.users.findById(req.params.id);
    
    switch (req.negotiatedFormat) {
      case 'application/json':
        return res.json(user);
      
      case 'application/xml':
        const xml = convertToXML(user);
        return res.type('application/xml').send(xml);
      
      case 'text/csv':
        const csv = convertToCSV([user]);
        return res.type('text/csv').send(csv);
    }
  }
);
```

---

## Format Converters

### JSON to XML

```javascript
function jsonToXML(obj, rootName = 'root') {
  function convert(obj, indent = '') {
    if (typeof obj !== 'object' || obj === null) {
      return escapeXML(String(obj));
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => convert(item, indent)).join('\n');
    }
    
    return Object.entries(obj)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return value.map(item => 
            `${indent}<${key}>${convert(item, indent + '  ')}</${key}>`
          ).join('\n');
        }
        
        if (typeof value === 'object' && value !== null) {
          return `${indent}<${key}>\n${convert(value, indent + '  ')}\n${indent}</${key}>`;
        }
        
        return `${indent}<${key}>${escapeXML(String(value))}</${key}>`;
      })
      .join('\n');
  }
  
  function escapeXML(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
  
  return `<?xml version="1.0" encoding="UTF-8"?>\n<${rootName}>\n${convert(obj, '  ')}\n</${rootName}>`;
}

// Usage
const user = { id: 42, name: 'John Doe', email: 'john@example.com' };
const xml = jsonToXML(user, 'user');

console.log(xml);
/*
<?xml version="1.0" encoding="UTF-8"?>
<user>
  <id>42</id>
  <name>John Doe</name>
  <email>john@example.com</email>
</user>
*/
```

### JSON to CSV

```javascript
function jsonToCSV(data) {
  if (!Array.isArray(data) || data.length === 0) {
    return '';
  }
  
  // Get all unique keys
  const keys = [...new Set(data.flatMap(Object.keys))];
  
  // Header row
  const header = keys.join(',');
  
  // Data rows
  const rows = data.map(obj => 
    keys.map(key => {
      const value = obj[key];
      
      // Handle null/undefined
      if (value == null) return '';
      
      // Escape quotes and wrap in quotes if contains comma/quote/newline
      const str = String(value);
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      
      return str;
    }).join(',')
  );
  
  return [header, ...rows].join('\n');
}

// Usage
const users = [
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
];

const csv = jsonToCSV(users);
console.log(csv);
/*
id,name,email
1,John Doe,john@example.com
2,Jane Smith,jane@example.com
*/
```

### JSON to HTML

```javascript
function jsonToHTML(data, title = 'Data') {
  if (Array.isArray(data) && data.length > 0) {
    // Table for arrays
    const keys = Object.keys(data[0]);
    
    const header = keys.map(key => `<th>${escapeHTML(key)}</th>`).join('');
    
    const rows = data.map(obj => {
      const cells = keys.map(key => 
        `<td>${escapeHTML(String(obj[key]))}</td>`
      ).join('');
      return `<tr>${cells}</tr>`;
    }).join('\n');
    
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${escapeHTML(title)}</title>
        <style>
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f2f2f2; }
        </style>
      </head>
      <body>
        <h1>${escapeHTML(title)}</h1>
        <table>
          <thead><tr>${header}</tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </body>
      </html>
    `;
  }
  
  // Single object
  const rows = Object.entries(data)
    .map(([key, value]) => 
      `<tr><th>${escapeHTML(key)}</th><td>${escapeHTML(String(value))}</td></tr>`
    )
    .join('\n');
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>${escapeHTML(title)}</title>
      <style>
        table { border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; }
        th { background-color: #f2f2f2; text-align: left; }
      </style>
    </head>
    <body>
      <h1>${escapeHTML(title)}</h1>
      <table>${rows}</table>
    </body>
    </html>
  `;
}

function escapeHTML(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
```

---

## Accept-Language Header

Negotiate content language.

```http
GET /api/products
Accept-Language: es-ES, es;q=0.9, en;q=0.8

# Preference:
# 1. Spanish (Spain) - q=1.0
# 2. Spanish (any) - q=0.9
# 3. English - q=0.8
```

### Implementation

```javascript
function parseAcceptLanguage(header) {
  if (!header) return ['en']; // Default
  
  return header
    .split(',')
    .map(lang => {
      const [locale, qParam] = lang.trim().split(';');
      const q = qParam ? parseFloat(qParam.split('=')[1]) : 1.0;
      return { locale: locale.trim(), q };
    })
    .sort((a, b) => b.q - a.q)
    .map(({ locale }) => locale);
}

app.get('/api/products', async (req, res) => {
  const languages = parseAcceptLanguage(req.headers['accept-language']);
  
  // Find first supported language
  const supportedLanguages = ['en', 'es', 'fr', 'de'];
  const language = languages.find(lang => 
    supportedLanguages.some(supported => 
      lang.toLowerCase().startsWith(supported)
    )
  ) || 'en';
  
  // Get products in preferred language
  const products = await db.products.find({ language }).toArray();
  
  res.set('Content-Language', language)
    .json(products);
});
```

### Translation Service

```javascript
const translations = {
  en: {
    greeting: 'Hello',
    farewell: 'Goodbye'
  },
  es: {
    greeting: 'Hola',
    farewell: 'Adiós'
  },
  fr: {
    greeting: 'Bonjour',
    farewell: 'Au revoir'
  }
};

function translate(key, language) {
  return translations[language]?.[key] || translations.en[key];
}

app.get('/api/welcome', (req, res) => {
  const languages = parseAcceptLanguage(req.headers['accept-language']);
  const language = languages.find(lang => translations[lang]) || 'en';
  
  res.set('Content-Language', language)
    .json({
      message: translate('greeting', language),
      language
    });
});
```

---

## Accept-Encoding Header

Negotiate compression format.

```http
GET /api/users
Accept-Encoding: gzip, deflate, br

# Server chooses best compression
HTTP/1.1 200 OK
Content-Encoding: gzip
Vary: Accept-Encoding

[compressed data]
```

### Compression Middleware

```javascript
const compression = require('compression');

// Enable compression
app.use(compression({
  // Compression level (0-9)
  level: 6,
  
  // Minimum size to compress (bytes)
  threshold: 1024,
  
  // Filter which responses to compress
  filter: (req, res) => {
    // Don't compress if client doesn't support it
    if (req.headers['x-no-compression']) {
      return false;
    }
    
    // Compress all responses by default
    return compression.filter(req, res);
  }
}));

app.get('/api/users', async (req, res) => {
  const users = await db.users.find().toArray();
  
  // Compression middleware handles Accept-Encoding automatically
  res.json(users);
});
```

### Manual Compression

```javascript
const zlib = require('zlib');
const { promisify } = require('util');

const gzip = promisify(zlib.gzip);
const deflate = promisify(zlib.deflate);
const brotli = promisify(zlib.brotliCompress);

app.get('/api/users', async (req, res) => {
  const users = await db.users.find().toArray();
  const json = JSON.stringify(users);
  
  const acceptEncoding = req.headers['accept-encoding'] || '';
  
  if (acceptEncoding.includes('br')) {
    // Brotli (best compression)
    const compressed = await brotli(Buffer.from(json));
    return res
      .set('Content-Encoding', 'br')
      .set('Vary', 'Accept-Encoding')
      .send(compressed);
  }
  
  if (acceptEncoding.includes('gzip')) {
    // Gzip (good compression)
    const compressed = await gzip(Buffer.from(json));
    return res
      .set('Content-Encoding', 'gzip')
      .set('Vary', 'Accept-Encoding')
      .send(compressed);
  }
  
  if (acceptEncoding.includes('deflate')) {
    // Deflate (basic compression)
    const compressed = await deflate(Buffer.from(json));
    return res
      .set('Content-Encoding', 'deflate')
      .set('Vary', 'Accept-Encoding')
      .send(compressed);
  }
  
  // No compression
  res.json(users);
});
```

---

## Accept-Charset Header

Negotiate character encoding (rarely used - UTF-8 is standard).

```http
GET /api/data
Accept-Charset: utf-8, iso-8859-1;q=0.5

HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
```

---

## 406 Not Acceptable

Server can't produce representation matching client's Accept headers.

```http
GET /api/users/42
Accept: application/pdf

HTTP/1.1 406 Not Acceptable
Content-Type: application/json

{
  "error": {
    "code": "NOT_ACCEPTABLE",
    "message": "The requested format is not supported",
    "acceptedFormats": [
      "application/json",
      "application/xml",
      "text/csv"
    ]
  }
}
```

### Implementation

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  const accept = req.headers.accept || 'application/json';
  const supportedFormats = ['application/json', 'application/xml', 'text/csv'];
  
  // Check if any supported format matches
  const isAcceptable = supportedFormats.some(format => 
    accept.includes(format) || accept.includes('*/*')
  );
  
  if (!isAcceptable) {
    return res.status(406)
      .type('application/json')
      .json({
        error: {
          code: 'NOT_ACCEPTABLE',
          message: 'The requested format is not supported',
          requestedFormat: accept,
          acceptedFormats: supportedFormats
        }
      });
  }
  
  // ... handle supported formats
});
```

---

## Proactive vs Reactive Negotiation

### Proactive (Server-Driven)

Server chooses representation based on Accept headers.

```http
GET /api/users/42
Accept: application/json, application/xml;q=0.8

HTTP/1.1 200 OK
Content-Type: application/json

{ "id": 42, "name": "John" }
```

**Pros:**
- ✅ Single request
- ✅ Fast
- ✅ Standard HTTP

**Cons:**
- ❌ Server might choose wrong format
- ❌ Complex negotiation logic

### Reactive (Agent-Driven)

Server returns list of available representations, client chooses.

```http
GET /api/users/42

HTTP/1.1 300 Multiple Choices
Content-Type: application/json

{
  "representations": [
    { "format": "application/json", "url": "/api/users/42.json" },
    { "format": "application/xml", "url": "/api/users/42.xml" },
    { "format": "text/csv", "url": "/api/users/42.csv" }
  ]
}

# Client chooses and makes second request
GET /api/users/42.json
```

**Pros:**
- ✅ Client has full control

**Cons:**
- ❌ Two requests
- ❌ Slower
- ❌ Rarely used

### Transparent (Proxy-Driven)

Proxy/CDN handles negotiation.

```http
Client → Proxy → Server

Proxy caches multiple representations
Proxy chooses appropriate one for each client
```

---

## Best Practices

### 1. Default to JSON

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  const accept = req.headers.accept || 'application/json';
  
  // Default to JSON if Accept header is missing or */*
  if (!accept || accept.includes('*/*')) {
    return res.json(user);
  }
  
  // ... handle other formats
});
```

### 2. Support Common Formats

```javascript
// At minimum, support JSON
// Optionally: XML, CSV

const commonFormats = [
  'application/json',  // Always
  'application/xml',   // If needed
  'text/csv'          // For data export
];
```

### 3. Set Content-Type Correctly

```javascript
// ✅ Good: Correct Content-Type
res.type('application/json').json(data);
res.type('application/xml').send(xml);
res.type('text/csv').send(csv);

// ❌ Bad: Wrong Content-Type
res.send(xml); // Content-Type: text/html (wrong!)
```

### 4. Use Vary Header

```javascript
// Tell caches that response varies by Accept header
res.set('Vary', 'Accept, Accept-Language, Accept-Encoding');
```

### 5. Document Supported Formats

```javascript
// In API documentation
/**
 * GET /api/users/:id
 * 
 * Supported formats:
 * - application/json (default)
 * - application/xml
 * - text/csv
 * - text/html
 * 
 * Example:
 * curl -H "Accept: application/xml" https://api.example.com/users/42
 */
```

### 6. Handle Quality Values

```javascript
function negotiateFormat(acceptHeader, supportedFormats) {
  const accepted = acceptHeader
    .split(',')
    .map(type => {
      const [mediaType, ...params] = type.trim().split(';');
      const qParam = params.find(p => p.trim().startsWith('q='));
      const q = qParam ? parseFloat(qParam.split('=')[1]) : 1.0;
      return { mediaType: mediaType.trim(), q };
    })
    .sort((a, b) => b.q - a.q);
  
  for (const { mediaType } of accepted) {
    if (supportedFormats.includes(mediaType)) {
      return mediaType;
    }
  }
  
  return null;
}
```

### 7. Provide Clear 406 Errors

```javascript
return res.status(406).json({
  error: {
    code: 'NOT_ACCEPTABLE',
    message: 'The requested format is not supported',
    requestedFormat: req.headers.accept,
    acceptedFormats: supportedFormats,
    documentation: 'https://api.example.com/docs/content-negotiation'
  }
});
```

---

## Testing Content Negotiation

```javascript
describe('Content Negotiation', () => {
  it('should return JSON by default', async () => {
    const response = await request(app)
      .get('/api/users/42');
    
    expect(response.headers['content-type']).toMatch(/application\/json/);
    expect(response.body).toHaveProperty('id', 42);
  });
  
  it('should return JSON when Accept is application/json', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', 'application/json');
    
    expect(response.headers['content-type']).toMatch(/application\/json/);
  });
  
  it('should return XML when Accept is application/xml', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', 'application/xml');
    
    expect(response.headers['content-type']).toMatch(/application\/xml/);
    expect(response.text).toContain('<user>');
  });
  
  it('should return CSV when Accept is text/csv', async () => {
    const response = await request(app)
      .get('/api/users')
      .set('Accept', 'text/csv');
    
    expect(response.headers['content-type']).toMatch(/text\/csv/);
    expect(response.text).toContain('id,name,email');
  });
  
  it('should respect quality values', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', 'application/xml;q=0.5, application/json;q=1.0');
    
    // Should choose JSON (higher q value)
    expect(response.headers['content-type']).toMatch(/application\/json/);
  });
  
  it('should return 406 for unsupported format', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', 'application/pdf');
    
    expect(response.status).toBe(406);
    expect(response.body.error.code).toBe('NOT_ACCEPTABLE');
    expect(response.body.error.acceptedFormats).toBeDefined();
  });
  
  it('should handle wildcard Accept header', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', '*/*');
    
    expect(response.status).toBe(200);
    expect(response.headers['content-type']).toMatch(/application\/json/);
  });
  
  it('should set Vary header', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('Accept', 'application/json');
    
    expect(response.headers.vary).toContain('Accept');
  });
  
  it('should negotiate language', async () => {
    const response = await request(app)
      .get('/api/products')
      .set('Accept-Language', 'es-ES');
    
    expect(response.headers['content-language']).toBe('es');
    expect(response.body[0].name).toBe('Producto 1'); // Spanish
  });
  
  it('should compress with gzip when accepted', async () => {
    const response = await request(app)
      .get('/api/users')
      .set('Accept-Encoding', 'gzip');
    
    expect(response.headers['content-encoding']).toBe('gzip');
  });
});
```

---

## Real-World Examples

### GitHub API

```http
GET https://api.github.com/users/octocat
Accept: application/vnd.github.v3+json

HTTP/1.1 200 OK
Content-Type: application/json

# Also supports:
# application/vnd.github.v3.raw+json
# application/vnd.github.v3.text+json
# application/vnd.github.v3.html+json
# application/vnd.github.v3.full+json
```

### Wikipedia API

```http
GET https://en.wikipedia.org/api/rest_v1/page/summary/HTTP
Accept: application/json

# Also supports:
# text/html
# application/ld+json
```

### REST Countries API

```http
GET https://restcountries.com/v3.1/all

# Supports multiple formats via URL extension
GET https://restcountries.com/v3.1/all.json
GET https://restcountries.com/v3.1/all.xml
```

---

## Common Mistakes

### Mistake 1: Ignoring Accept Header

```javascript
// ❌ Bad: Always return JSON
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  res.json(user); // What if client wants XML?
});

// ✅ Good: Respect Accept header
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  res.format({
    'application/json': () => res.json(user),
    'application/xml': () => res.type('xml').send(toXML(user))
  });
});
```

### Mistake 2: Wrong Content-Type

```javascript
// ❌ Bad: Wrong Content-Type
app.get('/api/users.xml', async (req, res) => {
  const xml = '<users>...</users>';
  res.send(xml); // Content-Type: text/html (wrong!)
});

// ✅ Good: Correct Content-Type
app.get('/api/users.xml', async (req, res) => {
  const xml = '<users>...</users>';
  res.type('application/xml').send(xml);
});
```

### Mistake 3: Not Setting Vary Header

```javascript
// ❌ Bad: No Vary header
app.get('/api/users/:id', (req, res) => {
  // Different response based on Accept, but no Vary header
  // Cache will serve wrong format to other clients!
});

// ✅ Good: Set Vary header
app.get('/api/users/:id', (req, res) => {
  res.set('Vary', 'Accept');
  // Now cache knows to store separate copies per Accept header
});
```

### Mistake 4: Using URL Extensions Instead of Headers

```javascript
// ❌ Bad: Extensions in URL
GET /api/users.json
GET /api/users.xml

// ✅ Better: Content negotiation with headers
GET /api/users
Accept: application/json
```

### Mistake 5: No 406 Response

```javascript
// ❌ Bad: Return 200 with error message in body
if (!formatSupported) {
  return res.json({ error: 'Format not supported' }); // Wrong status!
}

// ✅ Good: Return 406 Not Acceptable
if (!formatSupported) {
  return res.status(406).json({
    error: 'Not Acceptable',
    acceptedFormats: supportedFormats
  });
}
```

---

## Summary

### Key Concepts

- **Content Negotiation** = Client and server agree on representation format
- **Accept** = Client specifies preferred formats
- **Content-Type** = Server specifies actual format
- **Quality Values** = Preference order (q=0.0 to 1.0)
- **406 Not Acceptable** = No matching format available

### Important Headers

- **Accept** = Desired response format
- **Content-Type** = Actual response format
- **Accept-Language** = Desired language
- **Content-Language** = Actual language
- **Accept-Encoding** = Desired compression
- **Content-Encoding** = Actual compression
- **Accept-Charset** = Desired character encoding
- **Vary** = Response varies by these headers

### Common Formats

- **application/json** = JSON (most common)
- **application/xml** = XML
- **text/csv** = CSV (data export)
- **text/html** = HTML (browser view)
- **application/pdf** = PDF documents

### Best Practices

✅ Default to JSON
✅ Support common formats (JSON, XML, CSV)
✅ Set Content-Type correctly
✅ Use Vary header for caching
✅ Respect quality values
✅ Return 406 for unsupported formats
✅ Document supported formats
✅ Use res.format() in Express

### Negotiation Types

- **Proactive** = Server chooses (most common)
- **Reactive** = Client chooses from list (rare)
- **Transparent** = Proxy chooses (CDN)

---

## Next Steps

Explore related topics:
- API versioning with vendor media types
- Response compression optimization
- Internationalization strategies
- API documentation with format examples
- GraphQL as alternative to multiple formats
