# Request Components in REST API

## Introduction

A REST API request is composed of multiple components that work together to communicate intent, provide context, and transfer data. While each component has its own purpose, understanding how they **combine and interact** is crucial for building effective APIs.

**Key principle:** All components must work in harmony to create a complete, self-descriptive, and unambiguous request.

---

## Anatomy of a Complete Request

### Complete Request Example

```http
POST /api/v1/users/42/orders HTTP/1.1
Host: api.example.com
Content-Type: application/json; charset=utf-8
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
User-Agent: MyApp/2.0 (iOS 15.0)
X-Request-ID: req-abc-123-xyz
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US, en;q=0.9
If-None-Match: "etag-xyz-789"
Content-Length: 156

{
  "productId": 789,
  "quantity": 2,
  "shippingAddress": {
    "street": "123 Main St",
    "city": "New York",
    "zip": "10001"
  },
  "expressShipping": true
}
```

### Breaking Down the Components

```
┌─────────────────────────────────────────────────────────┐
│ REQUEST LINE                                            │
│ POST /api/v1/users/42/orders HTTP/1.1                 │
│ ↑    ↑                       ↑                         │
│ │    │                       └─ Protocol version       │
│ │    └─ URI (endpoint + path)                         │
│ └─ HTTP Method                                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ HEADERS                                                 │
│ Host: api.example.com ← Mandatory                      │
│ Content-Type: application/json ← Body format           │
│ Accept: application/json ← Expected response format    │
│ Authorization: Bearer token... ← Authentication        │
│ User-Agent: MyApp/2.0 ← Client identification         │
│ X-Request-ID: req-abc-123 ← Request tracking          │
│ Accept-Encoding: gzip ← Compression support           │
│ Content-Length: 156 ← Body size                       │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ BODY (Optional - for POST, PUT, PATCH)                 │
│ {                                                       │
│   "productId": 789,                                    │
│   "quantity": 2,                                       │
│   ...                                                   │
│ }                                                       │
└─────────────────────────────────────────────────────────┘
```

---

## Component Interactions

### 1. Method + URI: Defining the Action

The HTTP method and URI work together to specify **what** action on **which** resource.

#### Pattern: Method Determines Action, URI Identifies Resource

```http
GET    /users/42       → "Retrieve user 42"
POST   /users          → "Create a new user"
PUT    /users/42       → "Replace/update user 42"
PATCH  /users/42       → "Partially modify user 42"
DELETE /users/42       → "Remove user 42"
```

**Key insight:** Same URI, different methods = different actions

```http
/users/42:
  GET    → Read
  PUT    → Update/Replace
  PATCH  → Partial Update
  DELETE → Remove
```

#### Example: Collection vs Resource

```http
# Collection operations
GET    /products       → List all products
POST   /products       → Create new product

# Resource operations
GET    /products/123   → Get specific product
PUT    /products/123   → Update specific product
DELETE /products/123   → Delete specific product
```

---

### 2. Method + Body: Data Transfer

Some methods carry data, others don't. The body complements the method.

#### Methods That Accept Bodies

```http
POST   /users          → Body contains new user data
PUT    /users/42       → Body contains complete updated data
PATCH  /users/42       → Body contains partial updates
```

#### Example: Creating a Resource

```http
POST /users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "role": "user"
}
```

**Combination tells us:**
- **Method (POST):** We're creating something
- **URI (/users):** In the users collection
- **Body:** Here's the data for the new user

#### Methods That Don't Use Bodies

```http
GET    /users/42       → No body (retrieve only)
DELETE /users/42       → No body (just remove)
HEAD   /users/42       → No body (headers only)
```

**Exception:** DELETE can have a body but usually doesn't.

---

### 3. Content-Type + Body: Format Agreement

Content-Type header tells the server how to parse the body.

#### JSON Request

```http
POST /users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

#### Form Data Request

```http
POST /users
Content-Type: application/x-www-form-urlencoded

name=John+Doe&email=john%40example.com
```

#### Multipart Form Data (File Upload)

```http
POST /uploads
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="photo.jpg"
Content-Type: image/jpeg

[binary data]
------WebKitFormBoundary
Content-Disposition: form-data; name="description"

Profile photo
------WebKitFormBoundary--
```

**Key insight:** Content-Type and Body must match. Server rejects if they don't align.

```http
# ❌ Mismatch - will fail
Content-Type: application/json
Body: name=John&email=john@example.com  (this is form data!)

# ✅ Correct
Content-Type: application/json
Body: {"name":"John","email":"john@example.com"}
```

---

### 4. Authorization + URI: Access Control

Authorization header + URI determine if the request is allowed.

#### Public Endpoint (No Auth)

```http
GET /public/products
# No Authorization header needed
```

#### Protected Endpoint (Auth Required)

```http
GET /users/42/profile
Authorization: Bearer eyJhbGc...
```

**Server checks:**
1. Is the token valid?
2. Does the user have permission for this resource?
3. Does user 42 match the authenticated user?

#### Resource-Level Permissions

```http
# User trying to access their own profile
GET /users/42/profile
Authorization: Bearer token-for-user-42
→ ✅ Allowed

# User trying to access someone else's profile
GET /users/99/profile
Authorization: Bearer token-for-user-42
→ ❌ 403 Forbidden (if profiles are private)
```

---

### 5. Accept + Content-Type: Format Negotiation

Client specifies preferred response format with Accept, server responds with Content-Type.

#### Request-Response Cycle

```http
# Request
GET /users/42
Accept: application/json

# Response
HTTP/1.1 200 OK
Content-Type: application/json

{"id": 42, "name": "John"}
```

```http
# Request
GET /users/42
Accept: application/xml

# Response
HTTP/1.1 200 OK
Content-Type: application/xml

<user>
  <id>42</id>
  <name>John</name>
</user>
```

#### When Server Can't Satisfy Accept

```http
# Request
GET /users/42
Accept: application/pdf

# Response (server only supports JSON)
HTTP/1.1 406 Not Acceptable
Content-Type: application/json

{
  "error": "Not Acceptable",
  "supportedFormats": ["application/json"]
}
```

---

### 6. Method + Headers + Body: Complete Semantics

All components together define the complete meaning of the request.

#### Example: Conditional Update

```http
PUT /documents/42
Authorization: Bearer token123
Content-Type: application/json
If-Match: "v5"
Content-Length: 89

{
  "title": "Updated Document",
  "content": "New content here"
}
```

**Combined meaning:**
- **PUT:** Replace the document
- **URI:** Document 42
- **Authorization:** As authenticated user
- **If-Match:** Only if version is still "v5" (prevent conflicts)
- **Content-Type:** Body is JSON
- **Body:** Here's the new data

#### Example: Partial Update with Conditions

```http
PATCH /users/42/profile
Authorization: Bearer token123
Content-Type: application/json
If-Unmodified-Since: Wed, 21 Oct 2025 07:28:00 GMT

{
  "bio": "Updated biography"
}
```

**Combined meaning:**
- **PATCH:** Partially update
- **URI:** User 42's profile
- **Authorization:** As authenticated user
- **If-Unmodified-Since:** Only if not modified since date
- **Body:** Update just the bio field

---

## Common Request Patterns

### Pattern 1: Simple Retrieval

```http
GET /products/123
Accept: application/json
```

**Components work together:**
- Method: Read operation
- URI: Specific product
- Accept: Preferred format

**Server response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
ETag: "abc123"

{"id": 123, "name": "Product"}
```

---

### Pattern 2: Authenticated Creation

```http
POST /users/42/orders
Authorization: Bearer token123
Content-Type: application/json
Accept: application/json

{
  "items": [{"productId": 789, "quantity": 2}]
}
```

**Components work together:**
- Method: Create operation
- URI: In user 42's orders
- Authorization: Verify user identity
- Content-Type: Body format
- Accept: Response format
- Body: Order data

**Server response:**
```http
HTTP/1.1 201 Created
Location: /users/42/orders/999
Content-Type: application/json
ETag: "xyz789"

{
  "id": 999,
  "userId": 42,
  "items": [...],
  "total": 100.00,
  "createdAt": "2026-01-13T10:00:00Z"
}
```

---

### Pattern 3: Conditional Update (Optimistic Locking)

```http
PUT /documents/42
Authorization: Bearer token123
Content-Type: application/json
If-Match: "v5"

{
  "title": "Updated Document",
  "content": "New content"
}
```

**Success scenario:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
ETag: "v6"

{
  "id": 42,
  "title": "Updated Document",
  "version": 6,
  "updatedAt": "2026-01-13T10:00:00Z"
}
```

**Conflict scenario (someone else updated first):**
```http
HTTP/1.1 412 Precondition Failed
Content-Type: application/json
ETag: "v7"

{
  "error": "Precondition Failed",
  "message": "Document was modified by another user",
  "currentVersion": "v7",
  "requestedVersion": "v5"
}
```

---

### Pattern 4: Cached Retrieval

```http
GET /articles/42
If-None-Match: "abc123"
Accept: application/json
Accept-Encoding: gzip
```

**Not modified (use cache):**
```http
HTTP/1.1 304 Not Modified
ETag: "abc123"
Cache-Control: max-age=3600
```

**Modified (new data):**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: gzip
ETag: "xyz789"
Cache-Control: max-age=3600

[compressed JSON data]
```

---

### Pattern 5: File Upload with Metadata

```http
POST /files
Authorization: Bearer token123
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="file"; filename="report.pdf"
Content-Type: application/pdf

[binary PDF data]
------Boundary
Content-Disposition: form-data; name="metadata"
Content-Type: application/json

{
  "title": "Q4 Report",
  "category": "financial",
  "tags": ["2025", "quarterly"]
}
------Boundary--
```

**Components work together:**
- Method: Upload/create
- Authorization: Verify user
- Content-Type: Multipart with boundary
- Body: File + metadata

**Server response:**
```http
HTTP/1.1 201 Created
Location: /files/file-abc-123
Content-Type: application/json

{
  "id": "file-abc-123",
  "filename": "report.pdf",
  "size": 1024000,
  "url": "/files/file-abc-123/download",
  "metadata": {
    "title": "Q4 Report",
    "category": "financial"
  },
  "uploadedAt": "2026-01-13T10:00:00Z"
}
```

---

### Pattern 6: Complex Search (POST with Query Body)

```http
POST /products/search
Authorization: Bearer token123
Content-Type: application/json
Accept: application/json

{
  "filters": {
    "categories": ["electronics", "computers"],
    "priceRange": {"min": 500, "max": 2000},
    "brands": ["Apple", "Dell", "HP"],
    "inStock": true
  },
  "sort": {"field": "price", "order": "asc"},
  "pagination": {"page": 1, "limit": 20}
}
```

**Components work together:**
- Method: POST (for complex search)
- URI: Search endpoint
- Authorization: Personalize results
- Body: Complex search criteria

**Server response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
X-Total-Count: 150

{
  "results": [
    {"id": 1, "name": "MacBook", "price": 1299},
    {"id": 2, "name": "Dell XPS", "price": 1199}
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "pages": 8
  }
}
```

---

### Pattern 7: Batch Operations

```http
POST /users/batch-update
Authorization: Bearer admin-token
Content-Type: application/json
X-Idempotency-Key: batch-abc-123

{
  "userIds": [1, 2, 3, 4, 5],
  "update": {
    "status": "verified",
    "verifiedAt": "2026-01-13T10:00:00Z"
  }
}
```

**Components work together:**
- Method: POST (batch action)
- Authorization: Admin permission
- X-Idempotency-Key: Prevent duplicate execution
- Body: Users to update + changes

**Server response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
X-Request-ID: req-xyz-789

{
  "success": 5,
  "failed": 0,
  "results": [
    {"userId": 1, "status": "updated"},
    {"userId": 2, "status": "updated"},
    {"userId": 3, "status": "updated"},
    {"userId": 4, "status": "updated"},
    {"userId": 5, "status": "updated"}
  ]
}
```

---

### Pattern 8: Partial Response with Includes

```http
GET /posts/42?include=author,comments&fields=title,content
Authorization: Bearer token123
Accept: application/json
```

**Components work together:**
- Method: GET (retrieve)
- URI path: Post 42
- Query params: Include related resources, select fields
- Authorization: Check permissions

**Server response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: private, max-age=300

{
  "id": 42,
  "title": "My Post",
  "content": "Post content here...",
  "author": {
    "id": 10,
    "name": "Jane Doe",
    "avatar": "/avatars/10"
  },
  "comments": [
    {
      "id": 1,
      "text": "Great post!",
      "author": "John"
    }
  ]
}
```

---

## Request Validation Flow

### How Components Are Validated Together

```
┌────────────────────────────────────────────────┐
│ 1. REQUEST LINE VALIDATION                     │
│    ✓ Valid HTTP method?                        │
│    ✓ Valid URI format?                         │
│    ✓ Endpoint exists?                          │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 2. HEADER VALIDATION                           │
│    ✓ Host header present? (mandatory)          │
│    ✓ Content-Type matches body?                │
│    ✓ Authorization valid?                      │
│    ✓ Accept format supported?                  │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 3. AUTHENTICATION & AUTHORIZATION              │
│    ✓ User authenticated?                       │
│    ✓ User authorized for this resource?        │
│    ✓ User has required permissions?            │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 4. BODY VALIDATION                             │
│    ✓ Body format matches Content-Type?         │
│    ✓ JSON/XML well-formed?                     │
│    ✓ Required fields present?                  │
│    ✓ Field types correct?                      │
│    ✓ Business rules satisfied?                 │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 5. CONDITIONAL VALIDATION                      │
│    ✓ If-Match: ETag matches?                   │
│    ✓ If-None-Match: ETag differs?              │
│    ✓ If-Modified-Since: Resource changed?      │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 6. PROCESS REQUEST                             │
│    → Execute business logic                     │
│    → Return appropriate response                │
└────────────────────────────────────────────────┘
```

---

## Component Dependency Matrix

### Which Components Require Which

| Method | URI | Headers Required | Body | Query Params |
|--------|-----|------------------|------|--------------|
| GET | Required | Host, Accept | ❌ No | Optional |
| POST | Required | Host, Content-Type, Accept | ✅ Yes | Optional |
| PUT | Required | Host, Content-Type, Accept | ✅ Yes | Optional |
| PATCH | Required | Host, Content-Type, Accept | ✅ Yes | Optional |
| DELETE | Required | Host, Accept | Usually No | Optional |
| HEAD | Required | Host, Accept | ❌ No | Optional |
| OPTIONS | Required | Host | ❌ No | Optional |

**Additional context-dependent requirements:**
- **Authorization:** Required for protected endpoints (any method)
- **If-Match:** Required for optimistic locking updates
- **Content-Length:** Recommended with body
- **User-Agent:** Recommended for analytics

---

## Real-World Complete Examples

### Example 1: E-commerce Order Creation

```http
POST /api/v1/users/42/orders HTTP/1.1
Host: api.shop.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQyLCJyb2xlIjoidXNlciJ9.abc
Content-Type: application/json; charset=utf-8
Accept: application/json
Accept-Language: en-US, en;q=0.9
Accept-Encoding: gzip, deflate, br
User-Agent: ShopApp/3.2.1 (iOS 15.0; iPhone 13)
X-Request-ID: order-req-abc-123
X-Idempotency-Key: order-idempotent-xyz-789
Content-Length: 287

{
  "items": [
    {
      "productId": 1001,
      "quantity": 2,
      "price": 29.99
    },
    {
      "productId": 1002,
      "quantity": 1,
      "price": 49.99
    }
  ],
  "shippingAddress": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001",
    "country": "USA"
  },
  "paymentMethod": "card_ending_4242",
  "shippingMethod": "express"
}
```

**Component interactions:**
- **Method + URI:** Create order for user 42
- **Authorization:** Verify it's actually user 42 (or admin)
- **Content-Type + Body:** JSON order data
- **Accept:** Want JSON response
- **Accept-Encoding:** Support compression
- **X-Idempotency-Key:** Prevent duplicate orders on retry
- **X-Request-ID:** Track this specific request

**Server response:**
```http
HTTP/1.1 201 Created
Location: /api/v1/users/42/orders/999
Content-Type: application/json; charset=utf-8
Content-Encoding: gzip
ETag: "order-v1-xyz"
X-Request-ID: order-req-abc-123
Cache-Control: private, no-store
Set-Cookie: cart=; Max-Age=0; Path=/; HttpOnly; Secure

{
  "id": 999,
  "userId": 42,
  "items": [...],
  "subtotal": 109.97,
  "shipping": 15.00,
  "tax": 10.00,
  "total": 134.97,
  "status": "pending",
  "estimatedDelivery": "2026-01-15T18:00:00Z",
  "createdAt": "2026-01-13T10:00:00Z",
  "links": {
    "self": "/api/v1/users/42/orders/999",
    "payment": "/api/v1/orders/999/payment",
    "tracking": "/api/v1/orders/999/tracking"
  }
}
```

---

### Example 2: Updating Profile with Conflict Prevention

```http
PATCH /api/v1/users/42/profile HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQyLCJyb2xlIjoidXNlciJ9.xyz
Content-Type: application/json; charset=utf-8
Accept: application/json
If-Match: "profile-v5"
X-Request-ID: profile-update-req-456
Content-Length: 89

{
  "bio": "Updated biography text",
  "website": "https://newwebsite.com",
  "publicEmail": "public@example.com"
}
```

**Component interactions:**
- **Method:** PATCH (partial update)
- **URI:** User 42's profile
- **Authorization:** Verify user identity
- **If-Match:** Only update if version is still "profile-v5"
- **Content-Type + Body:** JSON with fields to update

**Success response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
ETag: "profile-v6"
Cache-Control: private, max-age=300
X-Request-ID: profile-update-req-456

{
  "id": 42,
  "bio": "Updated biography text",
  "website": "https://newwebsite.com",
  "publicEmail": "public@example.com",
  "version": 6,
  "updatedAt": "2026-01-13T10:05:00Z"
}
```

**Conflict response:**
```http
HTTP/1.1 412 Precondition Failed
Content-Type: application/json; charset=utf-8
ETag: "profile-v7"
X-Request-ID: profile-update-req-456

{
  "error": "Precondition Failed",
  "message": "Profile was modified by another session",
  "currentVersion": "profile-v7",
  "requestedVersion": "profile-v5",
  "links": {
    "current": "/api/v1/users/42/profile"
  }
}
```

---

### Example 3: Cached Data Retrieval

```http
GET /api/v1/products/123 HTTP/1.1
Host: api.shop.com
Accept: application/json
Accept-Encoding: gzip, br
Accept-Language: en-US
If-None-Match: "product-v3"
If-Modified-Since: Wed, 10 Jan 2026 10:00:00 GMT
```

**Component interactions:**
- **Method:** GET (retrieve)
- **URI:** Product 123
- **If-None-Match:** Check if cached version is still valid
- **If-Modified-Since:** Alternative cache validation
- **Accept-Encoding:** Accept compressed response

**Not modified (use cache):**
```http
HTTP/1.1 304 Not Modified
ETag: "product-v3"
Last-Modified: Wed, 10 Jan 2026 10:00:00 GMT
Cache-Control: public, max-age=3600
Vary: Accept-Encoding, Accept-Language
```

**Modified (new data):**
```http
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Encoding: gzip
ETag: "product-v4"
Last-Modified: Thu, 11 Jan 2026 15:30:00 GMT
Cache-Control: public, max-age=3600
Vary: Accept-Encoding, Accept-Language

[compressed JSON data]
```

---

## Best Practices for Component Composition

### 1. Ensure Component Consistency

```javascript
// ✅ Consistent - All components align
POST /users
Content-Type: application/json
Body: {"name": "John", "email": "john@example.com"}

// ❌ Inconsistent - Content-Type doesn't match body
POST /users
Content-Type: application/json
Body: name=John&email=john@example.com  // This is form data!
```

### 2. Include All Required Headers

```javascript
// ✅ Complete request
POST /users
Host: api.example.com
Content-Type: application/json
Accept: application/json
Authorization: Bearer token123
Content-Length: 56

{"name": "John"}

// ❌ Missing headers
POST /users
{"name": "John"}  // Missing Host, Content-Type, etc.
```

### 3. Use Appropriate Method for Body

```javascript
// ✅ Correct - POST with body
POST /users
Content-Type: application/json
{"name": "John"}

// ❌ Wrong - GET shouldn't have body
GET /users
Content-Type: application/json
{"filter": "active"}  // Use query params instead!

// ✅ Correct alternative
GET /users?status=active
```

### 4. Match Accept and Response Content-Type

```javascript
// Request
GET /users/42
Accept: application/json

// ✅ Response matches
HTTP/1.1 200 OK
Content-Type: application/json
{"id": 42, "name": "John"}

// ❌ Response doesn't match (should return 406)
HTTP/1.1 200 OK
Content-Type: application/xml
<user>...</user>
```

### 5. Use Conditional Headers Appropriately

```javascript
// ✅ Update with conflict prevention
PUT /documents/42
If-Match: "v5"
{"content": "updated"}

// ✅ Get only if changed
GET /documents/42
If-None-Match: "v5"

// ❌ Conditional header with wrong method
POST /documents  // Creating new, conditions don't apply
If-Match: "v5"
```

### 6. Provide Context with Custom Headers

```javascript
// ✅ Good - Trackable request
POST /orders
Authorization: Bearer token123
X-Request-ID: req-abc-123
X-Idempotency-Key: order-xyz-789
Content-Type: application/json

{...}
```

---

## Common Mistakes

### Mistake 1: Wrong Method-Body Combination

```javascript
// ❌ GET with body (non-standard)
GET /users
Content-Type: application/json
{"filter": {"status": "active"}}

// ✅ Use query params or POST
GET /users?status=active
// or
POST /users/search
{"filter": {"status": "active"}}
```

### Mistake 2: Missing Content-Type with Body

```javascript
// ❌ No Content-Type
POST /users
{"name": "John"}

// ✅ Include Content-Type
POST /users
Content-Type: application/json
{"name": "John"}
```

### Mistake 3: Inconsistent Authentication

```javascript
// ❌ Sometimes using Authorization, sometimes custom header
Request 1:
Authorization: Bearer token123

Request 2:
X-Auth-Token: token123  // Inconsistent!

// ✅ Always use the same header
Authorization: Bearer token123
```

### Mistake 4: Ignoring Cache Headers

```javascript
// ❌ Ignoring server cache directives
Server: Cache-Control: max-age=3600, ETag: "v5"
Client: Makes same request immediately without If-None-Match

// ✅ Respect cache directives
GET /data
If-None-Match: "v5"
```

### Mistake 5: Not Using Idempotency Keys

```javascript
// ❌ Retry without idempotency key
POST /payments
{"amount": 100.00}
// Network error, retry
POST /payments
{"amount": 100.00}  // Might charge twice!

// ✅ Use idempotency key
POST /payments
X-Idempotency-Key: payment-unique-123
{"amount": 100.00}
// Safe to retry
```

---

## Summary

### Request Components Work Together

**The Complete Picture:**
```
Request = Method + URI + Headers + Body (optional)

Each component has a role:
├─ Method: What action to perform
├─ URI: On which resource
├─ Headers: Context, format, authentication
└─ Body: Data to send (when applicable)

Together they form a complete, unambiguous instruction.
```

### Key Principles

1. **All components must be consistent** - They should tell a coherent story
2. **Headers provide context** - They describe how to interpret the request
3. **Method determines body presence** - GET/DELETE usually no body, POST/PUT/PATCH yes
4. **URI identifies, method acts** - Separation of concerns
5. **Conditional headers enable optimization** - Caching, conflict prevention
6. **Authentication applies across all** - Security is holistic

### Component Checklist

**Every request should have:**
- ✅ Appropriate HTTP method
- ✅ Valid, well-formed URI
- ✅ Host header (mandatory)
- ✅ Content-Type (if body present)
- ✅ Accept (preferred response format)
- ✅ Authorization (if protected)
- ✅ Consistent body format
- ✅ Appropriate conditional headers (for caching/locking)

**Remember:** The quality of your API depends on how well these components work together.

---

## Next Steps

Now that you understand how request components work together, explore:
- Response components and how they mirror requests
- Complete request-response cycles in detail
- Error handling across all components
- Testing strategies for component interactions
- Client libraries and how they manage components
