# Caching - Performance Optimization for REST APIs

## Introduction

**Caching** stores copies of responses to avoid regenerating the same data repeatedly. A cached response can be served in milliseconds instead of hundreds of milliseconds.

**Key principle:** Don't recompute what hasn't changed.

---

## Why Caching?

### Without Caching

```javascript
// Every request hits the database
GET /api/users/42

Server:
1. Query database (50ms)
2. Process data (10ms)
3. Generate JSON (5ms)
4. Send response (15ms)
Total: 80ms per request

// 1000 requests/second = 1000 database queries/second
// Database: ðŸ’¥ Overloaded
```

### With Caching

```javascript
// First request
GET /api/users/42
Response: 80ms (database + processing)
Cache-Control: max-age=300

// Subsequent requests within 5 minutes
GET /api/users/42
Response: 2ms (from cache)

// Benefits:
// âœ… 40x faster response
// âœ… 1000 requests/second = 1 database query/5 minutes
// âœ… Lower server load
// âœ… Better user experience
// âœ… Lower costs
```

### Benefits

1. **Performance**
   - Sub-millisecond response times
   - Reduced latency
   - Better user experience

2. **Scalability**
   - Handle more requests with same infrastructure
   - Reduce database load
   - Lower CPU usage

3. **Cost Reduction**
   - Less computation = lower costs
   - Smaller infrastructure needed
   - Reduced bandwidth (304 responses)

4. **Availability**
   - Serve cached data if backend is down
   - Graceful degradation
   - Better reliability

---

## HTTP Caching Headers

### Cache-Control

Most important caching header. Controls who can cache and for how long.

```http
HTTP/1.1 200 OK
Cache-Control: public, max-age=300
```

**Directives:**

| Directive | Description | Example |
|-----------|-------------|---------|
| `public` | Can be cached by browsers and CDNs | `Cache-Control: public` |
| `private` | Only browser can cache (not CDNs) | `Cache-Control: private` |
| `no-cache` | Must revalidate before using cache | `Cache-Control: no-cache` |
| `no-store` | Don't cache at all | `Cache-Control: no-store` |
| `max-age=N` | Cache for N seconds | `Cache-Control: max-age=3600` |
| `s-maxage=N` | Cache for N seconds (shared caches only) | `Cache-Control: s-maxage=7200` |
| `must-revalidate` | Must revalidate when stale | `Cache-Control: must-revalidate` |
| `proxy-revalidate` | Shared caches must revalidate | `Cache-Control: proxy-revalidate` |
| `immutable` | Never changes (forever cached) | `Cache-Control: immutable` |
| `stale-while-revalidate=N` | Serve stale while refreshing | `Cache-Control: stale-while-revalidate=60` |
| `stale-if-error=N` | Serve stale if error | `Cache-Control: stale-if-error=86400` |

**Common Combinations:**

```http
# Public resource, cache 1 hour
Cache-Control: public, max-age=3600

# User-specific data, cache 5 minutes (browser only)
Cache-Control: private, max-age=300

# Always revalidate (but can cache)
Cache-Control: public, max-age=300, must-revalidate

# Never cache sensitive data
Cache-Control: no-store, no-cache, must-revalidate

# Static assets (never change)
Cache-Control: public, max-age=31536000, immutable

# CDN cache longer than browser
Cache-Control: public, max-age=300, s-maxage=3600

# Serve stale while revalidating
Cache-Control: max-age=600, stale-while-revalidate=300
```

### ETag (Entity Tag)

Unique identifier for a specific version of a resource.

```http
# Server sends ETag
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Content-Type: application/json

{ "id": 42, "name": "John" }

# Client sends ETag in next request
GET /api/users/42
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# If not modified, server responds with 304
HTTP/1.1 304 Not Modified
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
(no body)

# If modified, server responds with new data
HTTP/1.1 200 OK
ETag: "98f6bcd4621d373cade4e832627b4f6"
Content-Type: application/json

{ "id": 42, "name": "John Doe" }
```

**Strong vs Weak ETags:**

```http
# Strong ETag (default)
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
# Byte-for-byte identical

# Weak ETag
ETag: W/"33a64df551425fcc55e4d42a148795d9f25f89d4"
# Semantically equivalent (minor differences ok)
```

### Last-Modified

Timestamp of when resource was last changed.

```http
# Server sends Last-Modified
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
Content-Type: application/json

{ "id": 42, "name": "John" }

# Client sends If-Modified-Since in next request
GET /api/users/42
If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT

# If not modified
HTTP/1.1 304 Not Modified
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
(no body)

# If modified
HTTP/1.1 200 OK
Last-Modified: Thu, 22 Oct 2025 10:15:00 GMT
Content-Type: application/json

{ "id": 42, "name": "John Doe" }
```

### Expires (Legacy)

Absolute date when cache expires. Replaced by `Cache-Control: max-age`.

```http
HTTP/1.1 200 OK
Expires: Thu, 01 Dec 2025 16:00:00 GMT
```

**Problem:** Time zone issues, clock skew.  
**Better:** Use `Cache-Control: max-age` (relative time).

### Pragma (Legacy)

Backward compatibility with HTTP/1.0.

```http
Cache-Control: no-cache
Pragma: no-cache
```

### Vary

Indicates which request headers affect response (for cache key).

```http
# Cache varies by Accept-Encoding header
Vary: Accept-Encoding

# Different cache for each language
Vary: Accept-Language

# Different cache for each user
Vary: Authorization

# Multiple headers
Vary: Accept-Encoding, Accept-Language
```

---

## 304 Not Modified

Server tells client "use your cached copy."

```
Client                                 Server
  |                                      |
  | GET /api/users/42                    |
  | If-None-Match: "abc123"              |
  |------------------------------------->|
  |                                      |
  |   Check if ETag matches              |
  |   If matches: return 304             |
  |                                      |
  | HTTP/1.1 304 Not Modified            |
  | ETag: "abc123"                       |
  | (no body)                            |
  |<-------------------------------------|
  |                                      |
  | Client uses cached response          |
  |                                      |
```

**Benefits:**
- âœ… No response body (saves bandwidth)
- âœ… Fast response
- âœ… Guarantees freshness

---

## Implementation Examples

### Basic Cache-Control

```javascript
app.get('/api/users', async (req, res) => {
  const users = await db.users.find().toArray();
  
  // Cache for 5 minutes
  res.set('Cache-Control', 'public, max-age=300');
  res.json(users);
});

// Static data: cache longer
app.get('/api/countries', async (req, res) => {
  const countries = await db.countries.find().toArray();
  
  // Cache for 1 day
  res.set('Cache-Control', 'public, max-age=86400');
  res.json(countries);
});

// User data: private cache
app.get('/api/users/me', authenticate, async (req, res) => {
  const user = await db.users.findById(req.user.id);
  
  // Cache in browser only, 5 minutes
  res.set('Cache-Control', 'private, max-age=300');
  res.json(user);
});

// Sensitive data: no cache
app.get('/api/users/me/payments', authenticate, async (req, res) => {
  const payments = await db.payments.find({ userId: req.user.id });
  
  // Never cache
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.json(payments);
});
```

### ETag Implementation

```javascript
const crypto = require('crypto');

function generateETag(data) {
  return crypto
    .createHash('md5')
    .update(JSON.stringify(data))
    .digest('hex');
}

app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  // Generate ETag
  const etag = generateETag(user);
  
  // Check If-None-Match header
  const clientETag = req.headers['if-none-match'];
  
  if (clientETag === etag) {
    // Not modified
    return res.status(304)
      .set('ETag', etag)
      .send();
  }
  
  // Modified, send new data
  res.set('ETag', etag)
    .set('Cache-Control', 'public, max-age=300')
    .json(user);
});
```

### Last-Modified Implementation

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  const lastModified = new Date(user.updated_at);
  
  // Check If-Modified-Since header
  const ifModifiedSince = req.headers['if-modified-since'];
  
  if (ifModifiedSince) {
    const clientDate = new Date(ifModifiedSince);
    
    if (lastModified <= clientDate) {
      // Not modified
      return res.status(304)
        .set('Last-Modified', lastModified.toUTCString())
        .send();
    }
  }
  
  // Modified, send new data
  res.set('Last-Modified', lastModified.toUTCString())
    .set('Cache-Control', 'public, max-age=300')
    .json(user);
});
```

### Combined ETag + Last-Modified

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  const etag = generateETag(user);
  const lastModified = new Date(user.updated_at);
  
  // Check both validators
  const clientETag = req.headers['if-none-match'];
  const ifModifiedSince = req.headers['if-modified-since'];
  
  let notModified = false;
  
  // If ETag provided, it takes precedence
  if (clientETag) {
    notModified = (clientETag === etag);
  } else if (ifModifiedSince) {
    const clientDate = new Date(ifModifiedSince);
    notModified = (lastModified <= clientDate);
  }
  
  if (notModified) {
    return res.status(304)
      .set('ETag', etag)
      .set('Last-Modified', lastModified.toUTCString())
      .send();
  }
  
  // Send new data
  res.set('ETag', etag)
    .set('Last-Modified', lastModified.toUTCString())
    .set('Cache-Control', 'public, max-age=300')
    .json(user);
});
```

### Middleware for Caching

```javascript
function cacheControl(options) {
  return (req, res, next) => {
    const {
      maxAge = 300,
      privacy = 'public',
      immutable = false,
      mustRevalidate = false
    } = options;
    
    const directives = [privacy, `max-age=${maxAge}`];
    
    if (immutable) directives.push('immutable');
    if (mustRevalidate) directives.push('must-revalidate');
    
    res.set('Cache-Control', directives.join(', '));
    next();
  };
}

// Usage
app.get('/api/countries',
  cacheControl({ maxAge: 86400 }),
  async (req, res) => {
    const countries = await db.countries.find();
    res.json(countries);
  }
);

app.get('/api/users/me',
  authenticate,
  cacheControl({ privacy: 'private', maxAge: 300 }),
  async (req, res) => {
    const user = await db.users.findById(req.user.id);
    res.json(user);
  }
);
```

---

## Server-Side Caching

### Redis Cache

```javascript
const Redis = require('ioredis');
const redis = new Redis();

async function getCachedUser(userId) {
  const cacheKey = `user:${userId}`;
  
  // Try cache first
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // Cache miss: get from database
  const user = await db.users.findById(userId);
  
  // Store in cache for 5 minutes
  await redis.set(cacheKey, JSON.stringify(user), 'EX', 300);
  
  return user;
}

app.get('/api/users/:id', async (req, res) => {
  const user = await getCachedUser(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.set('Cache-Control', 'public, max-age=300')
    .json(user);
});
```

### Cache-Aside Pattern

```javascript
class CacheService {
  constructor(redis, db) {
    this.redis = redis;
    this.db = db;
  }
  
  async get(key, fetchFn, ttl = 300) {
    // 1. Try cache
    const cached = await this.redis.get(key);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // 2. Cache miss: fetch from source
    const data = await fetchFn();
    
    // 3. Store in cache
    if (data) {
      await this.redis.set(key, JSON.stringify(data), 'EX', ttl);
    }
    
    return data;
  }
  
  async invalidate(key) {
    await this.redis.del(key);
  }
  
  async invalidatePattern(pattern) {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}

const cache = new CacheService(redis, db);

// Usage
app.get('/api/users/:id', async (req, res) => {
  const user = await cache.get(
    `user:${req.params.id}`,
    () => db.users.findById(req.params.id),
    300 // 5 minutes
  );
  
  res.json(user);
});

// Invalidate on update
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  
  // Invalidate cache
  await cache.invalidate(`user:${req.params.id}`);
  
  res.json(user);
});
```

### Read-Through Cache

```javascript
class ReadThroughCache {
  constructor(redis, db) {
    this.redis = redis;
    this.db = db;
  }
  
  async getUser(userId) {
    const cacheKey = `user:${userId}`;
    
    // Try cache
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Not in cache: get from DB and cache
    const user = await this.db.users.findById(userId);
    
    if (user) {
      await this.redis.set(cacheKey, JSON.stringify(user), 'EX', 300);
    }
    
    return user;
  }
}

const cache = new ReadThroughCache(redis, db);

app.get('/api/users/:id', async (req, res) => {
  const user = await cache.getUser(req.params.id);
  res.json(user);
});
```

### Write-Through Cache

```javascript
class WriteThroughCache {
  constructor(redis, db) {
    this.redis = redis;
    this.db = db;
  }
  
  async updateUser(userId, updates) {
    // 1. Update database
    const user = await this.db.users.update(userId, updates);
    
    // 2. Update cache immediately
    const cacheKey = `user:${userId}`;
    await this.redis.set(cacheKey, JSON.stringify(user), 'EX', 300);
    
    return user;
  }
}

const cache = new WriteThroughCache(redis, db);

app.put('/api/users/:id', async (req, res) => {
  const user = await cache.updateUser(req.params.id, req.body);
  res.json(user);
});
```

---

## Cache Invalidation Strategies

### 1. Time-Based Expiration (TTL)

```javascript
// Cache for 5 minutes
await redis.set('user:42', JSON.stringify(user), 'EX', 300);

// After 5 minutes, cache automatically expires
```

**Pros:** Simple, automatic  
**Cons:** Might serve stale data

### 2. Manual Invalidation

```javascript
// Update user
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  
  // Invalidate cache
  await redis.del(`user:${req.params.id}`);
  
  res.json(user);
});
```

**Pros:** Fresh data  
**Cons:** Must remember to invalidate

### 3. Pattern-Based Invalidation

```javascript
// Invalidate all user-related caches
await redis.keys('user:*').then(keys => {
  if (keys.length > 0) {
    return redis.del(...keys);
  }
});

// Better: Use Redis SCAN to avoid blocking
async function invalidatePattern(pattern) {
  let cursor = '0';
  do {
    const [newCursor, keys] = await redis.scan(
      cursor,
      'MATCH',
      pattern,
      'COUNT',
      100
    );
    cursor = newCursor;
    
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  } while (cursor !== '0');
}

await invalidatePattern('user:*');
```

### 4. Event-Based Invalidation

```javascript
const EventEmitter = require('events');
const events = new EventEmitter();

// Listen for user updates
events.on('user:updated', async (userId) => {
  await redis.del(`user:${userId}`);
  await redis.del(`user:${userId}:orders`);
  console.log(`Cache invalidated for user ${userId}`);
});

// Update user
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  
  // Emit event
  events.emit('user:updated', req.params.id);
  
  res.json(user);
});
```

### 5. Cache Tagging

```javascript
class TaggedCache {
  constructor(redis) {
    this.redis = redis;
  }
  
  async set(key, value, ttl, tags = []) {
    // Store value
    await this.redis.set(key, JSON.stringify(value), 'EX', ttl);
    
    // Add to tag sets
    for (const tag of tags) {
      await this.redis.sadd(`tag:${tag}`, key);
      await this.redis.expire(`tag:${tag}`, ttl);
    }
  }
  
  async invalidateTag(tag) {
    // Get all keys with this tag
    const keys = await this.redis.smembers(`tag:${tag}`);
    
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
    
    // Remove tag set
    await this.redis.del(`tag:${tag}`);
  }
}

const cache = new TaggedCache(redis);

// Set with tags
await cache.set('user:42', user, 300, ['user', 'user:42', 'active-users']);

// Invalidate all active users
await cache.invalidateTag('active-users');
```

---

## CDN Integration

### CDN Caching Headers

```javascript
app.get('/api/public/countries', async (req, res) => {
  const countries = await db.countries.find();
  
  // Browser cache: 5 minutes
  // CDN cache: 1 hour
  res.set('Cache-Control', 'public, max-age=300, s-maxage=3600');
  res.json(countries);
});
```

### CDN Cache Purging

```javascript
const axios = require('axios');

async function purgeCDNCache(url) {
  // Cloudflare example
  await axios.post(
    `https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/purge_cache`,
    { files: [url] },
    { headers: { 'X-Auth-Key': CF_API_KEY } }
  );
}

app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  
  // Purge CDN cache
  await purgeCDNCache(`https://api.example.com/api/users/${req.params.id}`);
  
  res.json(user);
});
```

### CDN with Surrogate Keys

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  res.set('Cache-Control', 'public, max-age=300, s-maxage=3600')
    .set('Surrogate-Key', `user user-${user.id}`) // Fastly/Cloudflare
    .json(user);
});

// Purge by surrogate key
async function purgeSurrogateKey(key) {
  await axios.post(
    'https://api.fastly.com/service/SERVICE_ID/purge',
    { surrogate_keys: [key] },
    { headers: { 'Fastly-Key': FASTLY_API_KEY } }
  );
}

// Purge all user caches
await purgeSurrogateKey('user');
```

---

## Vary Header for Content Negotiation

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  const acceptEncoding = req.headers['accept-encoding'];
  
  // Cache varies by encoding
  res.set('Vary', 'Accept-Encoding');
  
  // Compress if supported
  if (acceptEncoding && acceptEncoding.includes('gzip')) {
    res.set('Content-Encoding', 'gzip');
    // ... compress response
  }
  
  res.json(user);
});

// Different response per language
app.get('/api/products', async (req, res) => {
  const lang = req.headers['accept-language'] || 'en';
  const products = await db.products.find({ language: lang });
  
  // Separate cache per language
  res.set('Vary', 'Accept-Language')
    .set('Cache-Control', 'public, max-age=300')
    .json(products);
});

// Different response per user (Authorization)
app.get('/api/dashboard', authenticate, async (req, res) => {
  const dashboard = await getDashboard(req.user);
  
  // Separate cache per user
  res.set('Vary', 'Authorization')
    .set('Cache-Control', 'private, max-age=60')
    .json(dashboard);
});
```

---

## Stale-While-Revalidate

Serve stale content while refreshing in background.

```javascript
app.get('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  // Cache for 10 minutes
  // Serve stale for 5 more minutes while revalidating
  res.set('Cache-Control', 'max-age=600, stale-while-revalidate=300')
    .json(user);
});

/* Timeline:
0-10 min: Fresh (serve from cache)
10-15 min: Stale (serve from cache + trigger revalidation in background)
After 15 min: Expired (fetch fresh)
*/
```

**Benefits:**
- âœ… Always fast (serve cached)
- âœ… Always fresh (revalidate in background)
- âœ… Better UX

---

## Conditional Requests

### If-None-Match (ETag)

```javascript
const etag = generateETag(user);

if (req.headers['if-none-match'] === etag) {
  return res.status(304).set('ETag', etag).send();
}

res.set('ETag', etag).json(user);
```

### If-Modified-Since

```javascript
const lastModified = new Date(user.updated_at);
const ifModifiedSince = req.headers['if-modified-since'];

if (ifModifiedSince && lastModified <= new Date(ifModifiedSince)) {
  return res.status(304)
    .set('Last-Modified', lastModified.toUTCString())
    .send();
}

res.set('Last-Modified', lastModified.toUTCString()).json(user);
```

### If-Match (Optimistic Locking)

```javascript
// Client sends ETag with update
PUT /api/users/42
If-Match: "abc123"
{ "name": "New Name" }

app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  const currentETag = generateETag(user);
  const clientETag = req.headers['if-match'];
  
  // Check if ETags match
  if (clientETag && clientETag !== currentETag) {
    // Resource was modified by someone else
    return res.status(412).json({
      error: {
        code: 'PRECONDITION_FAILED',
        message: 'Resource was modified. Please refresh and try again.',
        currentETag
      }
    });
  }
  
  // Update user
  const updated = await db.users.update(req.params.id, req.body);
  const newETag = generateETag(updated);
  
  res.set('ETag', newETag).json(updated);
});
```

---

## Best Practices

### 1. Cache Immutable Resources Forever

```javascript
// Static assets with hash in filename
// /assets/app.a8f3d2c1.js â†’ never changes
app.get('/assets/*', (req, res) => {
  res.set('Cache-Control', 'public, max-age=31536000, immutable');
  res.sendFile(req.path);
});
```

### 2. Use Short Cache for Dynamic Data

```javascript
// User data changes frequently
app.get('/api/users/:id', async (req, res) => {
  const user = await getCachedUser(req.params.id);
  
  // Cache for 5 minutes
  res.set('Cache-Control', 'public, max-age=300')
    .json(user);
});
```

### 3. Never Cache Sensitive Data

```javascript
// Payment information
app.get('/api/payments', authenticate, async (req, res) => {
  const payments = await db.payments.find({ userId: req.user.id });
  
  // Never cache
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate')
    .set('Pragma', 'no-cache')
    .json(payments);
});
```

### 4. Use Private Cache for User Data

```javascript
// User-specific data
app.get('/api/users/me', authenticate, async (req, res) => {
  const user = await db.users.findById(req.user.id);
  
  // Cache in browser only (not CDN)
  res.set('Cache-Control', 'private, max-age=300')
    .json(user);
});
```

### 5. Set Vary Header Appropriately

```javascript
// Response depends on Accept-Encoding
app.get('/api/data', (req, res) => {
  res.set('Vary', 'Accept-Encoding');
  // ... send compressed or uncompressed
});

// Response depends on Authorization
app.get('/api/dashboard', authenticate, (req, res) => {
  res.set('Vary', 'Authorization');
  // ... user-specific content
});
```

### 6. Invalidate Cache on Updates

```javascript
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  
  // Invalidate all related caches
  await redis.del(`user:${req.params.id}`);
  await redis.del(`user:${req.params.id}:orders`);
  await purgeCDNCache(`/api/users/${req.params.id}`);
  
  res.json(user);
});
```

### 7. Use ETag for Concurrency Control

```javascript
// Prevent lost updates with If-Match
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  const currentETag = generateETag(user);
  
  if (req.headers['if-match'] !== currentETag) {
    return res.status(412).json({ error: 'Resource modified' });
  }
  
  // Safe to update
  const updated = await db.users.update(req.params.id, req.body);
  res.set('ETag', generateETag(updated)).json(updated);
});
```

---

## Testing Caching

```javascript
describe('Caching', () => {
  it('should set Cache-Control header', async () => {
    const response = await request(app)
      .get('/api/countries');
    
    expect(response.headers['cache-control']).toBe('public, max-age=86400');
  });
  
  it('should set ETag header', async () => {
    const response = await request(app)
      .get('/api/users/42');
    
    expect(response.headers).toHaveProperty('etag');
  });
  
  it('should return 304 when ETag matches', async () => {
    // First request
    const first = await request(app)
      .get('/api/users/42');
    
    const etag = first.headers.etag;
    
    // Second request with If-None-Match
    const second = await request(app)
      .get('/api/users/42')
      .set('If-None-Match', etag);
    
    expect(second.status).toBe(304);
    expect(second.body).toEqual({});
  });
  
  it('should return 200 when ETag does not match', async () => {
    const response = await request(app)
      .get('/api/users/42')
      .set('If-None-Match', 'wrong-etag');
    
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('id', 42);
  });
  
  it('should return 304 when not modified since', async () => {
    const user = await db.users.findById(42);
    const lastModified = new Date(user.updated_at);
    
    const response = await request(app)
      .get('/api/users/42')
      .set('If-Modified-Since', lastModified.toUTCString());
    
    expect(response.status).toBe(304);
  });
  
  it('should invalidate cache on update', async () => {
    // Get user (cache it)
    await request(app).get('/api/users/42');
    
    const cached = await redis.get('user:42');
    expect(cached).toBeTruthy();
    
    // Update user
    await request(app)
      .put('/api/users/42')
      .send({ name: 'Updated' });
    
    // Cache should be invalidated
    const afterUpdate = await redis.get('user:42');
    expect(afterUpdate).toBeNull();
  });
  
  it('should use different cache per Vary header', async () => {
    // Request with English
    const en = await request(app)
      .get('/api/products')
      .set('Accept-Language', 'en');
    
    // Request with Spanish
    const es = await request(app)
      .get('/api/products')
      .set('Accept-Language', 'es');
    
    expect(en.body).not.toEqual(es.body);
    expect(en.headers.vary).toBe('Accept-Language');
  });
});
```

---

## Real-World Examples

### GitHub API

```http
GET https://api.github.com/users/octocat

HTTP/1.1 200 OK
Cache-Control: public, max-age=60, s-maxage=60
ETag: "686897696a7c876b7e"
Last-Modified: Tue, 20 Oct 2025 10:00:00 GMT
Vary: Accept, Accept-Encoding

# Next request with ETag
GET https://api.github.com/users/octocat
If-None-Match: "686897696a7c876b7e"

HTTP/1.1 304 Not Modified
```

### Twitter API

```http
GET https://api.twitter.com/2/tweets/1234567890

HTTP/1.1 200 OK
Cache-Control: no-cache, no-store
# Twitter doesn't cache dynamic content
```

### Stripe API

```http
GET https://api.stripe.com/v1/customers/cus_123

HTTP/1.1 200 OK
Cache-Control: no-cache, no-store
# Stripe doesn't cache (financial data)
```

---

## Common Mistakes

### Mistake 1: Caching Sensitive Data

```javascript
// âŒ Bad: Cache payment info
res.set('Cache-Control', 'public, max-age=300');
res.json({ creditCard: '4111...' });

// âœ… Good: Never cache
res.set('Cache-Control', 'no-store, no-cache');
res.json({ creditCard: '4111...' });
```

### Mistake 2: Not Setting Cache Headers

```javascript
// âŒ Bad: No caching headers
app.get('/api/countries', async (req, res) => {
  res.json(countries);
});

// âœ… Good: Explicit caching
app.get('/api/countries', async (req, res) => {
  res.set('Cache-Control', 'public, max-age=86400');
  res.json(countries);
});
```

### Mistake 3: Wrong Cache Visibility

```javascript
// âŒ Bad: Public cache for user data
res.set('Cache-Control', 'public, max-age=300');
res.json(userPrivateData); // CDN will cache!

// âœ… Good: Private cache
res.set('Cache-Control', 'private, max-age=300');
res.json(userPrivateData);
```

### Mistake 4: Not Invalidating Cache

```javascript
// âŒ Bad: Update without invalidation
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  res.json(user); // Old cached version still served!
});

// âœ… Good: Invalidate cache
app.put('/api/users/:id', async (req, res) => {
  const user = await db.users.update(req.params.id, req.body);
  await redis.del(`user:${req.params.id}`);
  res.json(user);
});
```

### Mistake 5: Missing Vary Header

```javascript
// âŒ Bad: Compressed and uncompressed share cache
app.get('/api/data', (req, res) => {
  if (req.headers['accept-encoding']?.includes('gzip')) {
    res.set('Content-Encoding', 'gzip');
    res.send(compressedData);
  } else {
    res.send(data);
  }
});

// âœ… Good: Vary by encoding
app.get('/api/data', (req, res) => {
  res.set('Vary', 'Accept-Encoding');
  // ... send appropriate version
});
```

---

## Summary

### Key Concepts

- **Caching** = Store responses to avoid recomputation
- **Cache-Control** = Who can cache, for how long
- **ETag** = Version identifier for conditional requests
- **304 Not Modified** = "Use your cached copy"
- **Vary** = Cache key depends on request headers

### Cache-Control Directives

- `public` = Anyone can cache (browsers, CDNs)
- `private` = Only browsers can cache
- `no-store` = Never cache (sensitive data)
- `max-age=N` = Cache for N seconds
- `must-revalidate` = Must check freshness when stale
- `immutable` = Never changes

### Validation

- **ETag** = Strong validator (exact match)
- **Last-Modified** = Weak validator (timestamp)
- **If-None-Match** = Client sends ETag
- **If-Modified-Since** = Client sends timestamp

### Best Practices

âœ… Cache immutable resources forever
âœ… Use short TTL for dynamic data
âœ… Never cache sensitive data
âœ… Use `private` for user-specific data
âœ… Set `Vary` header appropriately
âœ… Invalidate cache on updates
âœ… Use ETag for concurrency control
âœ… Combine multiple cache layers (browser + CDN + server)

### Cache Strategies

- **Time-Based** = Cache expires after TTL
- **Manual** = Invalidate on updates
- **Event-Based** = Listen to events, invalidate
- **Tag-Based** = Group related caches, invalidate by tag

### Common Use Cases

- **Static data** = `Cache-Control: public, max-age=31536000, immutable`
- **Dynamic data** = `Cache-Control: public, max-age=300`
- **User data** = `Cache-Control: private, max-age=300`
- **Sensitive data** = `Cache-Control: no-store, no-cache`

---

## Next Steps

Explore related topics:
- Content negotiation for different formats
- Response compression (gzip, brotli)
- CDN configuration and optimization
- Database query optimization
- Monitoring cache hit rates
