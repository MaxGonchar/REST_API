# HATEOAS - Hypermedia as the Engine of Application State

## Introduction

HATEOAS is a constraint of the REST architectural style where the API provides information about what actions are available at any given moment. Instead of clients knowing all endpoints in advance, the server tells the client what it can do next through hypermedia links.

**Key principle:** The client doesn't need prior knowledge of the API structure. It discovers available actions dynamically through responses.

---

## The Problem HATEOAS Solves

### Traditional API (Without HATEOAS)

```javascript
// Client needs to know all endpoints hardcoded
GET /users/42

Response:
{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com",
  "status": "active"
}

// Client must know:
// - To get orders: GET /users/42/orders
// - To update user: PUT /users/42
// - To deactivate: POST /users/42/deactivate
// All hardcoded in client!
```

**Problems:**
- Client must know all endpoints
- API changes break clients
- No discovery mechanism
- Client needs documentation

### With HATEOAS

```javascript
GET /users/42

Response:
{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com",
  "status": "active",
  "_links": {
    "self": { "href": "/users/42" },
    "orders": { "href": "/users/42/orders" },
    "edit": { "href": "/users/42", "method": "PUT" },
    "deactivate": { "href": "/users/42/deactivate", "method": "POST" },
    "avatar": { "href": "/users/42/avatar" }
  }
}

// Client discovers actions from response!
// If user is deactivated, "deactivate" link won't be present
```

**Benefits:**
- Server tells client what's possible
- Self-documenting API
- Server controls workflow
- Graceful API evolution

---

## How HATEOAS Works

### The Hypermedia Concept

Like a website: You don't know all URLs upfront. You follow links.

```
Browser → Homepage
          ↓
       [About Us] [Products] [Contact]
          ↓
       Products Page
          ↓
       [Product 1] [Product 2]
          ↓
       Product 1 Details
          ↓
       [Add to Cart] [View Reviews]
```

**HATEOAS applies this to APIs:**

```
Client → GET /
         ↓
      { "_links": { "users": "/users", "products": "/products" } }
         ↓
      GET /users
         ↓
      { "_links": { "self": "/users", "first": "/users?page=1" } }
         ↓
      GET /users/42
         ↓
      { "_links": { "orders": "/users/42/orders", "edit": "/users/42" } }
```

---

## Link Formats

### 1. Simple Links

```json
{
  "id": 42,
  "name": "John Doe",
  "links": [
    "/users/42",
    "/users/42/orders",
    "/users/42/avatar"
  ]
}
```

**Problem:** Don't know what each link is for!

### 2. Named Links

```json
{
  "id": 42,
  "name": "John Doe",
  "links": {
    "self": "/users/42",
    "orders": "/users/42/orders",
    "avatar": "/users/42/avatar"
  }
}
```

**Better:** Names give meaning to links.

### 3. Rich Links

```json
{
  "id": 42,
  "name": "John Doe",
  "_links": {
    "self": {
      "href": "/users/42"
    },
    "orders": {
      "href": "/users/42/orders",
      "title": "User's Orders"
    },
    "edit": {
      "href": "/users/42",
      "method": "PUT",
      "title": "Update User"
    }
  }
}
```

**Best:** Includes HTTP method, title, and other metadata.

---

## Standard Formats

### HAL (Hypertext Application Language)

Most popular HATEOAS format.

```json
{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com",
  "status": "active",
  "_links": {
    "self": {
      "href": "/users/42"
    },
    "orders": {
      "href": "/users/42/orders"
    },
    "avatar": {
      "href": "/users/42/avatar",
      "title": "User Avatar"
    }
  },
  "_embedded": {
    "latestOrder": {
      "id": 123,
      "total": 99.99,
      "status": "shipped",
      "_links": {
        "self": { "href": "/orders/123" }
      }
    }
  }
}
```

**HAL Features:**
- `_links`: Related resources
- `_embedded`: Embedded resources (reduces requests)
- Standard format widely supported

### JSON:API

Another standard format.

```json
{
  "data": {
    "type": "users",
    "id": "42",
    "attributes": {
      "name": "John Doe",
      "email": "john@example.com",
      "status": "active"
    },
    "relationships": {
      "orders": {
        "links": {
          "self": "/users/42/relationships/orders",
          "related": "/users/42/orders"
        }
      }
    },
    "links": {
      "self": "/users/42"
    }
  },
  "included": [
    {
      "type": "orders",
      "id": "123",
      "attributes": {
        "total": 99.99,
        "status": "shipped"
      }
    }
  ]
}
```

### Collection+JSON

Format for collections.

```json
{
  "collection": {
    "version": "1.0",
    "href": "/users",
    "links": [
      { "rel": "next", "href": "/users?page=2" },
      { "rel": "prev", "href": "/users?page=1" }
    ],
    "items": [
      {
        "href": "/users/42",
        "data": [
          { "name": "name", "value": "John Doe" },
          { "name": "email", "value": "john@example.com" }
        ],
        "links": [
          { "rel": "orders", "href": "/users/42/orders" }
        ]
      }
    ],
    "template": {
      "data": [
        { "name": "name", "value": "", "prompt": "Full name" },
        { "name": "email", "value": "", "prompt": "Email address" }
      ]
    }
  }
}
```

---

## Implementation Examples

### Basic Implementation (Express.js)

```javascript
// User endpoint with HATEOAS
app.get('/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  // Build HATEOAS response
  const response = {
    id: user.id,
    name: user.name,
    email: user.email,
    status: user.status,
    _links: {
      self: {
        href: `/users/${user.id}`
      },
      orders: {
        href: `/users/${user.id}/orders`,
        title: "User's orders"
      },
      avatar: {
        href: `/users/${user.id}/avatar`,
        title: "User avatar"
      }
    }
  };
  
  // Conditional links based on state
  if (user.status === 'active') {
    response._links.deactivate = {
      href: `/users/${user.id}/deactivate`,
      method: 'POST',
      title: 'Deactivate user'
    };
  } else {
    response._links.activate = {
      href: `/users/${user.id}/activate`,
      method: 'POST',
      title: 'Activate user'
    };
  }
  
  // Permission-based links
  if (req.user.role === 'admin') {
    response._links.edit = {
      href: `/users/${user.id}`,
      method: 'PUT',
      title: 'Edit user'
    };
    response._links.delete = {
      href: `/users/${user.id}`,
      method: 'DELETE',
      title: 'Delete user'
    };
  }
  
  res.json(response);
});
```

### Link Builder Helper

```javascript
class LinkBuilder {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this.links = {};
  }
  
  addLink(rel, href, options = {}) {
    this.links[rel] = {
      href: this.baseUrl + href,
      ...options
    };
    return this;
  }
  
  addSelfLink(href) {
    return this.addLink('self', href);
  }
  
  addIfCondition(condition, rel, href, options = {}) {
    if (condition) {
      this.addLink(rel, href, options);
    }
    return this;
  }
  
  build() {
    return { _links: this.links };
  }
}

// Usage
app.get('/users/:id', async (req, res) => {
  const user = await db.users.findById(req.params.id);
  
  const links = new LinkBuilder('')
    .addSelfLink(`/users/${user.id}`)
    .addLink('orders', `/users/${user.id}/orders`, { title: "User's orders" })
    .addLink('avatar', `/users/${user.id}/avatar`)
    .addIfCondition(
      user.status === 'active',
      'deactivate',
      `/users/${user.id}/deactivate`,
      { method: 'POST' }
    )
    .addIfCondition(
      req.user.role === 'admin',
      'edit',
      `/users/${user.id}`,
      { method: 'PUT' }
    )
    .build();
  
  res.json({
    ...user,
    ...links
  });
});
```

### Collection with Pagination Links

```javascript
app.get('/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    db.users.find().skip(offset).limit(limit),
    db.users.count()
  ]);
  
  const totalPages = Math.ceil(total / limit);
  
  const response = {
    users: users.map(user => ({
      ...user,
      _links: {
        self: { href: `/users/${user.id}` },
        orders: { href: `/users/${user.id}/orders` }
      }
    })),
    _links: {
      self: { href: `/users?page=${page}&limit=${limit}` },
      first: { href: `/users?page=1&limit=${limit}` },
      last: { href: `/users?page=${totalPages}&limit=${limit}` }
    },
    _meta: {
      total,
      page,
      limit,
      totalPages
    }
  };
  
  // Previous page link
  if (page > 1) {
    response._links.prev = {
      href: `/users?page=${page - 1}&limit=${limit}`
    };
  }
  
  // Next page link
  if (page < totalPages) {
    response._links.next = {
      href: `/users?page=${page + 1}&limit=${limit}`
    };
  }
  
  res.json(response);
});
```

### State Machine with HATEOAS

Order workflow example.

```javascript
const ORDER_STATES = {
  pending: ['confirm', 'cancel'],
  confirmed: ['ship', 'cancel'],
  shipped: ['deliver', 'return'],
  delivered: ['return'],
  returned: [],
  cancelled: []
};

app.get('/orders/:id', async (req, res) => {
  const order = await db.orders.findById(req.params.id);
  
  const response = {
    id: order.id,
    total: order.total,
    status: order.status,
    items: order.items,
    _links: {
      self: { href: `/orders/${order.id}` },
      user: { href: `/users/${order.userId}` },
      invoice: { href: `/orders/${order.id}/invoice` }
    }
  };
  
  // Add available actions based on current state
  const availableActions = ORDER_STATES[order.status] || [];
  
  availableActions.forEach(action => {
    response._links[action] = {
      href: `/orders/${order.id}/${action}`,
      method: 'POST',
      title: `${action.charAt(0).toUpperCase() + action.slice(1)} order`
    };
  });
  
  // Tracking link only for shipped orders
  if (order.status === 'shipped' && order.trackingNumber) {
    response._links.tracking = {
      href: `/orders/${order.id}/tracking`,
      title: 'Track shipment'
    };
  }
  
  res.json(response);
});

// Example responses:

// Pending order:
{
  "status": "pending",
  "_links": {
    "self": { "href": "/orders/123" },
    "confirm": { "href": "/orders/123/confirm", "method": "POST" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" }
  }
}

// Confirmed order:
{
  "status": "confirmed",
  "_links": {
    "self": { "href": "/orders/123" },
    "ship": { "href": "/orders/123/ship", "method": "POST" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" }
  }
}

// Shipped order:
{
  "status": "shipped",
  "_links": {
    "self": { "href": "/orders/123" },
    "tracking": { "href": "/orders/123/tracking" },
    "deliver": { "href": "/orders/123/deliver", "method": "POST" },
    "return": { "href": "/orders/123/return", "method": "POST" }
  }
}

// Delivered order:
{
  "status": "delivered",
  "_links": {
    "self": { "href": "/orders/123" },
    "return": { "href": "/orders/123/return", "method": "POST" }
  }
}
```

---

## Link Relations

### Standard Relations (IANA)

Standard link relation types defined by IANA.

```javascript
{
  "_links": {
    "self": { "href": "/users/42" },           // The resource itself
    "first": { "href": "/users?page=1" },      // First page
    "last": { "href": "/users?page=10" },      // Last page
    "next": { "href": "/users?page=3" },       // Next page
    "prev": { "href": "/users?page=1" },       // Previous page
    "up": { "href": "/users" },                 // Parent resource
    "alternate": { "href": "/users/42.xml" },   // Alternative format
    "edit": { "href": "/users/42" },            // Edit resource
    "collection": { "href": "/users" },         // Collection
    "about": { "href": "/docs/users" },         // Documentation
    "author": { "href": "/users/1" },           // Creator
    "related": { "href": "/users/42/posts" }    // Related resource
  }
}
```

### Custom Relations

```javascript
{
  "_links": {
    "self": { "href": "/orders/123" },
    
    // Custom relations (use meaningful names)
    "customer": { "href": "/users/42" },
    "items": { "href": "/orders/123/items" },
    "invoice": { "href": "/orders/123/invoice" },
    "shipping-address": { "href": "/addresses/99" },
    "payment-method": { "href": "/payment-methods/5" },
    
    // Actions
    "cancel": { "href": "/orders/123/cancel", "method": "POST" },
    "refund": { "href": "/orders/123/refund", "method": "POST" }
  }
}
```

---

## Client Implementation

### Navigating HATEOAS API

```javascript
class HateoasClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  
  async get(url) {
    const response = await fetch(this.baseUrl + url);
    return response.json();
  }
  
  async followLink(resource, linkRel, options = {}) {
    const link = resource._links[linkRel];
    
    if (!link) {
      throw new Error(`Link relation '${linkRel}' not found`);
    }
    
    const method = link.method || options.method || 'GET';
    
    const response = await fetch(this.baseUrl + link.href, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      body: options.body ? JSON.stringify(options.body) : undefined
    });
    
    return response.json();
  }
  
  hasLink(resource, linkRel) {
    return !!resource._links?.[linkRel];
  }
  
  async navigatePagination(resource, direction = 'next') {
    if (!this.hasLink(resource, direction)) {
      return null; // No more pages
    }
    
    return this.followLink(resource, direction);
  }
}

// Usage example
const client = new HateoasClient('https://api.example.com');

// Get user
const user = await client.get('/users/42');
console.log('User:', user.name);

// Follow orders link
if (client.hasLink(user, 'orders')) {
  const orders = await client.followLink(user, 'orders');
  console.log('Orders:', orders);
}

// Deactivate user (if link exists)
if (client.hasLink(user, 'deactivate')) {
  await client.followLink(user, 'deactivate', { method: 'POST' });
  console.log('User deactivated');
} else {
  console.log('Cannot deactivate user (link not available)');
}

// Pagination
let currentPage = await client.get('/users?page=1');

while (currentPage) {
  console.log('Users on page:', currentPage.users);
  currentPage = await client.navigatePagination(currentPage, 'next');
}
```

### React Hook for HATEOAS

```javascript
function useHateoas(initialUrl) {
  const [resource, setResource] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const fetchResource = async (url) => {
    setLoading(true);
    try {
      const response = await fetch(url);
      const data = await response.json();
      setResource(data);
      setError(null);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };
  
  const followLink = async (linkRel, options = {}) => {
    if (!resource?._links?.[linkRel]) {
      throw new Error(`Link '${linkRel}' not available`);
    }
    
    const link = resource._links[linkRel];
    const method = link.method || options.method || 'GET';
    
    const response = await fetch(link.href, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      body: options.body ? JSON.stringify(options.body) : undefined
    });
    
    const data = await response.json();
    setResource(data);
    return data;
  };
  
  const hasLink = (linkRel) => {
    return !!resource?._links?.[linkRel];
  };
  
  useEffect(() => {
    fetchResource(initialUrl);
  }, [initialUrl]);
  
  return {
    resource,
    loading,
    error,
    followLink,
    hasLink,
    refresh: () => fetchResource(initialUrl)
  };
}

// Usage in component
function UserProfile({ userId }) {
  const { resource: user, loading, followLink, hasLink } = useHateoas(`/users/${userId}`);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      
      {hasLink('orders') && (
        <button onClick={() => followLink('orders')}>
          View Orders
        </button>
      )}
      
      {hasLink('deactivate') && (
        <button onClick={() => followLink('deactivate')}>
          Deactivate
        </button>
      )}
      
      {hasLink('edit') && (
        <button onClick={() => followLink('edit', {
          method: 'PUT',
          body: { name: 'New Name' }
        })}>
          Edit
        </button>
      )}
    </div>
  );
}
```

---

## Real-World Examples

### GitHub API (Uses HATEOAS)

```javascript
GET https://api.github.com/repos/octocat/Hello-World

Response:
{
  "id": 1296269,
  "name": "Hello-World",
  "full_name": "octocat/Hello-World",
  "owner": {
    "login": "octocat",
    "id": 1,
    "url": "https://api.github.com/users/octocat"
  },
  "html_url": "https://github.com/octocat/Hello-World",
  "description": "My first repository",
  "url": "https://api.github.com/repos/octocat/Hello-World",
  "forks_url": "https://api.github.com/repos/octocat/Hello-World/forks",
  "issues_url": "https://api.github.com/repos/octocat/Hello-World/issues{/number}",
  "pulls_url": "https://api.github.com/repos/octocat/Hello-World/pulls{/number}",
  "commits_url": "https://api.github.com/repos/octocat/Hello-World/commits{/sha}",
  ...
}

// Notice: URLs for related resources are in the response!
```

### PayPal API (Uses HATEOAS)

```javascript
POST https://api.paypal.com/v2/checkout/orders

Response:
{
  "id": "5O190127TN364715T",
  "status": "CREATED",
  "links": [
    {
      "href": "https://api.paypal.com/v2/checkout/orders/5O190127TN364715T",
      "rel": "self",
      "method": "GET"
    },
    {
      "href": "https://www.paypal.com/checkoutnow?token=5O190127TN364715T",
      "rel": "approve",
      "method": "GET"
    },
    {
      "href": "https://api.paypal.com/v2/checkout/orders/5O190127TN364715T",
      "rel": "update",
      "method": "PATCH"
    },
    {
      "href": "https://api.paypal.com/v2/checkout/orders/5O190127TN364715T/capture",
      "rel": "capture",
      "method": "POST"
    }
  ]
}

// Client follows "approve" link to redirect user
// Then follows "capture" link to complete payment
```

---

## Pros and Cons

### Advantages

✅ **Self-Documenting**
- API tells you what you can do
- Reduces need for external documentation

✅ **Loose Coupling**
- Client doesn't hardcode URLs
- Server can change URLs without breaking clients

✅ **State-Driven**
- Available actions depend on resource state
- Prevents invalid operations

✅ **Discoverability**
- Client can navigate entire API from root
- Similar to browsing a website

✅ **Graceful Evolution**
- Add new links without breaking existing clients
- Clients ignore unknown links

✅ **Permission-Aware**
- Only show links user has permission for
- UI can hide unavailable actions

### Disadvantages

❌ **Complexity**
- More complex responses
- Harder to implement correctly

❌ **Larger Responses**
- Extra data in every response
- More bandwidth usage

❌ **Client Complexity**
- Clients need to parse links
- Not all clients support it well

❌ **Not Widely Adopted**
- Most APIs don't use HATEOAS fully
- Limited tooling support

❌ **Caching Issues**
- Links might change
- Cache invalidation more complex

❌ **Overhead**
- Building links on every request
- Performance impact

---

## Levels of REST Maturity (Richardson Maturity Model)

HATEOAS is Level 3 (highest).

```
Level 0: The Swamp of POX
└─ Single endpoint, single method (POST)
   Example: XML-RPC, SOAP

Level 1: Resources
└─ Multiple URIs, but one method
   GET /users
   GET /orders
   POST /do-everything

Level 2: HTTP Verbs
└─ Proper use of HTTP methods
   GET /users
   POST /users
   PUT /users/42
   DELETE /users/42

Level 3: Hypermedia Controls (HATEOAS)
└─ Responses include links to related resources
   {
     "id": 42,
     "_links": {
       "self": "/users/42",
       "orders": "/users/42/orders"
     }
   }
```

**Most APIs are at Level 2.**

Level 3 (HATEOAS) is ideal but rarely implemented fully.

---

## When to Use HATEOAS

### Good Use Cases

✅ **Public APIs**
- Many unknown clients
- Clients discover API dynamically
- Example: GitHub, PayPal APIs

✅ **Complex Workflows**
- Multi-step processes (checkout, onboarding)
- State-dependent actions
- Example: Order processing, approval workflows

✅ **Long-Lived APIs**
- API will evolve over time
- Want to change URLs without breaking clients
- Need graceful evolution

✅ **Permission-Heavy Systems**
- Different users have different permissions
- Actions depend on user role
- Example: Admin panels, CMS systems

### When to Skip HATEOAS

❌ **Simple APIs**
- Few endpoints
- Stable structure
- Overhead not worth it

❌ **Internal APIs**
- You control all clients
- Hardcoded URLs are fine
- Don't need discovery

❌ **High-Performance Needs**
- Extra data is significant overhead
- Every byte counts
- Example: Mobile apps with limited bandwidth

❌ **Limited Resources**
- Team too small
- Not worth the complexity
- Better to focus on other features

---

## Practical Compromise

### Partial HATEOAS

Include links only where useful.

```javascript
// ✅ Good: Links for state transitions
GET /orders/123

{
  "id": 123,
  "status": "pending",
  "total": 99.99,
  "_links": {
    "self": "/orders/123",
    "confirm": { "href": "/orders/123/confirm", "method": "POST" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" }
  }
}

// ✅ Good: Pagination links
GET /users

{
  "users": [...],
  "_links": {
    "self": "/users?page=2",
    "next": "/users?page=3",
    "prev": "/users?page=1"
  }
}

// ✅ Good: Related resource links
GET /users/42

{
  "id": 42,
  "name": "John",
  "_links": {
    "self": "/users/42",
    "orders": "/users/42/orders",
    "avatar": "/users/42/avatar"
  }
}
```

### Progressive Enhancement

Start simple, add HATEOAS where needed.

```javascript
// V1: Simple response
{
  "id": 42,
  "name": "John"
}

// V2: Add critical links
{
  "id": 42,
  "name": "John",
  "_links": {
    "self": "/users/42"
  }
}

// V3: Add more links as needed
{
  "id": 42,
  "name": "John",
  "_links": {
    "self": "/users/42",
    "orders": "/users/42/orders",
    "edit": { "href": "/users/42", "method": "PUT" }
  }
}
```

---

## Common Mistakes

### Mistake 1: Inconsistent Link Format

```javascript
// ❌ Bad: Inconsistent formats
{
  "links": ["/users/42"],  // Array
  "nextPage": "/users?page=2",  // Direct property
  "_links": { "orders": "/users/42/orders" }  // Object
}

// ✅ Good: Consistent format
{
  "_links": {
    "self": { "href": "/users/42" },
    "next": { "href": "/users?page=2" },
    "orders": { "href": "/users/42/orders" }
  }
}
```

### Mistake 2: Missing Self Link

```javascript
// ❌ Bad: No self link
{
  "id": 42,
  "_links": {
    "orders": "/users/42/orders"
  }
}

// ✅ Good: Always include self
{
  "id": 42,
  "_links": {
    "self": "/users/42",
    "orders": "/users/42/orders"
  }
}
```

### Mistake 3: Static Links

```javascript
// ❌ Bad: All links always present
{
  "status": "cancelled",
  "_links": {
    "cancel": "/orders/123/cancel",  // Can't cancel cancelled order!
    "confirm": "/orders/123/confirm"
  }
}

// ✅ Good: Links based on state
{
  "status": "cancelled",
  "_links": {
    "self": "/orders/123"
    // No action links - order is cancelled
  }
}
```

### Mistake 4: Not Including HTTP Method

```javascript
// ❌ Bad: Client must guess
{
  "_links": {
    "update": "/users/42"  // Is this PUT, POST, or PATCH?
  }
}

// ✅ Good: Explicit method
{
  "_links": {
    "update": {
      "href": "/users/42",
      "method": "PUT"
    }
  }
}
```

---

## Testing HATEOAS APIs

```javascript
describe('User HATEOAS', () => {
  it('should include self link', async () => {
    const response = await request(app)
      .get('/users/42');
    
    expect(response.body._links).toHaveProperty('self');
    expect(response.body._links.self.href).toBe('/users/42');
  });
  
  it('should include orders link', async () => {
    const response = await request(app)
      .get('/users/42');
    
    expect(response.body._links).toHaveProperty('orders');
    expect(response.body._links.orders.href).toBe('/users/42/orders');
  });
  
  it('should include deactivate link for active users', async () => {
    const response = await request(app)
      .get('/users/42');  // Active user
    
    expect(response.body._links).toHaveProperty('deactivate');
    expect(response.body._links.deactivate.method).toBe('POST');
  });
  
  it('should not include deactivate link for inactive users', async () => {
    const response = await request(app)
      .get('/users/99');  // Inactive user
    
    expect(response.body._links).not.toHaveProperty('deactivate');
    expect(response.body._links).toHaveProperty('activate');
  });
  
  it('should include edit link only for admins', async () => {
    const adminResponse = await request(app)
      .get('/users/42')
      .set('Authorization', 'Bearer admin-token');
    
    expect(adminResponse.body._links).toHaveProperty('edit');
    
    const userResponse = await request(app)
      .get('/users/42')
      .set('Authorization', 'Bearer user-token');
    
    expect(userResponse.body._links).not.toHaveProperty('edit');
  });
});
```

---

## Summary

### Key Concepts

- **HATEOAS** = Server tells client what actions are available
- **Links** = Navigable relationships between resources
- **State-Driven** = Available actions depend on resource state
- **Self-Discovery** = Client explores API through responses
- **Loose Coupling** = Client doesn't hardcode URLs

### When to Use

✅ **Use HATEOAS when:**
- Building public APIs
- Complex multi-step workflows
- Permission-dependent actions
- Long-lived APIs that will evolve

❌ **Skip HATEOAS when:**
- Simple, stable APIs
- Internal APIs with known clients
- Performance is critical
- Team resources are limited

### Implementation Checklist

✅ Always include `self` link
✅ Use consistent link format (`_links` object)
✅ Include HTTP method for actions
✅ Add links based on resource state
✅ Add links based on user permissions
✅ Include pagination links for collections
✅ Test that links are correct and available

### Popular Standards

- **HAL** (Hypertext Application Language) - Most popular
- **JSON:API** - Comprehensive standard
- **Collection+JSON** - For collections

### Maturity Model

Most APIs are **Level 2** (HTTP verbs).
HATEOAS is **Level 3** (fully RESTful).
Level 3 is ideal but rarely necessary in practice.

---

## Next Steps

Now that you understand HATEOAS, explore:
- Implementing HAL format in your API
- API documentation showing link relations
- Client libraries that support HATEOAS
- Combining HATEOAS with GraphQL for discoverability
- State machines for workflow management
