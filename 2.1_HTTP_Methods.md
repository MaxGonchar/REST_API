# HTTP Methods in REST API

## Introduction

HTTP methods (also called HTTP verbs) define the **action** you want to perform on a resource. They tell the server what to do with the resource identified by the URI.

**Key concept:** In REST, the URI identifies **what** (the resource), and the HTTP method specifies **how** (the action).

```
HTTP Method + URI = Complete instruction

GET     /users/42    →  "Retrieve user 42"
POST    /users       →  "Create a new user"
PUT     /users/42    →  "Update user 42"
DELETE  /users/42    →  "Delete user 42"
```

---

## The Primary HTTP Methods

### 1. GET - Retrieve Resources

**Purpose:** Retrieve data from the server. GET requests should only fetch data, never modify it.

**Characteristics:**
- ✅ Safe - Doesn't modify server state
- ✅ Idempotent - Multiple identical requests have the same effect
- ✅ Cacheable - Responses can be cached

#### Basic Usage

```http
GET /users
Host: api.example.com
Accept: application/json
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

[
  { "id": 1, "name": "John Doe" },
  { "id": 2, "name": "Jane Smith" }
]
```

#### Retrieve Single Resource

```http
GET /users/42
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-01-15T10:00:00Z"
}
```

#### Query Parameters for Filtering

```http
GET /products?category=electronics&minPrice=100&maxPrice=500
GET /users?status=active&role=admin
GET /orders?startDate=2025-01-01&endDate=2025-12-31
```

#### Pagination

```http
GET /users?page=2&limit=20
```

**Response:**
```json
{
  "data": [...],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

#### Best Practices

```
✅ Good:
GET /users              (retrieve collection)
GET /users/42           (retrieve specific item)
GET /users/42/orders    (retrieve nested resource)

❌ Bad:
GET /getUsers           (verb in URI)
GET /users?action=delete&id=42  (GET shouldn't delete)
```

**Real-world analogy:** Reading a book from a library shelf. You're just looking at it, not changing it.

---

### 2. POST - Create Resources

**Purpose:** Create a new resource or submit data that causes a change on the server.

**Characteristics:**
- ❌ Not safe - Modifies server state
- ❌ Not idempotent - Multiple requests create multiple resources
- ⚠️ Rarely cacheable

#### Create New Resource

```http
POST /users
Content-Type: application/json

{
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "password": "securePass123"
}
```

**Response:**
```http
HTTP/1.1 201 Created
Location: /users/43
Content-Type: application/json

{
  "id": 43,
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "createdAt": "2026-01-12T14:30:00Z"
}
```

**Key elements:**
- Status code: `201 Created` (not 200)
- `Location` header: URI of the newly created resource
- Response body: The created resource with server-generated fields (id, timestamps)

#### Submit Data for Processing

```http
POST /orders/42/process
Content-Type: application/json

{
  "paymentMethod": "credit_card",
  "shippingAddress": {...}
}
```

#### Why POST is NOT Idempotent

```http
// First request
POST /users
{ "name": "John" }
→ Creates user with id: 1

// Second identical request
POST /users
{ "name": "John" }
→ Creates ANOTHER user with id: 2

// Result: Two different resources created
```

#### Best Practices

```
✅ Good:
POST /users             (create user in users collection)
POST /orders            (create new order)
POST /users/42/activate (action on existing resource)

❌ Bad:
POST /createUser        (verb in URI)
POST /user              (use plural)
```

**Real-world analogy:** Filling out a form and submitting it. Each submission creates a new entry.

---

### 3. PUT - Update/Replace Resources

**Purpose:** Update an existing resource by completely replacing it, or create a resource at a specific URI if it doesn't exist.

**Characteristics:**
- ❌ Not safe - Modifies server state
- ✅ Idempotent - Multiple identical requests have the same result
- ❌ Not cacheable

#### Complete Replacement

```http
PUT /users/42
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john.new@example.com",
  "phone": "+1234567890",
  "address": "123 Main St"
}
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "John Doe",
  "email": "john.new@example.com",
  "phone": "+1234567890",
  "address": "123 Main St",
  "updatedAt": "2026-01-12T15:00:00Z"
}
```

#### Why PUT is Idempotent

```http
// First request
PUT /users/42
{ "name": "John", "email": "john@example.com" }
→ User 42: name="John", email="john@example.com"

// Second identical request
PUT /users/42
{ "name": "John", "email": "john@example.com" }
→ User 42: name="John", email="john@example.com" (same result)

// Third identical request
PUT /users/42
{ "name": "John", "email": "john@example.com" }
→ User 42: name="John", email="john@example.com" (still same result)

// Result: Resource state is the same after 1, 2, or 100 identical requests
```

#### PUT vs POST for Creation

**PUT can create if resource doesn't exist:**
```http
PUT /users/999
{
  "name": "New User",
  "email": "new@example.com"
}

// If user 999 doesn't exist:
HTTP/1.1 201 Created

// If user 999 exists:
HTTP/1.1 200 OK
```

**Note:** With PUT, the client specifies the resource URI. With POST, the server generates the URI.

#### Complete Replacement Warning

```http
// Original resource
{
  "id": 42,
  "name": "John",
  "email": "john@example.com",
  "phone": "+1234567890"
}

// PUT request (missing phone)
PUT /users/42
{
  "name": "John",
  "email": "john.new@example.com"
}

// Result: phone is removed!
{
  "id": 42,
  "name": "John",
  "email": "john.new@example.com",
  "phone": null  // or removed entirely
}
```

**Best practice:** Always include all fields when using PUT, even unchanged ones.

#### Best Practices

```
✅ Good:
PUT /users/42           (replace user 42)
PUT /users/42/profile   (replace user 42's profile)

❌ Bad:
PUT /users              (PUT needs specific resource)
PUT /updateUser/42      (verb in URI)
```

**Real-world analogy:** Replacing a page in a document with a completely new page. The page number stays the same, but the content is entirely replaced.

---

### 4. PATCH - Partial Update

**Purpose:** Partially update a resource. Only the fields included in the request are updated.

**Characteristics:**
- ❌ Not safe - Modifies server state
- ✅ Usually idempotent (but can be designed as non-idempotent)
- ❌ Not cacheable

#### Partial Update

```http
PATCH /users/42
Content-Type: application/json

{
  "email": "john.new@example.com"
}
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "John Doe",           // unchanged
  "email": "john.new@example.com", // updated
  "phone": "+1234567890",       // unchanged
  "updatedAt": "2026-01-12T15:30:00Z"
}
```

#### PATCH vs PUT

```http
// Original resource
{
  "id": 42,
  "name": "John",
  "email": "john@example.com",
  "phone": "+1234567890",
  "address": "123 Main St"
}

// PATCH (partial update)
PATCH /users/42
{
  "email": "john.new@example.com"
}
// Result: Only email changes, everything else stays

// PUT (complete replacement)
PUT /users/42
{
  "email": "john.new@example.com"
}
// Result: Only email remains, other fields are removed!
```

#### JSON Patch Format (RFC 6902)

More sophisticated PATCH operations:

```http
PATCH /users/42
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/email", "value": "new@example.com" },
  { "op": "add", "path": "/phone", "value": "+1234567890" },
  { "op": "remove", "path": "/tempField" }
]
```

**Operations:**
- `add` - Add a field
- `remove` - Remove a field
- `replace` - Replace a field value
- `move` - Move a value from one location to another
- `copy` - Copy a value
- `test` - Test that a value is as expected

#### When PATCH is Idempotent

```http
// Idempotent PATCH (simple field update)
PATCH /users/42
{ "status": "active" }

// Request 1: status → active
// Request 2: status → active (already active)
// Request 3: status → active (still active)
// Result: Same state after multiple requests ✅
```

#### When PATCH is NOT Idempotent

```http
// Non-idempotent PATCH (increment operation)
PATCH /posts/42
{ "views": { "$increment": 1 } }

// Request 1: views = 100 → 101
// Request 2: views = 101 → 102
// Request 3: views = 102 → 103
// Result: Different state after each request ❌
```

#### Best Practices

```
✅ Good:
PATCH /users/42         (partial update)
PATCH /orders/123       (update specific fields)

❌ Bad:
PATCH /users            (PATCH needs specific resource)
PATCH /users/42/update  (verb in URI)
```

**Real-world analogy:** Using correction tape on a document. You only fix the mistake, leaving everything else intact.

---

### 5. DELETE - Remove Resources

**Purpose:** Delete a resource.

**Characteristics:**
- ❌ Not safe - Modifies server state
- ✅ Idempotent - Multiple deletes have the same effect
- ❌ Not cacheable

#### Delete Resource

```http
DELETE /users/42
```

**Response (No Content):**
```http
HTTP/1.1 204 No Content
```

**Response (With Confirmation):**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "User 42 deleted successfully",
  "deletedAt": "2026-01-12T16:00:00Z"
}
```

#### Why DELETE is Idempotent

```http
// First request
DELETE /users/42
→ User 42 is deleted
→ Response: 204 No Content

// Second identical request
DELETE /users/42
→ User 42 doesn't exist (already deleted)
→ Response: 404 Not Found (or 204 No Content)

// Third identical request
DELETE /users/42
→ User 42 still doesn't exist
→ Response: 404 Not Found (or 204 No Content)

// Result: After the first delete, the state is consistent
// (user doesn't exist) regardless of additional requests ✅
```

#### Soft Delete vs Hard Delete

**Hard Delete (permanent removal):**
```http
DELETE /users/42
// User record is permanently removed from database
```

**Soft Delete (mark as deleted):**
```http
DELETE /users/42
// User record marked as deleted but remains in database
// { "id": 42, "name": "John", "deletedAt": "2026-01-12T16:00:00Z" }
```

**PATCH for soft delete:**
```http
PATCH /users/42
{ "status": "deleted", "deletedAt": "2026-01-12T16:00:00Z" }
```

#### Delete Collection (Use Carefully!)

```http
DELETE /users/42/sessions
// Delete all sessions for user 42
```

**Note:** Most APIs don't allow `DELETE /users` (delete all users) for safety reasons.

#### Best Practices

```
✅ Good:
DELETE /users/42        (delete specific user)
DELETE /users/42/avatar (delete nested resource)

❌ Bad:
DELETE /deleteUser/42   (verb in URI)
DELETE /users           (too dangerous)
GET /users/42?action=delete  (use DELETE method)
```

**Real-world analogy:** Removing a book from a library. Once removed, trying to remove it again doesn't change anything (it's still gone).

---

### 6. HEAD - Retrieve Headers Only

**Purpose:** Same as GET, but returns only headers without the response body. Used to check if a resource exists or get metadata.

**Characteristics:**
- ✅ Safe - Doesn't modify server state
- ✅ Idempotent - Multiple identical requests have the same effect
- ✅ Cacheable

#### Check if Resource Exists

```http
HEAD /users/42
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 256
Last-Modified: Thu, 15 Jan 2026 10:00:00 GMT
ETag: "abc123xyz"

(no body)
```

#### Use Cases

**1. Check resource existence:**
```http
HEAD /files/large-video.mp4
// Get status 200 (exists) or 404 (not found) without downloading
```

**2. Get resource metadata:**
```http
HEAD /documents/report.pdf

Response:
Content-Length: 5242880  (5MB)
Last-Modified: ...
Content-Type: application/pdf
```

**3. Check if resource has changed:**
```http
HEAD /api/data.json
ETag: "abc123"

// Client caches the ETag, checks later:
HEAD /api/data.json
ETag: "abc123"  (unchanged)
or
ETag: "xyz789"  (changed)
```

**Real-world analogy:** Looking at a book's cover and checking its properties (title, author, publication date) without reading the content.

---

### 7. OPTIONS - Discover Allowed Methods

**Purpose:** Retrieve information about communication options available for a resource.

**Characteristics:**
- ✅ Safe - Doesn't modify server state
- ✅ Idempotent - Multiple identical requests have the same effect
- ✅ Cacheable

#### Discover Available Methods

```http
OPTIONS /users/42
```

**Response:**
```http
HTTP/1.1 200 OK
Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, PUT, PATCH, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

#### CORS Preflight Request

Before making cross-origin requests, browsers send an OPTIONS request:

```http
OPTIONS /api/users
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

**Response:**
```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
```

**Real-world analogy:** Asking what you're allowed to do before doing it. Like checking museum rules before entering.

---

### 8. Less Common Methods

#### CONNECT
Creates a tunnel to the server. Primarily used for HTTPS through HTTP proxies.

```http
CONNECT example.com:443 HTTP/1.1
```

#### TRACE
Performs a message loop-back test. Returns the request as received by the server (for debugging).

```http
TRACE /api/users
```

**Note:** Often disabled for security reasons.

---

## Understanding Idempotency

### What is Idempotency?

**Definition:** An operation is idempotent if performing it multiple times has the same effect as performing it once.

**Mathematical analogy:**
```
Idempotent:     abs(abs(abs(-5))) = abs(-5) = 5
Non-idempotent: increment(increment(increment(5))) = 8 ≠ 6
```

### Why Idempotency Matters

#### Network Reliability

```
Client sends: DELETE /users/42
Network timeout... Did it work?

If idempotent:
→ Safe to retry: DELETE /users/42 again
→ User still deleted, no duplicate effect ✅

If not idempotent:
→ Risky to retry
→ Might cause unwanted side effects ❌
```

#### Automatic Retries

```javascript
// HTTP client with retry logic
async function request(method, url, data) {
  let attempts = 0;
  const maxAttempts = 3;
  
  while (attempts < maxAttempts) {
    try {
      return await fetch(url, { method, body: data });
    } catch (error) {
      attempts++;
      
      // Safe to retry idempotent methods
      if (isIdempotent(method) && attempts < maxAttempts) {
        await sleep(1000 * attempts); // exponential backoff
        continue;
      }
      throw error;
    }
  }
}

function isIdempotent(method) {
  return ['GET', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'].includes(method);
}
```

### Idempotency Table

| Method  | Idempotent | Safe | Explanation |
|---------|-----------|------|-------------|
| GET     | ✅ Yes     | ✅ Yes | Same data retrieved every time |
| POST    | ❌ No      | ❌ No  | Creates new resource each time |
| PUT     | ✅ Yes     | ❌ No  | Same final state after multiple requests |
| PATCH   | ⚠️ Usually | ❌ No  | Depends on implementation |
| DELETE  | ✅ Yes     | ❌ No  | Resource stays deleted |
| HEAD    | ✅ Yes     | ✅ Yes | Same headers every time |
| OPTIONS | ✅ Yes     | ✅ Yes | Same options every time |

### Practical Examples

#### Example 1: GET (Idempotent & Safe)

```javascript
// Call 1
GET /users/42
→ { "id": 42, "name": "John", "balance": 100 }

// Call 2 (identical)
GET /users/42
→ { "id": 42, "name": "John", "balance": 100 }

// Result: Same response, no side effects ✅
```

#### Example 2: POST (Not Idempotent)

```javascript
// Call 1
POST /orders
{ "productId": 123, "quantity": 1 }
→ Order #1 created, inventory: 99

// Call 2 (identical)
POST /orders
{ "productId": 123, "quantity": 1 }
→ Order #2 created, inventory: 98

// Result: Two different orders, different state ❌
```

#### Example 3: PUT (Idempotent, Not Safe)

```javascript
// Call 1
PUT /users/42
{ "name": "John", "balance": 150 }
→ User updated, balance: 150

// Call 2 (identical)
PUT /users/42
{ "name": "John", "balance": 150 }
→ User updated, balance: 150 (same)

// Call 3 (identical)
PUT /users/42
{ "name": "John", "balance": 150 }
→ User updated, balance: 150 (still same)

// Result: Final state is identical ✅
```

#### Example 4: DELETE (Idempotent, Not Safe)

```javascript
// Call 1
DELETE /users/42
→ User deleted, 204 No Content

// Call 2 (identical)
DELETE /users/42
→ User already deleted, 404 Not Found (or 204)

// Call 3 (identical)
DELETE /users/42
→ User still deleted, 404 Not Found (or 204)

// Result: Resource remains deleted ✅
```

#### Example 5: PATCH (Depends on Implementation)

**Idempotent PATCH:**
```javascript
PATCH /users/42
{ "status": "active" }
→ Status: active

PATCH /users/42
{ "status": "active" }
→ Status: active (still)

// Idempotent: Same final state ✅
```

**Non-Idempotent PATCH:**
```javascript
PATCH /users/42/balance
{ "operation": "add", "amount": 10 }
→ Balance: 100 + 10 = 110

PATCH /users/42/balance
{ "operation": "add", "amount": 10 }
→ Balance: 110 + 10 = 120

// Not idempotent: Different final state ❌
```

---

## Understanding Safety

### What is a Safe Method?

**Definition:** A safe method doesn't modify the resource state on the server. It's read-only.

**Safe methods:**
- GET - Read data
- HEAD - Read metadata
- OPTIONS - Read available options

**Unsafe methods:**
- POST - Creates/modifies
- PUT - Modifies
- PATCH - Modifies
- DELETE - Modifies

### Safe vs Idempotent

```
All safe methods are idempotent
Not all idempotent methods are safe

Safe ⊂ Idempotent

Example:
GET    - Safe ✅ and Idempotent ✅
DELETE - Unsafe ❌ but Idempotent ✅
```

### Why Safety Matters

```javascript
// Safe methods can be:
// - Cached aggressively
// - Pre-fetched by browsers
// - Retried automatically
// - Called by web crawlers

// Unsafe methods should:
// - Require explicit user action
// - Not be cached (usually)
// - Ask for confirmation
// - Be protected by CSRF tokens
```

---

## Method Selection Guide

### Decision Tree

```
Want to retrieve data?
└─ GET (or HEAD for metadata only)

Want to create something?
├─ Client specifies ID? → PUT
└─ Server generates ID? → POST

Want to update something?
├─ Replace entirely? → PUT
└─ Update specific fields? → PATCH

Want to delete something?
└─ DELETE

Want to know what's allowed?
└─ OPTIONS
```

### Common Scenarios

#### Scenario 1: User Registration

```http
POST /users
{
  "username": "alice",
  "email": "alice@example.com",
  "password": "securePass123"
}

Response: 201 Created
Location: /users/123
```

**Why POST?** Server generates the user ID.

#### Scenario 2: Update User Profile

```http
PATCH /users/123
{
  "bio": "Software developer",
  "website": "https://alice.dev"
}

Response: 200 OK
```

**Why PATCH?** Only updating specific fields.

#### Scenario 3: Replace Configuration

```http
PUT /settings/theme
{
  "primaryColor": "#3498db",
  "secondaryColor": "#2ecc71",
  "fontSize": 16,
  "darkMode": true
}

Response: 200 OK
```

**Why PUT?** Replacing entire configuration.

#### Scenario 4: Toggle Feature

```http
PATCH /users/123/features
{
  "darkMode": true
}

Response: 200 OK
```

**Or use a specific endpoint:**
```http
POST /users/123/features/darkMode/enable

Response: 200 OK
```

---

## Best Practices

### 1. Use Appropriate Methods

```
✅ Good:
GET    /users/42         (retrieve)
POST   /users            (create)
PUT    /users/42         (replace)
PATCH  /users/42         (partial update)
DELETE /users/42         (delete)

❌ Bad:
GET    /users/42/delete  (should be DELETE)
POST   /users/42/update  (should be PUT or PATCH)
GET    /createUser       (should be POST)
```

### 2. Return Appropriate Status Codes

```javascript
GET     → 200 OK (found) or 404 Not Found
POST    → 201 Created or 200 OK
PUT     → 200 OK or 204 No Content
PATCH   → 200 OK or 204 No Content
DELETE  → 204 No Content or 200 OK
```

### 3. Make Methods Idempotent When Possible

```javascript
// ❌ Non-idempotent (avoid)
PATCH /users/42
{ "loginCount": "+1" }

// ✅ Idempotent (better)
POST /users/42/login
// Server increments login count
```

### 4. Use POST for Non-Idempotent Operations

```http
POST /orders/42/refund      (process refund)
POST /emails/send           (send email)
POST /reports/generate      (generate report)
POST /users/42/notify       (send notification)
```

### 5. Include Location Header for Created Resources

```http
POST /users

Response:
HTTP/1.1 201 Created
Location: /users/123
Content-Type: application/json

{ "id": 123, ... }
```

---

## Common Pitfalls

### ❌ Using GET for State-Changing Operations

```javascript
// WRONG
GET /users/42/delete
GET /orders/42/cancel
GET /logout

// RIGHT
DELETE /users/42
POST /orders/42/cancel
POST /logout
```

**Problem:** GET requests can be cached, pre-fetched, and triggered by search engines.

### ❌ Using POST for Everything

```javascript
// WRONG
POST /users/get
POST /users/update
POST /users/delete

// RIGHT
GET /users
PUT /users/42
DELETE /users/42
```

### ❌ Not Including All Fields in PUT

```javascript
// WRONG
PUT /users/42
{ "email": "new@example.com" }
// Result: Other fields might be lost!

// RIGHT
PUT /users/42
{
  "name": "John",
  "email": "new@example.com",
  "phone": "+1234567890"
}
// Or use PATCH for partial updates
```

### ❌ Making PATCH Non-Idempotent Unnecessarily

```javascript
// AVOID (non-idempotent)
PATCH /posts/42
{ "views": { "$increment": 1 } }

// BETTER (idempotent)
POST /posts/42/view
// Server handles view count internally
```

---

## Summary

### Quick Reference

| Method  | Purpose | Idempotent | Safe | Common Use |
|---------|---------|-----------|------|------------|
| GET     | Retrieve | ✅ | ✅ | Read data |
| POST    | Create/Action | ❌ | ❌ | Create resources |
| PUT     | Replace | ✅ | ❌ | Full update |
| PATCH   | Partial Update | ⚠️ | ❌ | Partial update |
| DELETE  | Remove | ✅ | ❌ | Delete resources |
| HEAD    | Metadata | ✅ | ✅ | Check existence |
| OPTIONS | Capabilities | ✅ | ✅ | CORS, discovery |

### Key Concepts

**Idempotency:** Same result after 1 or N identical requests
- Allows safe retries
- Important for reliability
- GET, PUT, DELETE are idempotent

**Safety:** Doesn't modify server state
- Read-only operations
- Can be cached and pre-fetched
- GET, HEAD, OPTIONS are safe

**Remember:**
- URI identifies WHAT (the resource)
- Method specifies HOW (the action)
- Use the right method for the right job

---

## Next Steps

Now that you understand HTTP methods, explore:
- HTTP status codes for different scenarios
- Request/response headers
- Error handling strategies
- Implementing idempotent operations in code
