# API Authentication Methods

## Introduction

Authentication is the process of verifying the identity of a user or system. In REST APIs, authentication ensures that requests come from legitimate users and allows the server to identify who is making each request.

**Key principle:** Always use HTTPS. All authentication mechanisms are vulnerable without encryption.

---

## Why Authentication Matters

```http
# Without authentication
GET /users/42/bank-account
Response: { "balance": 50000 }  ← Anyone can access this!

# With authentication
GET /users/42/bank-account
Authorization: Bearer token-abc-123
Response: { "balance": 50000 }  ← Only if token belongs to user 42

# Wrong user
GET /users/42/bank-account
Authorization: Bearer token-of-user-99
Response: 403 Forbidden  ← You can't access someone else's account
```

---

## Authentication vs Authorization

**Authentication (AuthN):** Who are you?
- Verifying identity
- "Prove you are John Doe"

**Authorization (AuthZ):** What can you do?
- Verifying permissions
- "John Doe can read, but not delete"

```
Authentication → Authorization → Access
     ↓               ↓              ↓
  Who are you?  What can you do?  Allowed/Denied
```

---

## 1. API Keys

### How It Works

Simple string token that identifies the application/user.

```http
GET /users
X-API-Key: sk_live_abc123def456

# Alternative headers
API-Key: abc123def456
Authorization: Api-Key abc123def456
```

### Characteristics

- **Simplest** authentication method
- **Long-lived** - Often never expire
- Identifies **application**, not individual users
- Good for **server-to-server** communication

### Implementation

```javascript
// Server-side validation
const API_KEYS = {
  'sk_live_abc123': { appName: 'Mobile App', userId: null },
  'sk_live_def456': { appName: 'Web App', userId: null }
};

app.use('/api', (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey) {
    return res.status(401).json({
      error: {
        code: 'MISSING_API_KEY',
        message: 'API key is required'
      }
    });
  }
  
  const keyInfo = API_KEYS[apiKey];
  
  if (!keyInfo) {
    return res.status(401).json({
      error: {
        code: 'INVALID_API_KEY',
        message: 'Invalid API key'
      }
    });
  }
  
  req.apiKey = apiKey;
  req.appName = keyInfo.appName;
  next();
});
```

### Pros

✅ Simple to implement
✅ Easy to understand
✅ Good for service-to-service authentication
✅ No user login required

### Cons

❌ No user identity (just application identity)
❌ Hard to revoke (if hardcoded in apps)
❌ If leaked, anyone can use it
❌ Usually never expire
❌ All-or-nothing access (no fine-grained permissions)

### Security Best Practices

```javascript
// ✅ Good: Store hashed API keys
const crypto = require('crypto');

function hashApiKey(apiKey) {
  return crypto.createHash('sha256').update(apiKey).digest('hex');
}

// When creating key
const apiKey = generateSecureApiKey();
const hashedKey = hashApiKey(apiKey);
db.apiKeys.create({ hashedKey, appName: 'Mobile App' });
console.log('Your API key (save it now!):', apiKey);

// When validating
const providedKey = req.headers['x-api-key'];
const hashedProvided = hashApiKey(providedKey);
const keyRecord = await db.apiKeys.findOne({ hashedKey: hashedProvided });

if (!keyRecord) {
  return res.status(401).json({ error: 'Invalid API key' });
}
```

```javascript
// ✅ Good: Key prefix for identification
// sk_live_... = secret key, live environment
// sk_test_... = secret key, test environment
// pk_live_... = public key, live environment

function generateApiKey(type, environment) {
  const random = crypto.randomBytes(32).toString('hex');
  return `${type}_${environment}_${random}`;
}

const liveKey = generateApiKey('sk', 'live');
// sk_live_abc123def456...
```

---

## 2. Basic Authentication

### How It Works

Username and password sent with each request, encoded in Base64.

```http
GET /users
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=

# Where "dXNlcm5hbWU6cGFzc3dvcmQ=" is Base64("username:password")
```

### Encoding/Decoding

```javascript
// Encoding
const credentials = 'username:password';
const encoded = Buffer.from(credentials).toString('base64');
console.log(encoded); // dXNlcm5hbWU6cGFzc3dvcmQ=

// Decoding
const decoded = Buffer.from('dXNlcm5hbWU6cGFzc3dvcmQ=', 'base64').toString();
console.log(decoded); // username:password
```

### Implementation

```javascript
app.use('/api', async (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Basic ')) {
    return res.status(401).json({
      error: {
        code: 'MISSING_CREDENTIALS',
        message: 'Basic authentication required'
      }
    });
  }
  
  // Extract and decode credentials
  const base64Credentials = authHeader.split(' ')[1];
  const credentials = Buffer.from(base64Credentials, 'base64').toString();
  const [username, password] = credentials.split(':');
  
  // Validate credentials
  const user = await db.users.findByUsername(username);
  
  if (!user || !await bcrypt.compare(password, user.passwordHash)) {
    return res.status(401).json({
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid username or password'
      }
    });
  }
  
  req.user = user;
  next();
});
```

### Pros

✅ Simple to implement
✅ Built into HTTP standard
✅ Supported by all HTTP clients
✅ No need for login endpoint

### Cons

❌ **Credentials sent with every request** (not efficient)
❌ **No way to logout** (browser caches credentials)
❌ **Base64 is not encryption** (just encoding)
❌ **Vulnerable to credential stuffing**
❌ **No token expiration**
❌ Not suitable for web browsers (poor UX)

### When to Use

- Internal tools
- Simple prototypes
- Service-to-service with mutual TLS
- **NOT recommended for production APIs**

---

## 3. Bearer Tokens (Access Tokens)

### How It Works

Client exchanges credentials for a token, then includes token in subsequent requests.

```http
# Step 1: Login to get token
POST /auth/login
{
  "email": "user@example.com",
  "password": "secret123"
}

Response:
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "tokenType": "Bearer",
  "expiresIn": 3600
}

# Step 2: Use token for requests
GET /users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Implementation

```javascript
// Login endpoint
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await db.users.findByEmail(email);
  
  if (!user || !await bcrypt.compare(password, user.passwordHash)) {
    return res.status(401).json({
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password'
      }
    });
  }
  
  // Generate token (opaque token stored in database)
  const token = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 3600 * 1000); // 1 hour
  
  await db.tokens.create({
    token: hashToken(token),
    userId: user.id,
    expiresAt,
    createdAt: new Date()
  });
  
  res.json({
    accessToken: token,
    tokenType: 'Bearer',
    expiresIn: 3600,
    userId: user.id
  });
});

// Authentication middleware
app.use('/api', async (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: {
        code: 'MISSING_TOKEN',
        message: 'Bearer token required'
      }
    });
  }
  
  const token = authHeader.split(' ')[1];
  const hashedToken = hashToken(token);
  
  // Lookup token in database
  const tokenRecord = await db.tokens.findOne({
    token: hashedToken,
    expiresAt: { $gt: new Date() }
  });
  
  if (!tokenRecord) {
    return res.status(401).json({
      error: {
        code: 'INVALID_TOKEN',
        message: 'Token is invalid or expired'
      }
    });
  }
  
  // Get user
  const user = await db.users.findById(tokenRecord.userId);
  req.user = user;
  req.tokenId = tokenRecord.id;
  
  next();
});

function hashToken(token) {
  return crypto.createHash('sha256').update(token).digest('hex');
}
```

### Pros

✅ Credentials not sent with every request
✅ Tokens can expire
✅ Can be revoked
✅ Can have different scopes/permissions

### Cons

❌ Requires token storage (database or cache)
❌ Token can be stolen if intercepted
❌ Need token refresh mechanism

---

## 4. JWT (JSON Web Tokens)

### How It Works

Self-contained tokens that carry user information, signed by the server.

**JWT Structure:**
```
header.payload.signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQyLCJpYXQiOjE2MDAwMDAwMDB9.signature
│                                      │                                    │
│         Header (Base64)              │       Payload (Base64)            │  Signature
```

**Decoded:**
```json
// Header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload
{
  "userId": 42,
  "email": "user@example.com",
  "role": "admin",
  "iat": 1600000000,  // Issued at
  "exp": 1600003600   // Expires at (1 hour later)
}

// Signature = HMAC-SHA256(
//   base64(header) + "." + base64(payload),
//   secret_key
// )
```

### Implementation

```javascript
const jwt = require('jsonwebtoken');

// Login endpoint
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await db.users.findByEmail(email);
  
  if (!user || !await bcrypt.compare(password, user.passwordHash)) {
    return res.status(401).json({
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password'
      }
    });
  }
  
  // Generate JWT
  const token = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      role: user.role
    },
    process.env.JWT_SECRET,
    {
      expiresIn: '1h',
      issuer: 'api.example.com',
      audience: 'api.example.com'
    }
  );
  
  res.json({
    accessToken: token,
    tokenType: 'Bearer',
    expiresIn: 3600
  });
});

// Authentication middleware
app.use('/api', (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: {
        code: 'MISSING_TOKEN',
        message: 'Bearer token required'
      }
    });
  }
  
  const token = authHeader.split(' ')[1];
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET, {
      issuer: 'api.example.com',
      audience: 'api.example.com'
    });
    
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      role: decoded.role
    };
    
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: {
          code: 'EXPIRED_TOKEN',
          message: 'Token has expired',
          expiredAt: error.expiredAt
        }
      });
    }
    
    return res.status(401).json({
      error: {
        code: 'INVALID_TOKEN',
        message: 'Token is invalid'
      }
    });
  }
});
```

### Pros

✅ **Stateless** - No database lookup needed
✅ **Self-contained** - Contains user info
✅ **Scalable** - No shared session storage
✅ **Cross-domain** - Can be used across services
✅ Standardized (RFC 7519)

### Cons

❌ **Cannot be revoked easily** (stateless = no server tracking)
❌ **Larger than opaque tokens** (contains data)
❌ **Sensitive data exposed** (Base64 is not encryption)
❌ **Cannot update claims** until token expires
❌ Token theft still an issue

### JWT Claims

**Registered Claims (Standard):**
```javascript
{
  iss: 'api.example.com',        // Issuer
  sub: '42',                      // Subject (user ID)
  aud: 'api.example.com',         // Audience
  exp: 1600003600,                // Expiration time (Unix timestamp)
  nbf: 1600000000,                // Not before
  iat: 1600000000,                // Issued at
  jti: 'unique-token-id'          // JWT ID (unique identifier)
}
```

**Custom Claims:**
```javascript
{
  userId: 42,
  email: 'user@example.com',
  role: 'admin',
  permissions: ['users.read', 'users.write'],
  plan: 'premium'
}
```

---

## 5. OAuth 2.0

### How It Works

Delegated authorization protocol allowing third-party apps to access resources without sharing passwords.

**OAuth 2.0 Roles:**
- **Resource Owner:** User who owns the data
- **Client:** Application requesting access
- **Authorization Server:** Issues tokens
- **Resource Server:** API that hosts the data

### OAuth 2.0 Flow (Authorization Code)

```
┌─────────┐                                ┌─────────────────┐
│  User   │                                │  Client App     │
│ (Owner) │                                │ (Your Website)  │
└────┬────┘                                └────────┬────────┘
     │                                              │
     │ 1. Click "Login with Google"                │
     │◄────────────────────────────────────────────┤
     │                                              │
     │ 2. Redirect to Authorization Server         │
     ├─────────────────────────────────────────────►
     │      https://auth.example.com/authorize?    │
     │      response_type=code&                    │
     │      client_id=abc123&                      │
     │      redirect_uri=https://app.com/callback& │
     │      scope=email+profile                    │
     │                                              │
     │ 3. User logs in and grants permission       │
     │ ┌───────────────────────────────┐          │
     │ │ Authorize "YourApp"?          │          │
     │ │ Access to: email, profile     │          │
     │ │ [Deny] [Allow]                │          │
     │ └───────────────────────────────┘          │
     │                                              │
     │ 4. Redirect back with auth code             │
     │──────────────────────────────────────────────►
     │      https://app.com/callback?code=xyz123  │
     │                                              │
     │                                              │ 5. Exchange code for token
     │                                              ├──────────────────►
     │                                              │  POST /token      │
     │                                              │  code=xyz123      │
     │                                              │  client_id=abc    │
     │                                              │  client_secret=   │
     │                                              │                   │
     │                                              │◄──────────────────┤
     │                                              │ { "access_token": "..." }
     │                                              │
     │ 6. Access protected resources               │
     │◄─────────────────────────────────────────────┤
     │  GET /api/profile                           │
     │  Authorization: Bearer access_token         │
```

### OAuth 2.0 Grant Types

#### 1. Authorization Code (Most Secure)

For server-side web applications.

```javascript
// Step 1: Redirect to authorization endpoint
app.get('/auth/google', (req, res) => {
  const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');
  authUrl.searchParams.append('client_id', process.env.GOOGLE_CLIENT_ID);
  authUrl.searchParams.append('redirect_uri', 'https://yourapp.com/auth/callback');
  authUrl.searchParams.append('response_type', 'code');
  authUrl.searchParams.append('scope', 'email profile');
  authUrl.searchParams.append('state', generateRandomState()); // CSRF protection
  
  res.redirect(authUrl.toString());
});

// Step 2: Handle callback with authorization code
app.get('/auth/callback', async (req, res) => {
  const { code, state } = req.query;
  
  // Verify state (CSRF protection)
  if (!verifyState(state)) {
    return res.status(400).json({ error: 'Invalid state' });
  }
  
  // Exchange code for access token
  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      code,
      client_id: process.env.GOOGLE_CLIENT_ID,
      client_secret: process.env.GOOGLE_CLIENT_SECRET,
      redirect_uri: 'https://yourapp.com/auth/callback',
      grant_type: 'authorization_code'
    })
  });
  
  const tokens = await tokenResponse.json();
  // {
  //   access_token: "ya29.a0...",
  //   expires_in: 3599,
  //   refresh_token: "1//0e...",
  //   scope: "email profile",
  //   token_type: "Bearer"
  // }
  
  // Use access token to get user info
  const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
    headers: { Authorization: `Bearer ${tokens.access_token}` }
  });
  
  const googleUser = await userResponse.json();
  
  // Create or update user in your database
  const user = await db.users.upsert({
    googleId: googleUser.id,
    email: googleUser.email,
    name: googleUser.name,
    picture: googleUser.picture
  });
  
  // Create session for user
  const sessionToken = await createSession(user.id);
  
  res.cookie('session', sessionToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days
  });
  
  res.redirect('/dashboard');
});
```

#### 2. Client Credentials

For server-to-server authentication (no user involved).

```javascript
// Get access token
const tokenResponse = await fetch('https://auth.example.com/token', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: new URLSearchParams({
    grant_type: 'client_credentials',
    client_id: process.env.CLIENT_ID,
    client_secret: process.env.CLIENT_SECRET,
    scope: 'api.read api.write'
  })
});

const { access_token } = await tokenResponse.json();

// Use token
const apiResponse = await fetch('https://api.example.com/data', {
  headers: { Authorization: `Bearer ${access_token}` }
});
```

#### 3. Refresh Token Flow

Exchange refresh token for new access token when it expires.

```javascript
// Access token expired, use refresh token
const refreshResponse = await fetch('https://oauth2.googleapis.com/token', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token: storedRefreshToken,
    client_id: process.env.GOOGLE_CLIENT_ID,
    client_secret: process.env.GOOGLE_CLIENT_SECRET
  })
});

const newTokens = await refreshResponse.json();
// {
//   access_token: "new-access-token",
//   expires_in: 3599,
//   scope: "email profile",
//   token_type: "Bearer"
// }

// Update stored access token
await updateAccessToken(userId, newTokens.access_token);
```

### OAuth 2.0 Scopes

Define what permissions the token has.

```javascript
// Request specific scopes
scope: 'email profile openid'

// In your API, check scopes
app.get('/api/admin', requireScope('admin'), (req, res) => {
  // Only accessible with admin scope
});

function requireScope(requiredScope) {
  return (req, res, next) => {
    const tokenScopes = req.token.scope.split(' ');
    
    if (!tokenScopes.includes(requiredScope)) {
      return res.status(403).json({
        error: {
          code: 'INSUFFICIENT_SCOPE',
          message: `Scope '${requiredScope}' is required`,
          providedScopes: tokenScopes,
          requiredScope
        }
      });
    }
    
    next();
  };
}
```

---

## Token Security: Theft Mitigation

### Problem: Token Theft

```
Attacker intercepts token:
1. Man-in-the-middle attack (if not HTTPS)
2. XSS attack (if stored in localStorage)
3. Stolen from logs
4. Phishing attack
5. Malware on user device
```

### 1. Token Rotation

Rotate tokens regularly to limit damage if stolen.

```javascript
// On each request, issue a new token
app.use('/api', async (req, res, next) => {
  // Validate current token
  const token = extractToken(req);
  const tokenRecord = await validateToken(token);
  
  if (!tokenRecord) {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  // Generate new token
  const newToken = generateToken();
  const expiresAt = new Date(Date.now() + 3600 * 1000);
  
  // Replace old token with new one
  await db.tokens.update(
    { id: tokenRecord.id },
    { token: hashToken(newToken), expiresAt }
  );
  
  // Return new token in response header
  res.set('X-New-Token', newToken);
  
  req.user = await db.users.findById(tokenRecord.userId);
  next();
});
```

### 2. Token Binding

Bind token to specific device/browser.

```javascript
// Generate token with device fingerprint
function generateBoundToken(userId, fingerprint) {
  const token = crypto.randomBytes(32).toString('hex');
  
  db.tokens.create({
    token: hashToken(token),
    userId,
    fingerprint: hashFingerprint(fingerprint),
    expiresAt: new Date(Date.now() + 3600 * 1000)
  });
  
  return token;
}

// Validate token with fingerprint
app.use('/api', async (req, res, next) => {
  const token = extractToken(req);
  const fingerprint = generateFingerprint(req);
  
  const tokenRecord = await db.tokens.findOne({
    token: hashToken(token),
    fingerprint: hashFingerprint(fingerprint)
  });
  
  if (!tokenRecord) {
    return res.status(401).json({
      error: {
        code: 'TOKEN_DEVICE_MISMATCH',
        message: 'Token is not valid for this device'
      }
    });
  }
  
  req.user = await db.users.findById(tokenRecord.userId);
  next();
});

function generateFingerprint(req) {
  // Combine multiple factors
  return [
    req.headers['user-agent'],
    req.headers['accept-language'],
    req.ip
  ].join('|');
}
```

### 3. Refresh Token Rotation

Rotate refresh tokens on each use (prevents replay attacks).

```javascript
app.post('/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  // Find refresh token
  const tokenRecord = await db.refreshTokens.findOne({
    token: hashToken(refreshToken),
    expiresAt: { $gt: new Date() }
  });
  
  if (!tokenRecord) {
    return res.status(401).json({
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Refresh token is invalid or expired'
      }
    });
  }
  
  // Check if token was already used (possible theft!)
  if (tokenRecord.used) {
    // Token reuse detected - revoke all tokens for this user
    await db.refreshTokens.deleteMany({ userId: tokenRecord.userId });
    await db.accessTokens.deleteMany({ userId: tokenRecord.userId });
    
    // Alert user
    await sendSecurityAlert(tokenRecord.userId, 'Token reuse detected');
    
    return res.status(401).json({
      error: {
        code: 'TOKEN_REUSE_DETECTED',
        message: 'Security violation: All tokens have been revoked'
      }
    });
  }
  
  // Mark refresh token as used
  await db.refreshTokens.update(
    { id: tokenRecord.id },
    { used: true, usedAt: new Date() }
  );
  
  // Generate new tokens
  const newAccessToken = generateAccessToken(tokenRecord.userId);
  const newRefreshToken = generateRefreshToken(tokenRecord.userId);
  
  res.json({
    accessToken: newAccessToken,
    refreshToken: newRefreshToken,
    expiresIn: 3600
  });
});
```

### 4. Token Expiration Strategy

Use short-lived access tokens + long-lived refresh tokens.

```javascript
// Short-lived access token (15 minutes)
const accessToken = jwt.sign(
  { userId: user.id },
  process.env.JWT_SECRET,
  { expiresIn: '15m' }
);

// Long-lived refresh token (30 days)
const refreshToken = crypto.randomBytes(32).toString('hex');
await db.refreshTokens.create({
  token: hashToken(refreshToken),
  userId: user.id,
  expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
});

res.json({
  accessToken,
  refreshToken,
  expiresIn: 900 // 15 minutes
});
```

**Why?**
- Access token stolen → Only valid for 15 minutes
- Refresh token stolen → Can detect reuse and revoke

### 5. Secure Storage

**Backend:**
```javascript
// ✅ Store hashed tokens
const hashedToken = crypto
  .createHash('sha256')
  .update(token)
  .digest('hex');

await db.tokens.create({ token: hashedToken });

// ❌ Never store plain tokens
await db.tokens.create({ token }); // Bad!
```

**Frontend:**
```javascript
// ✅ Best: HttpOnly cookie (protected from XSS)
res.cookie('accessToken', token, {
  httpOnly: true,    // Not accessible via JavaScript
  secure: true,      // Only sent over HTTPS
  sameSite: 'strict', // CSRF protection
  maxAge: 3600000    // 1 hour
});

// ⚠️ OK: localStorage (vulnerable to XSS)
localStorage.setItem('accessToken', token);

// ⚠️ OK: sessionStorage (vulnerable to XSS, cleared on tab close)
sessionStorage.setItem('accessToken', token);

// ❌ Bad: Regular cookie (accessible via JavaScript)
res.cookie('accessToken', token); // No httpOnly flag!
```

### 6. IP Address Validation

```javascript
app.use('/api', async (req, res, next) => {
  const token = extractToken(req);
  const tokenRecord = await validateToken(token);
  
  if (!tokenRecord) {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  // Check if IP changed
  const currentIp = req.ip;
  
  if (tokenRecord.ipAddress && tokenRecord.ipAddress !== currentIp) {
    // IP changed - require re-authentication
    await sendSecurityAlert(tokenRecord.userId, 'Login from new IP detected');
    
    return res.status(401).json({
      error: {
        code: 'IP_ADDRESS_CHANGED',
        message: 'Token is not valid from this IP address. Please login again.',
        originalIp: tokenRecord.ipAddress,
        currentIp
      }
    });
  }
  
  req.user = await db.users.findById(tokenRecord.userId);
  next();
});
```

### 7. Anomaly Detection

```javascript
async function detectAnomalies(userId, req) {
  const recentActivity = await db.auditLog.find({
    userId,
    timestamp: { $gt: new Date(Date.now() - 3600000) } // Last hour
  });
  
  // Check for suspicious patterns
  const uniqueIps = new Set(recentActivity.map(a => a.ip)).size;
  const uniqueDevices = new Set(recentActivity.map(a => a.userAgent)).size;
  const requestCount = recentActivity.length;
  
  const anomalies = [];
  
  if (uniqueIps > 3) {
    anomalies.push('Multiple IPs in short time');
  }
  
  if (uniqueDevices > 2) {
    anomalies.push('Multiple devices simultaneously');
  }
  
  if (requestCount > 1000) {
    anomalies.push('Unusually high request rate');
  }
  
  // Check for impossible travel
  const locations = await getLocations(recentActivity.map(a => a.ip));
  for (let i = 1; i < locations.length; i++) {
    const distance = calculateDistance(locations[i-1], locations[i]);
    const timeDiff = (locations[i].timestamp - locations[i-1].timestamp) / 1000 / 60; // minutes
    const speed = distance / timeDiff; // km/min
    
    if (speed > 10) { // Faster than plane
      anomalies.push('Impossible travel detected');
    }
  }
  
  if (anomalies.length > 0) {
    // Require additional verification
    await sendSecurityAlert(userId, 'Suspicious activity detected: ' + anomalies.join(', '));
    
    // Invalidate all tokens
    await revokeAllTokens(userId);
    
    return {
      suspicious: true,
      reasons: anomalies
    };
  }
  
  return { suspicious: false };
}
```

---

## Token Revocation

### 1. Individual Token Revocation

```javascript
// Revoke specific token
app.post('/auth/logout', async (req, res) => {
  const token = extractToken(req);
  
  // Delete token from database
  await db.tokens.delete({ token: hashToken(token) });
  
  // Or mark as revoked
  await db.tokens.update(
    { token: hashToken(token) },
    { revoked: true, revokedAt: new Date() }
  );
  
  res.json({ message: 'Logged out successfully' });
});

// Validation checks revocation
app.use('/api', async (req, res, next) => {
  const token = extractToken(req);
  const tokenRecord = await db.tokens.findOne({
    token: hashToken(token),
    revoked: false  // Check not revoked
  });
  
  if (!tokenRecord) {
    return res.status(401).json({ error: 'Token is invalid or revoked' });
  }
  
  req.user = await db.users.findById(tokenRecord.userId);
  next();
});
```

### 2. Revoke All User Tokens

```javascript
// User clicks "Log out all devices"
app.post('/auth/logout-all', async (req, res) => {
  const userId = req.user.id;
  
  // Delete all tokens for user
  await db.tokens.deleteMany({ userId });
  await db.refreshTokens.deleteMany({ userId });
  
  res.json({ message: 'Logged out from all devices' });
});
```

### 3. JWT Revocation (Using Blocklist)

JWTs are stateless, so you need a blocklist.

```javascript
// Add JWT to blocklist
app.post('/auth/logout', async (req, res) => {
  const token = extractToken(req);
  const decoded = jwt.decode(token);
  
  // Add to blocklist (Redis for performance)
  const ttl = decoded.exp - Math.floor(Date.now() / 1000); // Time until expiration
  await redis.setex(`blocklist:${decoded.jti}`, ttl, 'revoked');
  
  res.json({ message: 'Logged out successfully' });
});

// Check blocklist on each request
app.use('/api', async (req, res, next) => {
  const token = extractToken(req);
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Check blocklist
    const isBlocked = await redis.get(`blocklist:${decoded.jti}`);
    
    if (isBlocked) {
      return res.status(401).json({
        error: {
          code: 'TOKEN_REVOKED',
          message: 'Token has been revoked'
        }
      });
    }
    
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
});
```

### 4. Version-Based Revocation

Include version number in tokens; increment on logout/password change.

```javascript
// User model has tokenVersion field
const user = {
  id: 42,
  email: 'user@example.com',
  tokenVersion: 3  // Incremented on each logout/password change
};

// Include version in token
const token = jwt.sign(
  {
    userId: user.id,
    tokenVersion: user.tokenVersion
  },
  process.env.JWT_SECRET,
  { expiresIn: '1h' }
);

// Validation checks version
app.use('/api', async (req, res, next) => {
  const token = extractToken(req);
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  
  const user = await db.users.findById(decoded.userId);
  
  if (decoded.tokenVersion !== user.tokenVersion) {
    return res.status(401).json({
      error: {
        code: 'TOKEN_VERSION_MISMATCH',
        message: 'Token is outdated. Please login again.'
      }
    });
  }
  
  req.user = user;
  next();
});

// Increment version on logout
app.post('/auth/logout-all', async (req, res) => {
  await db.users.update(
    { id: req.user.id },
    { $inc: { tokenVersion: 1 } }
  );
  
  res.json({ message: 'All tokens invalidated' });
});

// Increment on password change
app.post('/auth/change-password', async (req, res) => {
  // Change password logic...
  
  // Invalidate all existing tokens
  await db.users.update(
    { id: req.user.id },
    { $inc: { tokenVersion: 1 } }
  );
  
  res.json({ message: 'Password changed. Please login again.' });
});
```

---

## Advanced Authentication Methods

### 1. Mutual TLS (mTLS)

Both client and server authenticate each other using certificates.

```javascript
const https = require('https');
const fs = require('fs');

const options = {
  // Server certificate
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),
  
  // Require client certificate
  requestCert: true,
  rejectUnauthorized: true,
  ca: fs.readFileSync('ca-cert.pem') // Certificate Authority
};

const server = https.createServer(options, (req, res) => {
  // Client certificate
  const cert = req.socket.getPeerCertificate();
  
  if (!cert || !cert.subject) {
    res.writeHead(401);
    res.end('Client certificate required');
    return;
  }
  
  // Verify client identity
  const clientId = cert.subject.CN; // Common Name
  console.log('Client authenticated:', clientId);
  
  res.writeHead(200);
  res.end('Hello, ' + clientId);
});

server.listen(443);
```

**Use cases:**
- Service-to-service authentication
- High-security environments
- IoT devices

### 2. HMAC Signatures

Client signs requests using shared secret.

```javascript
// Client side
const crypto = require('crypto');

function signRequest(method, path, body, timestamp, secret) {
  const message = [method, path, timestamp, body].join('\n');
  return crypto
    .createHmac('sha256', secret)
    .update(message)
    .digest('hex');
}

const timestamp = Date.now();
const signature = signRequest('POST', '/api/users', JSON.stringify(body), timestamp, API_SECRET);

fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'X-Timestamp': timestamp,
    'X-Signature': signature,
    'X-API-Key': 'client-id'
  },
  body: JSON.stringify(body)
});

// Server side
app.use('/api', (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  const timestamp = req.headers['x-timestamp'];
  const signature = req.headers['x-signature'];
  
  // Get client's secret
  const client = API_CLIENTS[apiKey];
  if (!client) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  // Check timestamp (prevent replay attacks)
  const now = Date.now();
  if (Math.abs(now - timestamp) > 300000) { // 5 minutes
    return res.status(401).json({ error: 'Request expired' });
  }
  
  // Verify signature
  const message = [req.method, req.path, timestamp, JSON.stringify(req.body)].join('\n');
  const expectedSignature = crypto
    .createHmac('sha256', client.secret)
    .update(message)
    .digest('hex');
  
  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  req.client = client;
  next();
});
```

**Benefits:**
- No token to steal (only signature)
- Request cannot be replayed (timestamp)
- Request cannot be modified (signature covers entire request)

### 3. Biometric Authentication

Use device biometrics (Face ID, Touch ID, fingerprint).

```javascript
// Frontend: WebAuthn API
async function registerBiometric() {
  // Get challenge from server
  const challenge = await fetch('/auth/biometric/register/challenge').then(r => r.json());
  
  // Create credential using device biometric
  const credential = await navigator.credentials.create({
    publicKey: {
      challenge: Uint8Array.from(challenge.challenge, c => c.charCodeAt(0)),
      rp: { name: "MyApp" },
      user: {
        id: Uint8Array.from(challenge.userId, c => c.charCodeAt(0)),
        name: "user@example.com",
        displayName: "John Doe"
      },
      pubKeyCredParams: [{ type: "public-key", alg: -7 }],
      authenticatorSelection: {
        authenticatorAttachment: "platform", // Built-in (Face ID, Touch ID)
        userVerification: "required"
      }
    }
  });
  
  // Send public key to server
  await fetch('/auth/biometric/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      credentialId: credential.id,
      publicKey: arrayBufferToBase64(credential.response.getPublicKey())
    })
  });
}

async function loginBiometric() {
  // Get challenge from server
  const challenge = await fetch('/auth/biometric/login/challenge').then(r => r.json());
  
  // Authenticate using biometric
  const credential = await navigator.credentials.get({
    publicKey: {
      challenge: Uint8Array.from(challenge.challenge, c => c.charCodeAt(0)),
      allowCredentials: [{
        type: "public-key",
        id: Uint8Array.from(challenge.credentialId, c => c.charCodeAt(0))
      }],
      userVerification: "required"
    }
  });
  
  // Send signature to server
  const response = await fetch('/auth/biometric/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      credentialId: credential.id,
      signature: arrayBufferToBase64(credential.response.signature),
      authenticatorData: arrayBufferToBase64(credential.response.authenticatorData),
      clientDataJSON: arrayBufferToBase64(credential.response.clientDataJSON)
    })
  });
  
  const { accessToken } = await response.json();
  return accessToken;
}
```

### 4. Magic Links (Passwordless)

Email a login link, no password needed.

```javascript
// Request magic link
app.post('/auth/magic-link', async (req, res) => {
  const { email } = req.body;
  
  const user = await db.users.findByEmail(email);
  if (!user) {
    // Don't reveal if email exists
    return res.json({ message: 'If that email exists, a login link was sent' });
  }
  
  // Generate one-time token
  const token = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes
  
  await db.magicTokens.create({
    token: hashToken(token),
    userId: user.id,
    expiresAt
  });
  
  // Send email
  const loginUrl = `https://yourapp.com/auth/verify?token=${token}`;
  await sendEmail(user.email, {
    subject: 'Login to YourApp',
    html: `
      <p>Click the link below to login:</p>
      <a href="${loginUrl}">Login to YourApp</a>
      <p>This link expires in 15 minutes.</p>
      <p>If you didn't request this, ignore this email.</p>
    `
  });
  
  res.json({ message: 'If that email exists, a login link was sent' });
});

// Verify magic link
app.get('/auth/verify', async (req, res) => {
  const { token } = req.query;
  
  const magicToken = await db.magicTokens.findOne({
    token: hashToken(token),
    expiresAt: { $gt: new Date() },
    used: false
  });
  
  if (!magicToken) {
    return res.status(401).json({
      error: {
        code: 'INVALID_MAGIC_LINK',
        message: 'Magic link is invalid or expired'
      }
    });
  }
  
  // Mark as used
  await db.magicTokens.update(
    { id: magicToken.id },
    { used: true, usedAt: new Date() }
  );
  
  // Create session
  const sessionToken = await createSession(magicToken.userId);
  
  res.cookie('session', sessionToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 30 * 24 * 60 * 60 * 1000
  });
  
  res.redirect('/dashboard');
});
```

### 5. Multi-Factor Authentication (MFA)

Require additional verification beyond password.

```javascript
// TOTP (Time-based One-Time Password) - Google Authenticator, Authy
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');

// Setup MFA
app.post('/auth/mfa/setup', async (req, res) => {
  // Generate secret
  const secret = speakeasy.generateSecret({
    name: 'YourApp',
    issuer: 'YourApp'
  });
  
  // Save secret to user
  await db.users.update(
    { id: req.user.id },
    { mfaSecret: secret.base32, mfaEnabled: false }
  );
  
  // Generate QR code
  const qrCode = await QRCode.toDataURL(secret.otpauth_url);
  
  res.json({
    secret: secret.base32,
    qrCode
  });
});

// Verify and enable MFA
app.post('/auth/mfa/verify-setup', async (req, res) => {
  const { code } = req.body;
  
  const user = await db.users.findById(req.user.id);
  
  // Verify code
  const verified = speakeasy.totp.verify({
    secret: user.mfaSecret,
    encoding: 'base32',
    token: code,
    window: 2 // Allow 2 time steps of variance
  });
  
  if (!verified) {
    return res.status(400).json({
      error: {
        code: 'INVALID_MFA_CODE',
        message: 'Invalid verification code'
      }
    });
  }
  
  // Enable MFA
  await db.users.update(
    { id: user.id },
    { mfaEnabled: true }
  );
  
  // Generate backup codes
  const backupCodes = Array.from({ length: 10 }, () => 
    crypto.randomBytes(4).toString('hex')
  );
  
  await db.backupCodes.insertMany(
    backupCodes.map(code => ({
      userId: user.id,
      code: hashBackupCode(code)
    }))
  );
  
  res.json({
    message: 'MFA enabled successfully',
    backupCodes
  });
});

// Login with MFA
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await db.users.findByEmail(email);
  
  if (!user || !await bcrypt.compare(password, user.passwordHash)) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Check if MFA is enabled
  if (user.mfaEnabled) {
    // Generate temporary token for MFA step
    const mfaToken = crypto.randomBytes(32).toString('hex');
    await db.mfaTokens.create({
      token: hashToken(mfaToken),
      userId: user.id,
      expiresAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes
    });
    
    return res.json({
      requiresMfa: true,
      mfaToken
    });
  }
  
  // No MFA, return access token
  const accessToken = generateAccessToken(user.id);
  res.json({ accessToken });
});

// Verify MFA code
app.post('/auth/mfa/verify', async (req, res) => {
  const { mfaToken, code, useBackupCode } = req.body;
  
  // Get MFA token
  const mfaTokenRecord = await db.mfaTokens.findOne({
    token: hashToken(mfaToken),
    expiresAt: { $gt: new Date() }
  });
  
  if (!mfaTokenRecord) {
    return res.status(401).json({ error: 'Invalid or expired MFA token' });
  }
  
  const user = await db.users.findById(mfaTokenRecord.userId);
  let verified = false;
  
  if (useBackupCode) {
    // Check backup code
    const backupCode = await db.backupCodes.findOne({
      userId: user.id,
      code: hashBackupCode(code),
      used: false
    });
    
    if (backupCode) {
      verified = true;
      await db.backupCodes.update({ id: backupCode.id }, { used: true });
    }
  } else {
    // Verify TOTP code
    verified = speakeasy.totp.verify({
      secret: user.mfaSecret,
      encoding: 'base32',
      token: code,
      window: 2
    });
  }
  
  if (!verified) {
    return res.status(401).json({
      error: {
        code: 'INVALID_MFA_CODE',
        message: 'Invalid verification code'
      }
    });
  }
  
  // Delete MFA token
  await db.mfaTokens.delete({ id: mfaTokenRecord.id });
  
  // Generate access token
  const accessToken = generateAccessToken(user.id);
  const refreshToken = generateRefreshToken(user.id);
  
  res.json({
    accessToken,
    refreshToken,
    expiresIn: 3600
  });
});
```

---

## Best Practices Summary

### 1. Always Use HTTPS

```javascript
// ✅ Enforce HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https') {
    return res.redirect(`https://${req.hostname}${req.url}`);
  }
  next();
});

// Set HSTS header
app.use((req, res, next) => {
  res.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

### 2. Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: {
    error: {
      code: 'TOO_MANY_ATTEMPTS',
      message: 'Too many login attempts. Please try again later.'
    }
  }
});

app.post('/auth/login', loginLimiter, async (req, res) => {
  // Login logic
});
```

### 3. Token Best Practices

```javascript
// ✅ Short expiration
expiresIn: '15m'

// ✅ Store hashed
token: hashToken(token)

// ✅ Include metadata
{
  userId: 42,
  jti: 'unique-id',  // For revocation
  iat: 1600000000,   // Issued at
  exp: 1600003600    // Expires at
}

// ✅ Use httpOnly cookies
res.cookie('token', token, { httpOnly: true, secure: true, sameSite: 'strict' });

// ❌ Never log tokens
console.log('Token:', token); // Bad!
logger.info('User logged in', { token }); // Bad!
```

### 4. Password Security

```javascript
const bcrypt = require('bcrypt');

// ✅ Hash passwords
const hash = await bcrypt.hash(password, 12); // 12 rounds

// ✅ Validate password strength
function isStrongPassword(password) {
  return password.length >= 8 &&
         /[A-Z]/.test(password) &&
         /[a-z]/.test(password) &&
         /[0-9]/.test(password) &&
         /[^A-Za-z0-9]/.test(password);
}

// ❌ Never store plain passwords
await db.users.create({ password }); // Bad!
```

### 5. Secure Headers

```javascript
const helmet = require('helmet');

app.use(helmet());

// Or manually:
app.use((req, res, next) => {
  res.set({
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'"
  });
  next();
});
```

---

## Summary

### Authentication Method Comparison

| Method | Complexity | Security | Scalability | Use Case |
|--------|-----------|----------|-------------|----------|
| API Keys | ⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | Server-to-server |
| Basic Auth | ⭐ | ⭐ | ⭐⭐⭐⭐⭐ | Internal tools only |
| Bearer Tokens | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | Most APIs |
| JWT | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Stateless APIs |
| OAuth 2.0 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Third-party access |
| mTLS | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | High security |
| HMAC | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Service-to-service |

### Token Security Checklist

✅ **Always use HTTPS**
✅ **Short-lived access tokens** (15 minutes)
✅ **Long-lived refresh tokens** (30 days)
✅ **Store tokens hashed** (SHA-256)
✅ **Rotate refresh tokens** on use
✅ **Detect token reuse**
✅ **Bind tokens to devices**
✅ **Validate IP address** (optional)
✅ **Include jti** (JWT ID) for revocation
✅ **Use httpOnly cookies** when possible
✅ **Rate limit** authentication endpoints
✅ **Monitor for anomalies**
✅ **Support MFA** for sensitive operations

### Token Revocation Strategies

1. **Database tokens:** Delete from database
2. **JWT with blocklist:** Add jti to Redis
3. **Version-based:** Increment tokenVersion
4. **Refresh token rotation:** New token on each refresh

---

## Next Steps

Now that you understand authentication, explore:
- Authorization (RBAC, permissions, scopes)
- Security best practices (CORS, XSS, CSRF, SQL injection)
- OAuth 2.0 implementation details
- Session management strategies
- API security auditing
