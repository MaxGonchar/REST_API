# Resources in REST API

## Introduction

In REST, everything is a **resource**. A resource is any piece of information that can be named and accessed. Resources are the fundamental building blocks of REST APIs - they're the "nouns" in your API design.

**Key concept:** If you can name it, it's a resource. Users, products, orders, images, documents, even search results - all resources.

---

## What is a Resource?

### Definition

A resource is any information or entity that:
1. Can be uniquely identified
2. Can be accessed or manipulated
3. Has one or more representations

### Examples of Resources

**Concrete entities:**
- A specific user: User #123
- A product: Product #456
- An order: Order #789
- A photo: Photo #101

**Collections:**
- All users: `/users`
- All products in a category: `/categories/electronics/products`
- All orders by a user: `/users/123/orders`

**Abstract concepts:**
- Search results: `/search?q=laptop`
- Shopping cart: `/users/123/cart`
- User session: `/sessions/abc123`
- Current weather: `/weather/current?city=London`

**Real-world analogy:**  
Think of a library. Books are resources (individual items), the catalog is a resource (collection), a specific shelf is a resource (filtered collection), and your reading list is a resource (user-specific collection).

---

## Resource Identification through URIs

### What is a URI?

**URI (Uniform Resource Identifier)** - A unique address that identifies a resource on the web.

```
https://api.example.com/v1/users/123
│      │               │  │     │
│      │               │  │     └─ Resource identifier
│      │               │  └─────── Resource type
│      │               └────────── API version
│      └────────────────────────── Domain
└───────────────────────────────── Protocol
```

### URI Design Principles

#### 1. Use Nouns, Not Verbs

```
✅ Good:
GET    /users          (retrieve users)
POST   /users          (create user)
GET    /users/123      (retrieve specific user)
DELETE /users/123      (delete user)

❌ Bad:
GET    /getUsers
POST   /createUser
GET    /getUserById/123
POST   /deleteUser/123
```

**Why?** The HTTP method (GET, POST, DELETE) already describes the action. The URI should describe the resource.

#### 2. Use Plural Nouns for Collections

```
✅ Good:
/users              (collection of users)
/users/123          (single user from the collection)
/products           (collection of products)
/products/456       (single product)

❌ Bad:
/user               (unclear if one or many)
/user/123
/product
/product/456
```

#### 3. Use Hierarchical Structure

```
✅ Good:
/users/123/orders              (orders belonging to user 123)
/users/123/orders/789          (specific order of user 123)
/categories/electronics/products  (products in electronics category)

❌ Bad:
/getUserOrders?userId=123
/orders?userId=123&orderId=789
```

**Key point:** URIs should reflect relationships and hierarchy.

#### 4. Use Lowercase and Hyphens

```
✅ Good:
/user-profiles
/order-history
/shopping-cart

❌ Bad:
/UserProfiles       (avoid camelCase)
/order_history      (avoid underscores)
/SHOPPING-CART      (avoid uppercase)
```

#### 5. Avoid File Extensions

```
✅ Good:
/users/123
(use Accept header to specify format)

❌ Bad:
/users/123.json
/users/123.xml
```

#### 6. Use Query Parameters for Filtering, Sorting, Pagination

```
✅ Good:
/users?status=active
/products?category=electronics&sort=price&order=asc
/orders?page=2&limit=20

❌ Bad:
/users/active
/products/electronics/sortByPrice
/orders/page2
```

---

## Resource Representation

A resource can have multiple **representations** - different formats for the same underlying data.

### What is a Representation?

A representation is how a resource is presented or formatted when transferred between client and server.

**Same resource, different representations:**

```json
// JSON representation
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-01-15T10:30:00Z"
}
```

```xml
<!-- XML representation -->
<user>
  <id>123</id>
  <name>John Doe</name>
  <email>john@example.com</email>
  <createdAt>2025-01-15T10:30:00Z</createdAt>
</user>
```

```html
<!-- HTML representation -->
<div class="user">
  <h2>John Doe</h2>
  <p>Email: john@example.com</p>
  <p>Joined: January 15, 2025</p>
</div>
```

### Common Representation Formats

#### 1. JSON (JavaScript Object Notation)
**Most popular format for REST APIs**

**Advantages:**
- Human-readable
- Lightweight
- Native JavaScript support
- Wide language support

```json
{
  "id": 1,
  "title": "Learn REST API",
  "completed": false,
  "tags": ["learning", "api"],
  "metadata": {
    "priority": "high",
    "dueDate": "2025-12-31"
  }
}
```

#### 2. XML (eXtensible Markup Language)
**Traditional format, still used in enterprise systems**

```xml
<task>
  <id>1</id>
  <title>Learn REST API</title>
  <completed>false</completed>
  <tags>
    <tag>learning</tag>
    <tag>api</tag>
  </tags>
</task>
```

#### 3. HTML
**For human-readable web interfaces**

Used when the client is a web browser and you want to display formatted content.

#### 4. Others
- **CSV** - For data exports
- **Binary formats** - Images (JPEG, PNG), PDFs, videos
- **Protocol Buffers** - Efficient binary serialization
- **MessagePack** - Binary JSON alternative

---

## Content Negotiation

**Content negotiation** is how clients and servers agree on the format of representations.

### Request - Client Specifies Preferred Format

```http
GET /users/123
Accept: application/json
```

The `Accept` header tells the server: "I prefer JSON format."

### Response - Server Confirms Format

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "John Doe"
}
```

The `Content-Type` header tells the client: "This response is in JSON format."

### Multiple Formats Support

```http
GET /users/123
Accept: application/json, application/xml;q=0.9, */*;q=0.8
```

This means:
- I prefer JSON (default quality 1.0)
- XML is acceptable (quality 0.9)
- Any format is acceptable (quality 0.8)

**Server logic:**
1. Check if JSON is available → return JSON
2. If not, check if XML is available → return XML
3. If not, return default format

---

## Self-Descriptive Messages

Every message should contain enough information to describe how to process it.

### Components of Self-Descriptive Messages

#### 1. HTTP Method
Describes the action

```http
GET /users/123        (retrieve)
POST /users           (create)
PUT /users/123        (update/replace)
PATCH /users/123      (partial update)
DELETE /users/123     (delete)
```

#### 2. Headers
Provide metadata about the message

```http
Content-Type: application/json
Content-Length: 256
Authorization: Bearer abc123xyz
Accept: application/json
Cache-Control: no-cache
```

#### 3. Status Code
Describes the result

```http
200 OK                  (success)
201 Created             (resource created)
400 Bad Request         (client error)
404 Not Found           (resource doesn't exist)
500 Internal Server Error  (server error)
```

#### 4. Body
Contains the actual data

```json
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com"
}
```

### Complete Self-Descriptive Example

**Request:**
```http
POST /users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 62
Authorization: Bearer token123

{
  "name": "Jane Smith",
  "email": "jane@example.com"
}
```

**Response:**
```http
HTTP/1.1 201 Created
Content-Type: application/json
Location: /users/124
Content-Length: 89

{
  "id": 124,
  "name": "Jane Smith",
  "email": "jane@example.com",
  "createdAt": "2025-12-18T14:30:00Z"
}
```

**What makes it self-descriptive:**
- Method `POST` → we're creating something
- Status `201 Created` → resource was successfully created
- `Content-Type` → tells us the format
- `Location` → tells us where the new resource is
- Body → contains the created resource

---

## Resource Manipulation through Representations

Clients don't modify resources directly. Instead, they send representations to the server, and the server updates the actual resource.

### How It Works

```
1. Client retrieves representation
   GET /users/123
   
2. Client modifies the representation
   (changes name from "John" to "Jane")
   
3. Client sends modified representation
   PUT /users/123
   { "id": 123, "name": "Jane", ... }
   
4. Server updates the actual resource
   (updates database record)
   
5. Server sends updated representation
   { "id": 123, "name": "Jane", ... }
```

### CRUD Operations with Representations

#### CREATE - Send representation of new resource

```http
POST /users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

**Response:**
```http
HTTP/1.1 201 Created
Location: /users/125

{
  "id": 125,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-12-18T14:30:00Z"
}
```

#### READ - Retrieve representation

```http
GET /users/125
Accept: application/json
```

**Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 125,
  "name": "John Doe",
  "email": "john@example.com"
}
```

#### UPDATE - Send modified representation

**Full update (PUT):**
```http
PUT /users/125
Content-Type: application/json

{
  "id": 125,
  "name": "John Smith",
  "email": "john.smith@example.com"
}
```

**Partial update (PATCH):**
```http
PATCH /users/125
Content-Type: application/json

{
  "name": "John Smith"
}
```

#### DELETE - Remove resource

```http
DELETE /users/125
```

**Response:**
```http
HTTP/1.1 204 No Content
```

---

## Resource Relationships

Resources often relate to other resources. REST APIs should express these relationships in URIs.

### Types of Relationships

#### 1. One-to-Many

```
/users/123/orders          (all orders of user 123)
/categories/5/products     (all products in category 5)
/posts/789/comments        (all comments on post 789)
```

#### 2. Many-to-Many

```
/users/123/groups          (all groups user 123 belongs to)
/groups/456/users          (all users in group 456)
```

#### 3. Nested Resources

```
/users/123/orders/789               (specific order of user 123)
/users/123/orders/789/items         (items in that order)
/users/123/orders/789/items/3       (specific item in that order)
```

### When to Nest vs Use Query Parameters

**Use nesting** when there's a strong ownership relationship:
```
/users/123/orders          ✅ (orders belong to a user)
```

**Use query parameters** for filtering unrelated resources:
```
/orders?userId=123         ✅ (filtering all orders)
/orders?status=pending
```

**Avoid deep nesting:**
```
❌ /users/123/orders/789/items/3/reviews/5
✅ /reviews/5?orderId=789&itemId=3
```

---

## Resource State

Resources have **state** - their current data at a given time.

### State Representation

```json
{
  "id": 789,
  "status": "pending",        // current state
  "items": [...],
  "total": 149.99,
  "createdAt": "2025-12-18T10:00:00Z",
  "updatedAt": "2025-12-18T10:30:00Z"
}
```

### State Transitions

Resources can transition between states through client actions:

```
Order State Machine:
pending → processing → shipped → delivered
   ↓
cancelled
```

**Example transitions:**

```http
// Transition from pending to processing
PATCH /orders/789
{
  "status": "processing"
}

// Transition from processing to shipped
PATCH /orders/789
{
  "status": "shipped",
  "trackingNumber": "ABC123"
}
```

---

## Best Practices for Resources

### 1. Make URIs Intuitive and Predictable

Good URI design is guessable:
```
If /users exists, then /users/123 probably exists
If /users/123/orders exists, then /users/123/orders/789 probably exists
```

### 2. Keep URIs Stable

Once published, URIs should rarely change. Use versioning if needed:
```
/v1/users/123
/v2/users/123
```

### 3. Return Consistent Representations

The same resource should have the same structure across operations:
```json
// GET /users/123
{
  "id": 123,
  "name": "John",
  "email": "john@example.com"
}

// POST /users (response)
{
  "id": 124,
  "name": "Jane",
  "email": "jane@example.com"
}
```

### 4. Use Partial Representations When Needed

**List view (minimal data):**
```json
GET /users
[
  { "id": 1, "name": "John" },
  { "id": 2, "name": "Jane" }
]
```

**Detail view (full data):**
```json
GET /users/1
{
  "id": 1,
  "name": "John",
  "email": "john@example.com",
  "address": {...},
  "preferences": {...}
}
```

### 5. Include Metadata

```json
{
  "data": [...],
  "metadata": {
    "page": 1,
    "perPage": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

### 6. Use Hypermedia Links (HATEOAS)

```json
{
  "id": 123,
  "name": "John Doe",
  "links": {
    "self": "/users/123",
    "orders": "/users/123/orders",
    "edit": "/users/123",
    "delete": "/users/123"
  }
}
```

---

## Common Patterns

### Singleton Resources

Resources that have only one instance:

```
/profile              (current user's profile)
/settings             (current user's settings)
/dashboard            (current user's dashboard)
```

### Sub-resources

```
/users/123/profile
/users/123/settings
/users/123/avatar
```

### Actions on Resources

When standard CRUD isn't enough:

```
POST /orders/789/cancel
POST /users/123/activate
POST /documents/456/publish
```

### Search and Filtering

```
/users?search=john
/products?category=electronics&minPrice=100&maxPrice=500
/posts?tags=rest,api&published=true
```

---

## Summary

**Key Takeaways:**

1. **Resources are nouns** - Everything in REST is a resource
2. **URIs identify resources** - Each resource has a unique address
3. **Representations are formats** - Resources can be represented in JSON, XML, etc.
4. **Self-descriptive messages** - Include all information needed to process the request
5. **Manipulate through representations** - Send representations to modify resources
6. **Express relationships** - Use URI hierarchy and query parameters

**Resource Design Checklist:**
- ✓ Use nouns, not verbs in URIs
- ✓ Use plural forms for collections
- ✓ Keep URIs simple and intuitive
- ✓ Express relationships hierarchically
- ✓ Support multiple representations
- ✓ Include proper metadata in responses
- ✓ Make messages self-descriptive

---

## Next Steps

Now that you understand resources, explore:
- HTTP methods (GET, POST, PUT, PATCH, DELETE)
- Status codes for different scenarios
- Designing relationships between resources
- Practical examples of REST API endpoints
