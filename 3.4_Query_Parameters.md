# Query Parameters in REST API

## Introduction

Query parameters are key-value pairs appended to URLs after a `?` symbol to modify, filter, or control the behavior of API requests. They're one of the most powerful tools for making APIs flexible and expressive without changing the endpoint structure.

**Key principle:** Query parameters should modify **how** you retrieve data, not **what** resource you're accessing.

---

## Query Parameter Basics

### Syntax Structure

```
https://api.example.com/users?status=active&role=admin&sort=createdAt

Base URL: https://api.example.com/users
├─ ? ← Query string start
├─ status=active ← First parameter
├─ & ← Parameter separator
├─ role=admin ← Second parameter
├─ & ← Parameter separator
└─ sort=createdAt ← Third parameter
```

### Multiple Values for Same Parameter

```
# Multiple separate parameters
?tag=javascript&tag=nodejs&tag=react

# Comma-separated (common convention)
?tags=javascript,nodejs,react

# Bracket notation (array style)
?tags[]=javascript&tags[]=nodejs&tags[]=react
```

---

## Core Query Parameter Types

### 1. Filtering Parameters

Filter the collection to return only matching items.

#### Simple Filters

```http
# Single condition
GET /products?category=electronics

# Multiple conditions (AND logic)
GET /products?category=electronics&inStock=true

# Multiple values (OR logic)
GET /products?category=electronics,computers,phones
```

#### Comparison Operators

Many APIs use suffixes to indicate comparison operations:

```http
# Greater than
GET /products?price_gt=100

# Less than
GET /products?price_lt=1000

# Greater than or equal
GET /products?price_gte=100

# Less than or equal
GET /products?price_lte=1000

# Not equal
GET /products?status_ne=archived

# Contains (partial match)
GET /users?name_contains=john

# Starts with
GET /users?email_startswith=admin

# Ends with
GET /files?filename_endswith=.pdf

# In list
GET /products?id_in=1,2,3,4,5
```

#### Range Filters

```http
# Date range
GET /orders?createdAt_gte=2026-01-01&createdAt_lte=2026-01-31

# Price range
GET /products?price_between=100,500

# Alternative range syntax
GET /products?minPrice=100&maxPrice=500
```

#### Real-World Example

```http
GET /api/v1/products?
  category=electronics&
  inStock=true&
  price_gte=100&
  price_lte=1000&
  brand=Apple,Samsung,Sony&
  rating_gte=4.0

Response:
{
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "category": "electronics",
      "price": 999,
      "brand": "Apple",
      "rating": 4.8,
      "inStock": true
    }
  ],
  "filters": {
    "applied": {
      "category": "electronics",
      "inStock": true,
      "priceRange": {"min": 100, "max": 1000},
      "brands": ["Apple", "Samsung", "Sony"],
      "minRating": 4.0
    }
  }
}
```

---

### 2. Sorting Parameters

Control the order of returned items.

#### Basic Sorting

```http
# Sort by single field (ascending)
GET /users?sort=createdAt

# Sort descending (minus prefix)
GET /users?sort=-createdAt

# Sort descending (explicit)
GET /users?sort=createdAt&order=desc

# Multiple fields
GET /users?sort=lastName,firstName
GET /users?sort=-createdAt,name
```

#### Alternative Sorting Conventions

```http
# Convention 1: sort + order parameters
GET /products?sort=price&order=asc

# Convention 2: sortBy + sortOrder
GET /products?sortBy=price&sortOrder=ascending

# Convention 3: orderBy with direction
GET /products?orderBy=price:asc

# Convention 4: Separate params for each field
GET /users?orderBy[]=lastName:asc&orderBy[]=firstName:asc
```

#### Real-World Example

```http
GET /api/v1/products?
  sort=-rating,price&
  category=electronics

# Results sorted by:
# 1. Rating (highest first)
# 2. Then by price (lowest first)

Response:
{
  "data": [
    {
      "id": 1,
      "name": "Product A",
      "rating": 4.9,
      "price": 299
    },
    {
      "id": 2,
      "name": "Product B",
      "rating": 4.9,
      "price": 399
    },
    {
      "id": 3,
      "name": "Product C",
      "rating": 4.7,
      "price": 199
    }
  ],
  "sorting": {
    "fields": [
      {"field": "rating", "order": "desc"},
      {"field": "price", "order": "asc"}
    ]
  }
}
```

---

### 3. Pagination Parameters

Control which subset of results to return.

#### Page-Based Pagination

```http
# Page number + items per page
GET /users?page=2&limit=20

# Alternative naming
GET /users?page=2&perPage=20
GET /users?page=2&size=20
GET /users?pageNumber=2&pageSize=20
```

**Response:**
```json
{
  "data": [...],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 150,
    "pages": 8,
    "hasNext": true,
    "hasPrev": true
  },
  "links": {
    "first": "/users?page=1&limit=20",
    "prev": "/users?page=1&limit=20",
    "self": "/users?page=2&limit=20",
    "next": "/users?page=3&limit=20",
    "last": "/users?page=8&limit=20"
  }
}
```

#### Offset-Based Pagination

```http
# Skip N items, take M items
GET /users?offset=40&limit=20

# Skip 40, take 20 (items 41-60)
```

**Response:**
```json
{
  "data": [...],
  "pagination": {
    "offset": 40,
    "limit": 20,
    "total": 150
  },
  "links": {
    "prev": "/users?offset=20&limit=20",
    "next": "/users?offset=60&limit=20"
  }
}
```

#### Cursor-Based Pagination

```http
# First page
GET /users?limit=20

# Next page using cursor
GET /users?cursor=eyJpZCI6MTAwfQ&limit=20

# Previous page
GET /users?cursor=eyJpZCI6NjB9&direction=prev&limit=20
```

**Response:**
```json
{
  "data": [...],
  "pagination": {
    "cursor": {
      "next": "eyJpZCI6MTIwfQ",
      "prev": "eyJpZCI6ODB9"
    },
    "hasNext": true,
    "hasPrev": true
  },
  "links": {
    "next": "/users?cursor=eyJpZCI6MTIwfQ&limit=20",
    "prev": "/users?cursor=eyJpZCI6ODB9&limit=20"
  }
}
```

---

### 4. Field Selection (Sparse Fieldsets)

Request only specific fields to reduce response size.

#### Basic Field Selection

```http
# Select specific fields
GET /users?fields=id,name,email

# Nested field selection
GET /users?fields=id,name,profile.avatar,profile.bio
```

**Full vs Sparse Response:**

```http
# Full response
GET /users/42

{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com",
  "phone": "+1234567890",
  "address": {...},
  "profile": {...},
  "settings": {...},
  "createdAt": "2025-01-01T00:00:00Z",
  "updatedAt": "2026-01-13T10:00:00Z"
}

# Sparse response
GET /users/42?fields=id,name,email

{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com"
}
```

#### Complex Field Selection

```http
# Include and exclude patterns
GET /users?fields=*,-password,-ssn

# Nested selections
GET /posts?fields=id,title,author(id,name),comments(id,text,author(name))

# Alternative syntax for nested
GET /posts?fields[post]=id,title&fields[author]=id,name
```

---

### 5. Search Parameters

Full-text search across resources.

#### Simple Search

```http
# Search in default fields
GET /products?search=laptop

# Search in specific field
GET /products?search=name:laptop

# Search with multiple terms
GET /products?search=gaming+laptop
GET /products?q=gaming+laptop
```

#### Advanced Search

```http
# Boolean operators
GET /products?search=laptop AND (gaming OR professional)

# Phrase search (quoted)
GET /articles?search="machine learning"

# Field-specific search
GET /users?search=name:john AND email:gmail.com

# Wildcard search
GET /products?search=lap*top
```

---

### 6. Resource Expansion (Include/Embed)

Include related resources in the response.

#### Basic Expansion

```http
# Without expansion
GET /posts/42

{
  "id": 42,
  "title": "Post Title",
  "authorId": 10,
  "categoryId": 5
}

# With expansion
GET /posts/42?include=author,category

{
  "id": 42,
  "title": "Post Title",
  "authorId": 10,
  "author": {
    "id": 10,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "categoryId": 5,
  "category": {
    "id": 5,
    "name": "Technology"
  }
}
```

#### Multi-Level Expansion

```http
# Expand nested relationships
GET /posts/42?include=author,comments.author

{
  "id": 42,
  "title": "Post Title",
  "author": {...},
  "comments": [
    {
      "id": 1,
      "text": "Great post!",
      "author": {
        "id": 20,
        "name": "Jane Smith"
      }
    }
  ]
}
```

#### Alternative Conventions

```http
# Using 'expand'
GET /orders/42?expand=customer,items.product

# Using 'embed'
GET /posts/42?embed=author,comments

# Using 'with'
GET /users/42?with=profile,orders
```

---

## Advanced Query Parameter Patterns

### 1. Passing Arrays

Different conventions for array parameters.

#### Convention 1: Repeated Parameters

```http
GET /products?tag=javascript&tag=nodejs&tag=react

# Server receives: tags = ["javascript", "nodejs", "react"]
```

#### Convention 2: Comma-Separated

```http
GET /products?tags=javascript,nodejs,react

# Server receives: tags = ["javascript", "nodejs", "react"]
```

#### Convention 3: Bracket Notation

```http
GET /products?tags[]=javascript&tags[]=nodejs&tags[]=react

# Server receives: tags = ["javascript", "nodejs", "react"]
```

#### Convention 4: Indexed Arrays

```http
GET /products?tags[0]=javascript&tags[1]=nodejs&tags[2]=react

# Server receives: tags = ["javascript", "nodejs", "react"]
```

#### Real-World Example

```http
GET /api/v1/reports/generate?
  years[]=2023&
  years[]=2024&
  years[]=2025&
  metrics[]=revenue&
  metrics[]=growth&
  metrics[]=profit

Response:
{
  "reportId": "report-abc-123",
  "parameters": {
    "years": [2023, 2024, 2025],
    "metrics": ["revenue", "growth", "profit"]
  },
  "status": "generating"
}
```

---

### 2. Passing Objects/Nested Structures

#### Convention 1: Bracket Notation

```http
GET /products?filter[price][min]=100&filter[price][max]=500&filter[category]=electronics

# Server receives:
{
  "filter": {
    "price": {
      "min": 100,
      "max": 500
    },
    "category": "electronics"
  }
}
```

#### Convention 2: Dot Notation

```http
GET /products?filter.price.min=100&filter.price.max=500&filter.category=electronics

# Server receives: same structure as above
```

#### Convention 3: JSON Encoding

```http
GET /products?filter={"price":{"min":100,"max":500},"category":"electronics"}

# URL encoded:
GET /products?filter=%7B%22price%22%3A%7B%22min%22%3A100%2C%22max%22%3A500%7D%2C%22category%22%3A%22electronics%22%7D

# Server receives: parsed JSON object
```

#### Real-World Example

```http
GET /api/v1/products?
  filter[category]=electronics&
  filter[price][gte]=100&
  filter[price][lte]=1000&
  filter[tags][in]=featured,bestseller&
  filter[inStock]=true

Response:
{
  "data": [...],
  "appliedFilters": {
    "category": "electronics",
    "price": {
      "gte": 100,
      "lte": 1000
    },
    "tags": {
      "in": ["featured", "bestseller"]
    },
    "inStock": true
  }
}
```

---

### 3. Boolean Parameters

Different ways to represent boolean values.

#### Convention 1: true/false strings

```http
GET /users?active=true
GET /users?active=false
```

#### Convention 2: 1/0 values

```http
GET /users?active=1
GET /users?active=0
```

#### Convention 3: Presence/absence

```http
GET /users?active    # active=true (present)
GET /users           # active not specified
```

#### Convention 4: yes/no

```http
GET /users?newsletter=yes
GET /users?newsletter=no
```

**Best Practice:** Use `true`/`false` strings for clarity.

```http
# ✅ Clear and unambiguous
GET /products?inStock=true&featured=false

# ❌ Can be confusing
GET /products?inStock=1&featured=0
```

---

### 4. Date and Time Parameters

#### ISO 8601 Format (Recommended)

```http
# Date only
GET /orders?createdAt=2026-01-13

# Date with time
GET /orders?createdAt=2026-01-13T10:00:00Z

# Date range
GET /orders?startDate=2026-01-01&endDate=2026-01-31

# Timestamp (Unix epoch)
GET /orders?createdAfter=1673611200
```

#### Relative Time Parameters

```http
# Last N days
GET /analytics?period=last7days
GET /analytics?period=last30days

# Today, yesterday
GET /logs?date=today
GET /logs?date=yesterday

# This week, this month
GET /reports?period=thisWeek
GET /reports?period=thisMonth
```

#### Real-World Example

```http
GET /api/v1/orders?
  createdAt_gte=2026-01-01T00:00:00Z&
  createdAt_lte=2026-01-31T23:59:59Z&
  status=completed&
  sort=-createdAt

Response:
{
  "data": [...],
  "filters": {
    "dateRange": {
      "start": "2026-01-01T00:00:00Z",
      "end": "2026-01-31T23:59:59Z"
    },
    "status": "completed"
  },
  "summary": {
    "totalOrders": 234,
    "dateRange": "January 2026"
  }
}
```

---

### 5. Special Query Parameters

#### Meta Parameters

Control API behavior, not data filtering.

```http
# API version (alternative to URI versioning)
GET /users?v=2
GET /users?api_version=2.1

# Response format
GET /users?format=json
GET /users?format=xml
GET /users?format=csv

# Pretty print (debugging)
GET /users?pretty=true

# Locale/language
GET /products?locale=en-US
GET /products?lang=fr

# Timezone
GET /events?timezone=America/New_York
```

#### Cache Control Parameters

```http
# Bypass cache
GET /products?nocache=true
GET /products?refresh=true

# Cache bust
GET /products?_=1673611200  # timestamp
```

#### Debug Parameters

```http
# Include debug info
GET /users?debug=true

# Show SQL query
GET /users?explain=true

# Verbose response
GET /users?verbose=true
```

#### Real-World Example

```http
GET /api/v1/products?
  category=electronics&
  locale=en-US&
  currency=USD&
  format=json&
  pretty=true

Response:
{
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "price": {
        "amount": 999,
        "currency": "USD",
        "formatted": "$999.00"
      }
    }
  ],
  "meta": {
    "locale": "en-US",
    "currency": "USD",
    "timezone": "America/New_York"
  }
}
```

---

## URL Encoding

### When to Encode

Special characters must be URL encoded.

#### Characters That Need Encoding

```http
# Space → %20 or +
search=hello world → search=hello%20world
search=hello world → search=hello+world

# Special characters
email=user@example.com → email=user%40example.com
filter=price>100 → filter=price%3E100
tag=C++ → tag=C%2B%2B

# Brackets
tags[]=js → tags%5B%5D=js

# Quotes
search="exact phrase" → search=%22exact%20phrase%22
```

#### Common URL Encodings

```
Space    → %20 or +
!        → %21
"        → %22
#        → %23
$        → %24
%        → %25
&        → %26
'        → %27
(        → %28
)        → %29
*        → %2A
+        → %2B
,        → %2C
/        → %2F
:        → %3A
;        → %3B
=        → %3D
?        → %3F
@        → %40
[        → %5B
]        → %5D
{        → %7B
}        → %7D
```

#### Example: Complex Query with Encoding

```http
# Before encoding
GET /search?q=machine learning&tags[]=AI&tags[]=ML&author.name=John Doe

# After encoding
GET /search?q=machine%20learning&tags%5B%5D=AI&tags%5B%5D=ML&author.name=John%20Doe
```

---

## Query Parameter Conventions

### 1. Naming Conventions

#### Snake Case (Recommended)

```http
GET /users?first_name=John&created_at_gte=2026-01-01
```

#### Camel Case

```http
GET /users?firstName=John&createdAtGte=2026-01-01
```

#### Kebab Case

```http
GET /users?first-name=John&created-at-gte=2026-01-01
```

**Best Practice:** Choose one and be consistent across your entire API.

---

### 2. Filter Operator Conventions

#### Suffix Style (Recommended)

```http
GET /products?price_gt=100&price_lt=1000
GET /products?name_contains=laptop
GET /products?tags_in=electronics,computers
```

**Common suffixes:**
- `_eq` - Equal (usually default, can be omitted)
- `_ne` - Not equal
- `_gt` - Greater than
- `_gte` - Greater than or equal
- `_lt` - Less than
- `_lte` - Less than or equal
- `_in` - In list
- `_nin` - Not in list
- `_contains` - Contains substring
- `_startswith` - Starts with
- `_endswith` - Ends with
- `_regex` - Regular expression match
- `_exists` - Field exists/is not null
- `_between` - Between two values

#### Bracket Style

```http
GET /products?price[gt]=100&price[lt]=1000
GET /products?name[contains]=laptop
```

#### Query Language Style

```http
GET /products?filter=price>100 AND price<1000
GET /products?where=status='active' AND created_at>'2026-01-01'
```

---

### 3. Combining Multiple Query Parameters

Real-world complex queries combine multiple parameter types.

#### Example 1: Product Catalog

```http
GET /api/v1/products?
  category=electronics&
  brand=Apple,Samsung&
  price_gte=500&
  price_lte=2000&
  inStock=true&
  rating_gte=4.0&
  tags=featured,bestseller&
  search=laptop&
  sort=-rating,price&
  page=1&
  limit=20&
  include=reviews,specifications&
  fields=id,name,price,rating,brand

Response:
{
  "data": [
    {
      "id": 1,
      "name": "MacBook Pro",
      "price": 1999,
      "rating": 4.8,
      "brand": "Apple",
      "reviews": [...],
      "specifications": {...}
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 45,
    "pages": 3
  },
  "filters": {
    "category": "electronics",
    "brands": ["Apple", "Samsung"],
    "priceRange": {"min": 500, "max": 2000},
    "inStock": true,
    "minRating": 4.0,
    "tags": ["featured", "bestseller"],
    "search": "laptop"
  },
  "sorting": [
    {"field": "rating", "order": "desc"},
    {"field": "price", "order": "asc"}
  ]
}
```

#### Example 2: Analytics Dashboard

```http
GET /api/v1/analytics/sales?
  startDate=2026-01-01&
  endDate=2026-01-31&
  groupBy=day&
  metrics=revenue,orders,averageOrderValue&
  regions=US,CA,UK&
  products[]=product-123&
  products[]=product-456&
  include=compareToPrevious&
  format=json

Response:
{
  "data": [
    {
      "date": "2026-01-01",
      "revenue": 45230.50,
      "orders": 234,
      "averageOrderValue": 193.29,
      "breakdown": {
        "US": {"revenue": 30000, "orders": 150},
        "CA": {"revenue": 10000, "orders": 50},
        "UK": {"revenue": 5230.50, "orders": 34}
      }
    }
  ],
  "comparison": {
    "previousPeriod": {
      "revenue": 42100,
      "orders": 220,
      "growth": "+7.4%"
    }
  },
  "filters": {
    "dateRange": {
      "start": "2026-01-01",
      "end": "2026-01-31"
    },
    "regions": ["US", "CA", "UK"],
    "products": ["product-123", "product-456"]
  }
}
```

---

## Best Practices

### 1. Keep Query Parameters Optional

```http
# ✅ Base endpoint works without params
GET /products
→ Returns all products (with sensible defaults)

# ✅ Params refine results
GET /products?category=electronics
→ Returns electronics only

# ❌ Requiring params for basic functionality
GET /products  
→ 400 Bad Request: "category parameter required"
```

---

### 2. Provide Sensible Defaults

```http
# Without pagination params
GET /users

# Server applies defaults:
# - limit: 20 (reasonable page size)
# - page: 1 (first page)
# - sort: -createdAt (newest first)

Response:
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 1500
  }
}
```

---

### 3. Validate and Return Clear Errors

```http
# Invalid value
GET /products?limit=abc

Response:
HTTP/1.1 400 Bad Request
{
  "error": "Validation Failed",
  "details": [
    {
      "parameter": "limit",
      "message": "Must be a positive integer",
      "value": "abc"
    }
  ]
}

# Out of range
GET /products?limit=10000

Response:
HTTP/1.1 400 Bad Request
{
  "error": "Validation Failed",
  "details": [
    {
      "parameter": "limit",
      "message": "Maximum limit is 100",
      "value": 10000,
      "max": 100
    }
  ]
}
```

---

### 4. Document Parameter Limits

```http
# Clearly communicate limits in docs and responses
GET /products?limit=150

Response:
HTTP/1.1 400 Bad Request
{
  "error": "Invalid Parameter",
  "message": "limit parameter exceeds maximum",
  "parameter": "limit",
  "value": 150,
  "constraints": {
    "min": 1,
    "max": 100,
    "default": 20
  }
}
```

---

### 5. Use Consistent Parameter Names

```http
# ✅ Consistent across all endpoints
GET /users?page=1&limit=20
GET /products?page=1&limit=20
GET /orders?page=1&limit=20

# ❌ Inconsistent
GET /users?page=1&limit=20
GET /products?pageNum=1&perPage=20
GET /orders?offset=0&count=20
```

---

### 6. Echo Applied Parameters in Response

```http
GET /products?
  category=electronics&
  price_gte=100&
  sort=-rating&
  page=2&
  limit=20

Response:
{
  "data": [...],
  "request": {
    "filters": {
      "category": "electronics",
      "price": {"gte": 100}
    },
    "sorting": [{"field": "rating", "order": "desc"}],
    "pagination": {"page": 2, "limit": 20}
  }
}
```

---

### 7. Support Parameter Discovery

```http
# OPTIONS request shows available parameters
OPTIONS /products

Response:
HTTP/1.1 200 OK
{
  "endpoint": "/products",
  "methods": ["GET", "POST"],
  "parameters": {
    "category": {
      "type": "string",
      "description": "Filter by category",
      "values": ["electronics", "clothing", "books"]
    },
    "price_gte": {
      "type": "number",
      "description": "Minimum price"
    },
    "price_lte": {
      "type": "number",
      "description": "Maximum price"
    },
    "sort": {
      "type": "string",
      "description": "Sort field (prefix with - for desc)",
      "values": ["name", "price", "rating", "createdAt"]
    },
    "page": {
      "type": "integer",
      "default": 1,
      "min": 1
    },
    "limit": {
      "type": "integer",
      "default": 20,
      "min": 1,
      "max": 100
    }
  }
}
```

---

## Common Mistakes

### Mistake 1: Using Query Params to Identify Resources

```http
# ❌ Wrong - Resource ID in query param
GET /users?id=42

# ✅ Correct - Resource ID in path
GET /users/42
```

### Mistake 2: Inconsistent Naming

```http
# ❌ Inconsistent
GET /users?page=1&limit=20
GET /products?pageNum=1&perPage=20

# ✅ Consistent
GET /users?page=1&limit=20
GET /products?page=1&limit=20
```

### Mistake 3: Not URL Encoding

```http
# ❌ Unencoded special characters
GET /search?q=machine learning&tags[]=AI

# ✅ Properly encoded
GET /search?q=machine%20learning&tags%5B%5D=AI
```

### Mistake 4: Ignoring Param Order in Caching

```http
# These should return same cached result:
GET /products?category=electronics&sort=price
GET /products?sort=price&category=electronics

# Server should normalize parameter order for cache keys
```

### Mistake 5: No Maximum Limit

```http
# ❌ Allows unbounded queries
GET /users?limit=999999999
→ Server crashes trying to return millions of records

# ✅ Enforce maximum
GET /users?limit=999999999
→ 400 Bad Request: "Maximum limit is 100"
```

### Mistake 6: Complex Logic in Query Params

```http
# ❌ Too complex for query params
GET /products?filter=(price>100 AND (category='electronics' OR category='computers')) AND (brand='Apple' OR brand='Samsung') AND rating>=4.0

# ✅ Use POST for complex queries
POST /products/search
{
  "filter": {
    "and": [
      {"price": {"gt": 100}},
      {"or": [
        {"category": "electronics"},
        {"category": "computers"}
      ]},
      {"or": [
        {"brand": "Apple"},
        {"brand": "Samsung"}
      ]},
      {"rating": {"gte": 4.0}}
    ]
  }
}
```

---

## Query Parameter Security

### 1. Input Validation

```javascript
// ✅ Validate all parameters
GET /users?email=user@example.com

// Server-side validation:
function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!regex.test(email)) {
    throw new ValidationError('Invalid email format');
  }
  // Sanitize for SQL injection
  return sanitize(email);
}
```

### 2. SQL Injection Prevention

```http
# ❌ Vulnerable to SQL injection
GET /users?name='; DROP TABLE users; --

# ✅ Use parameterized queries
// Server-side (pseudocode):
query = "SELECT * FROM users WHERE name = ?";
execute(query, [params.name]);  // Safe
```

### 3. Rate Limiting on Expensive Queries

```http
# Expensive query (no filters, large limit)
GET /users?limit=100&include=orders,profile,settings

Response:
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1673611260

{
  "error": "Rate Limit Exceeded",
  "message": "Expensive queries are limited to 10 per minute"
}
```

### 4. Sanitize Output

```http
# User-provided search term in response
GET /search?q=<script>alert('xss')</script>

Response:
{
  "query": "&lt;script&gt;alert('xss')&lt;/script&gt;",  // Escaped
  "results": [...]
}
```

---

## Real-World Complete Examples

### Example 1: E-commerce Product Search

```http
GET /api/v1/products?
  search=wireless+headphones&
  category=electronics&
  subcategory=audio&
  brand=Sony,Bose,Apple&
  price_gte=50&
  price_lte=300&
  rating_gte=4.0&
  features=noise-canceling,bluetooth&
  inStock=true&
  sort=-rating,price&
  page=1&
  limit=24&
  include=reviews.author&
  fields=id,name,brand,price,rating,images.thumbnail&
  currency=USD&
  locale=en-US

Response:
HTTP/1.1 200 OK
Content-Type: application/json
X-Total-Count: 87
Link: </api/v1/products?...&page=2>; rel="next"

{
  "data": [
    {
      "id": "prod-123",
      "name": "Sony WH-1000XM5",
      "brand": "Sony",
      "price": {
        "amount": 399.99,
        "currency": "USD",
        "formatted": "$399.99"
      },
      "rating": 4.8,
      "images": {
        "thumbnail": "https://cdn.example.com/thumbnails/prod-123.jpg"
      },
      "reviews": [
        {
          "id": "rev-456",
          "rating": 5,
          "text": "Amazing sound quality!",
          "author": {
            "id": "user-789",
            "name": "John D.",
            "verified": true
          }
        }
      ]
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 24,
    "total": 87,
    "pages": 4,
    "hasNext": true,
    "hasPrev": false
  },
  "facets": {
    "brands": [
      {"name": "Sony", "count": 32},
      {"name": "Bose", "count": 28},
      {"name": "Apple", "count": 27}
    ],
    "priceRanges": [
      {"range": "50-100", "count": 23},
      {"range": "100-200", "count": 35},
      {"range": "200-300", "count": 29}
    ]
  },
  "appliedFilters": {
    "search": "wireless headphones",
    "category": "electronics",
    "subcategory": "audio",
    "brands": ["Sony", "Bose", "Apple"],
    "priceRange": {"min": 50, "max": 300},
    "minRating": 4.0,
    "features": ["noise-canceling", "bluetooth"],
    "inStock": true
  }
}
```

---

### Example 2: Analytics API with Complex Filtering

```http
GET /api/v1/analytics/revenue?
  startDate=2026-01-01&
  endDate=2026-01-31&
  groupBy=day&
  metrics=revenue,orders,conversion&
  filters[channel]=web,mobile&
  filters[country]=US,CA,UK&
  filters[category]=electronics&
  breakdown=channel,country&
  compare=previousPeriod&
  timezone=America/New_York&
  format=json

Response:
{
  "data": [
    {
      "date": "2026-01-01",
      "revenue": 125430.50,
      "orders": 523,
      "conversion": 3.2,
      "breakdown": {
        "byChannel": {
          "web": {"revenue": 85430.50, "orders": 340},
          "mobile": {"revenue": 40000, "orders": 183}
        },
        "byCountry": {
          "US": {"revenue": 85000, "orders": 350},
          "CA": {"revenue": 25000, "orders": 105},
          "UK": {"revenue": 15430.50, "orders": 68}
        }
      }
    }
  ],
  "comparison": {
    "current": {
      "revenue": 3882345,
      "orders": 16213,
      "conversion": 3.1
    },
    "previous": {
      "revenue": 3621100,
      "orders": 15102,
      "conversion": 2.9
    },
    "change": {
      "revenue": "+7.2%",
      "orders": "+7.4%",
      "conversion": "+6.9%"
    }
  },
  "filters": {
    "dateRange": {
      "start": "2026-01-01",
      "end": "2026-01-31"
    },
    "channels": ["web", "mobile"],
    "countries": ["US", "CA", "UK"],
    "category": "electronics"
  },
  "meta": {
    "timezone": "America/New_York",
    "generatedAt": "2026-01-14T10:00:00-05:00"
  }
}
```

---

## Summary

### Query Parameter Categories

```
Query Parameters
├─ Filtering
│  ├─ Exact match: ?status=active
│  ├─ Comparison: ?price_gt=100
│  ├─ Range: ?price_between=100,500
│  └─ List: ?tags=js,node,react
│
├─ Sorting
│  ├─ Single field: ?sort=createdAt
│  ├─ Multiple fields: ?sort=-rating,price
│  └─ With direction: ?sort=price&order=asc
│
├─ Pagination
│  ├─ Page-based: ?page=2&limit=20
│  ├─ Offset-based: ?offset=40&limit=20
│  └─ Cursor-based: ?cursor=abc123&limit=20
│
├─ Field Selection
│  ├─ Sparse: ?fields=id,name,email
│  └─ Nested: ?fields=id,author(name)
│
├─ Search
│  ├─ Simple: ?search=laptop
│  └─ Complex: ?q=gaming AND laptop
│
├─ Expansion
│  ├─ Include: ?include=author,comments
│  └─ Embed: ?embed=related
│
└─ Special
   ├─ Meta: ?locale=en-US&format=json
   ├─ Cache: ?nocache=true
   └─ Debug: ?debug=true
```

### Key Conventions

1. **Operator Suffixes:** `_gt`, `_lt`, `_gte`, `_lte`, `_in`, `_contains`
2. **Array Notation:** Brackets `tags[]`, comma-separated `tags=a,b,c`
3. **Object Notation:** Brackets `filter[price][min]` or dots `filter.price.min`
4. **Boolean Values:** Use `true`/`false` strings
5. **Dates:** ISO 8601 format `2026-01-13T10:00:00Z`
6. **Sorting:** Minus prefix for descending `sort=-createdAt`

### Best Practices Checklist

- ✅ Make parameters optional with sensible defaults
- ✅ Validate all input and return clear errors
- ✅ Be consistent across all endpoints
- ✅ URL encode special characters
- ✅ Document parameter constraints (min, max, default)
- ✅ Echo applied parameters in response
- ✅ Enforce maximum limits to prevent abuse
- ✅ Use path parameters for resource IDs, query params for filtering
- ✅ Support parameter discovery (OPTIONS)
- ✅ Sanitize input to prevent injection attacks

---

## Next Steps

Now that you understand query parameters, explore:
- API versioning strategies
- Error handling patterns
- Rate limiting implementation
- Caching strategies
- HATEOAS and hypermedia
- Advanced filtering with query languages
- GraphQL as an alternative for complex queries
