# API Versioning Strategies

## Introduction

API versioning is essential for evolving your API without breaking existing clients. As your API grows and changes, you need a strategy to introduce new features, fix bugs, and deprecate old functionality while maintaining backward compatibility for existing users.

**Key principle:** Never break existing clients. Give them time to migrate to new versions.

---

## Why Versioning Matters

### The Breaking Change Problem

```http
# Your API in 2024
GET /users/42
Response:
{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com"
}

# You want to change to separate first/last name in 2025
GET /users/42
Response:
{
  "id": 42,
  "firstName": "John",    ‚Üê New field
  "lastName": "Doe",      ‚Üê New field
  "email": "john@example.com"
  // "name" removed!      ‚Üê Breaking change!
}

# Existing clients break:
client.displayName(user.name);  // undefined! üí•
```

**Without versioning:** All clients break immediately
**With versioning:** Old clients keep working, new clients get new features

---

## Versioning Strategies

### 1. URI Versioning (Most Common)

Version number in the URL path.

```http
GET /v1/users
GET /v2/users
GET /v3/users
```

**Structure options:**

```http
# Major version only (recommended)
https://api.example.com/v1/users
https://api.example.com/v2/users

# With /api prefix
https://api.example.com/api/v1/users
https://api.example.com/api/v2/users

# Version first
https://api.example.com/v1/users
https://api.example.com/v2/products

# API subdomain
https://api-v1.example.com/users
https://api-v2.example.com/users
```

#### Pros

‚úÖ **Simple and visible** - Version is obvious in URL
‚úÖ **Easy to route** - Load balancers and proxies can route by path
‚úÖ **Easy to test** - Different URLs for different versions
‚úÖ **Cacheable** - Each version has unique URL
‚úÖ **Browser-friendly** - Can test in browser easily

#### Cons

‚ùå **Not RESTful purist** - URI should identify resource, not version
‚ùå **URL proliferation** - Multiple URLs for same resource
‚ùå **Documentation overhead** - Need to document all versions

#### Implementation Example

```javascript
// Express.js
const express = require('express');
const app = express();

// V1 routes
app.get('/v1/users', (req, res) => {
  const users = db.users.findAll();
  res.json(users.map(u => ({
    id: u.id,
    name: u.name,  // Single name field
    email: u.email
  })));
});

app.get('/v1/users/:id', (req, res) => {
  const user = db.users.findById(req.params.id);
  res.json({
    id: user.id,
    name: user.name,
    email: user.email
  });
});

// V2 routes (new structure)
app.get('/v2/users', (req, res) => {
  const users = db.users.findAll();
  res.json(users.map(u => ({
    id: u.id,
    firstName: u.firstName,  // Split name
    lastName: u.lastName,
    email: u.email
  })));
});

app.get('/v2/users/:id', (req, res) => {
  const user = db.users.findById(req.params.id);
  res.json({
    id: user.id,
    firstName: user.firstName,
    lastName: user.lastName,
    email: user.email
  });
});
```

---

### 2. Header Versioning (API Version Header)

Version specified in HTTP header.

```http
GET /users
API-Version: 2
Accept: application/json
```

**Header conventions:**

```http
# Custom header
API-Version: 2
X-API-Version: 2
Version: 2

# With semantic versioning
API-Version: 2.1.0
```

#### Pros

‚úÖ **RESTful** - URI identifies resource consistently
‚úÖ **Clean URLs** - No version in URL
‚úÖ **Flexible** - Easy to add metadata in headers

#### Cons

‚ùå **Less visible** - Version not obvious in URL
‚ùå **Harder to test** - Need to set headers manually
‚ùå **Caching complexity** - Need Vary header for proper caching
‚ùå **Documentation complexity** - Harder to explain to developers

#### Implementation Example

```javascript
// Express.js with header versioning
app.get('/users', (req, res) => {
  const version = req.headers['api-version'] || '1';
  
  const users = db.users.findAll();
  
  if (version === '1') {
    // V1 format
    res.json(users.map(u => ({
      id: u.id,
      name: u.name,
      email: u.email
    })));
  } else if (version === '2') {
    // V2 format
    res.json(users.map(u => ({
      id: u.id,
      firstName: u.firstName,
      lastName: u.lastName,
      email: u.email
    })));
  } else {
    res.status(400).json({
      error: 'Invalid API version',
      supportedVersions: ['1', '2']
    });
  }
});

// Middleware to extract version
app.use((req, res, next) => {
  req.apiVersion = req.headers['api-version'] || '1';
  
  // Important: Add Vary header for caching
  res.set('Vary', 'API-Version');
  
  next();
});
```

---

### 3. Content Negotiation (Accept Header)

Version specified in Accept header using vendor MIME types.

```http
GET /users
Accept: application/vnd.myapi.v2+json
```

**Format:**
```
application/vnd.{vendor}.{version}+{format}
```

**Examples:**

```http
Accept: application/vnd.myapi.v1+json
Accept: application/vnd.myapi.v2+json
Accept: application/vnd.myapi.v2+xml
Accept: application/vnd.github.v3+json  (GitHub's approach)
```

#### Pros

‚úÖ **RESTful** - Proper use of content negotiation
‚úÖ **Clean URLs** - Version not in URL
‚úÖ **Format included** - Version and format in one header

#### Cons

‚ùå **Complex** - Harder to understand and implement
‚ùå **Difficult to test** - Need proper Accept headers
‚ùå **Documentation overhead** - Complex to explain
‚ùå **Not widely adopted** - Less familiar to developers

#### Implementation Example

```javascript
app.get('/users', (req, res) => {
  const accept = req.headers['accept'] || 'application/json';
  
  // Parse vendor MIME type
  const versionMatch = accept.match(/application\/vnd\.myapi\.v(\d+)\+json/);
  const version = versionMatch ? versionMatch[1] : '1';
  
  const users = db.users.findAll();
  
  if (version === '1') {
    res.set('Content-Type', 'application/vnd.myapi.v1+json');
    res.json(users.map(u => ({
      id: u.id,
      name: u.name,
      email: u.email
    })));
  } else if (version === '2') {
    res.set('Content-Type', 'application/vnd.myapi.v2+json');
    res.json(users.map(u => ({
      id: u.id,
      firstName: u.firstName,
      lastName: u.lastName,
      email: u.email
    })));
  } else {
    res.status(406).json({
      error: 'Not Acceptable',
      message: 'Unsupported API version',
      supportedVersions: ['v1', 'v2']
    });
  }
  
  // Add Vary header for caching
  res.set('Vary', 'Accept');
});
```

---

### 4. Query Parameter Versioning

Version in query string.

```http
GET /users?version=2
GET /users?api_version=2
GET /users?v=2
```

#### Pros

‚úÖ **Simple** - Easy to understand
‚úÖ **Easy to test** - Just add parameter to URL
‚úÖ **Optional** - Can default to latest or specific version

#### Cons

‚ùå **Not recommended** - Query params should be for filtering, not versioning
‚ùå **Pollutes query space** - Mixes versioning with other parameters
‚ùå **Caching issues** - Query params affect cache keys

#### Implementation Example

```javascript
app.get('/users', (req, res) => {
  const version = req.query.version || req.query.v || '1';
  
  const users = db.users.findAll();
  
  if (version === '1') {
    res.json(users.map(u => ({
      id: u.id,
      name: u.name,
      email: u.email
    })));
  } else if (version === '2') {
    res.json(users.map(u => ({
      id: u.id,
      firstName: u.firstName,
      lastName: u.lastName,
      email: u.email
    })));
  } else {
    res.status(400).json({
      error: 'Invalid version',
      supportedVersions: ['1', '2']
    });
  }
});
```

**Not recommended for production APIs.** Use URI or header versioning instead.

---

## Comparison Matrix

| Strategy | Visibility | REST Compliance | Caching | Testing | Adoption |
|----------|-----------|-----------------|---------|---------|----------|
| URI (path) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Header | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Accept (content negotiation) | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê |
| Query param | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê |

**Recommendation:** **URI versioning** for most APIs (practical and widely adopted)

---

## Semantic Versioning for APIs

### Version Number Format

```
MAJOR.MINOR.PATCH

Example: 2.1.3
         ‚îÇ ‚îÇ ‚îÇ
         ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ PATCH: Bug fixes (backward compatible)
         ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ MINOR: New features (backward compatible)
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MAJOR: Breaking changes
```

### When to Increment

**MAJOR (breaking changes):**
- Removing endpoints or fields
- Changing field types or semantics
- Changing response structure
- Changing authentication mechanism
- Removing support for format

**MINOR (new features, backward compatible):**
- Adding new endpoints
- Adding new optional fields
- Adding new query parameters
- Deprecating (but not removing) features

**PATCH (bug fixes):**
- Fixing bugs in logic
- Performance improvements
- Security patches
- Documentation updates

### API Version Examples

```http
# Major version in URI
/v1/users  (version 1.x.x)
/v2/users  (version 2.x.x)

# Full semantic version in header
API-Version: 2.1.3

# Response header showing full version
X-API-Version: 2.1.3
X-API-Build: 2024-01-13-build-456
```

---

## Migration Strategies

### Strategy 1: Running Multiple Versions Simultaneously

Run old and new versions side-by-side.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  API Gateway / Load Balancer        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  V1 API   ‚îÇ   ‚îÇ  V2 API   ‚îÇ
‚îÇ  Servers  ‚îÇ   ‚îÇ  Servers  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  Database   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation:**

```javascript
// Separate routers for each version
const v1Router = require('./routes/v1');
const v2Router = require('./routes/v2');

app.use('/v1', v1Router);
app.use('/v2', v2Router);

// Or separate apps
const v1App = require('./apps/v1');
const v2App = require('./apps/v2');

// Route by subdomain
app.use((req, res, next) => {
  if (req.hostname === 'api-v1.example.com') {
    v1App(req, res, next);
  } else if (req.hostname === 'api-v2.example.com') {
    v2App(req, res, next);
  } else {
    res.status(400).json({ error: 'Invalid API hostname' });
  }
});
```

**Pros:**
- ‚úÖ Clean separation
- ‚úÖ Easy to maintain both versions
- ‚úÖ Can optimize each version independently

**Cons:**
- ‚ùå More infrastructure
- ‚ùå Code duplication
- ‚ùå Higher operational costs

---

### Strategy 2: Single Codebase with Adapters

Transform data between versions using adapters.

```javascript
// Shared business logic
class UserService {
  async getUser(id) {
    return db.users.findById(id);
  }
}

// V1 adapter
class UserV1Adapter {
  static toResponse(user) {
    return {
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,  // Combine names
      email: user.email
    };
  }
  
  static fromRequest(data) {
    const [firstName, ...lastNameParts] = data.name.split(' ');
    return {
      firstName,
      lastName: lastNameParts.join(' ')
    };
  }
}

// V2 adapter
class UserV2Adapter {
  static toResponse(user) {
    return {
      id: user.id,
      firstName: user.firstName,  // Separate names
      lastName: user.lastName,
      email: user.email
    };
  }
  
  static fromRequest(data) {
    return {
      firstName: data.firstName,
      lastName: data.lastName
    };
  }
}

// Routes
app.get('/v1/users/:id', async (req, res) => {
  const user = await userService.getUser(req.params.id);
  res.json(UserV1Adapter.toResponse(user));
});

app.get('/v2/users/:id', async (req, res) => {
  const user = await userService.getUser(req.params.id);
  res.json(UserV2Adapter.toResponse(user));
});
```

**Pros:**
- ‚úÖ Single codebase
- ‚úÖ Shared business logic
- ‚úÖ Less duplication

**Cons:**
- ‚ùå Can become complex with many versions
- ‚ùå All versions deployed together

---

### Strategy 3: Feature Flags

Use feature flags to toggle new features.

```javascript
const featureFlags = {
  splitNames: (version) => version >= 2,
  includeMetadata: (version) => version >= 2,
  newSearchAlgorithm: (version) => version >= 3
};

app.get('/users/:id', async (req, res) => {
  const version = getVersion(req);
  const user = await userService.getUser(req.params.id);
  
  const response = {
    id: user.id,
    email: user.email
  };
  
  // Toggle features based on version
  if (featureFlags.splitNames(version)) {
    response.firstName = user.firstName;
    response.lastName = user.lastName;
  } else {
    response.name = `${user.firstName} ${user.lastName}`;
  }
  
  if (featureFlags.includeMetadata(version)) {
    response.metadata = {
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };
  }
  
  res.json(response);
});
```

**Pros:**
- ‚úÖ Single codebase
- ‚úÖ Gradual rollout
- ‚úÖ Easy to toggle features

**Cons:**
- ‚ùå Code becomes cluttered with conditionals
- ‚ùå Hard to remove old code
- ‚ùå Testing complexity

---

## Deprecation and Sunset

### Deprecation Process

```
Phase 1: Announce
‚Üì (3-6 months)
Phase 2: Deprecate
‚Üì (6-12 months)
Phase 3: Sunset
```

### Phase 1: Announce New Version

**Documentation:**
```markdown
# API Changelog

## Version 2.0.0 - Released 2026-01-15

### Breaking Changes
- User `name` field split into `firstName` and `lastName`
- Date format changed to ISO 8601

### Migration Guide
See [Migration from v1 to v2](./migration-v1-to-v2.md)

### Timeline
- V2 released: January 15, 2026
- V1 deprecated: July 15, 2026
- V1 sunset: January 15, 2027
```

**Email notification:**
```
Subject: New API Version 2.0 Released

Dear API Users,

We're excited to announce version 2.0 of our API with new features
and improvements.

What's New:
- More flexible user name structure
- Improved data formats
- Better error messages

Migration Timeline:
- V2 Available: January 15, 2026 (today!)
- V1 Deprecated: July 15, 2026 (6 months)
- V1 End of Life: January 15, 2027 (12 months)

Migration Guide:
https://api.example.com/docs/migration-v1-to-v2

Questions? Contact support@example.com
```

### Phase 2: Mark as Deprecated

**Deprecation Headers:**

```http
# Request to deprecated version
GET /v1/users
API-Version: 1

# Response includes deprecation warning
HTTP/1.1 200 OK
Deprecation: true
Sunset: Mon, 15 Jan 2027 00:00:00 GMT
Link: <https://api.example.com/docs/migration-v1-to-v2>; rel="deprecation"
Warning: 299 - "API v1 is deprecated. Migrate to v2 by 2027-01-15"
X-API-Deprecated: true
X-API-Deprecation-Date: 2026-07-15
X-API-Sunset-Date: 2027-01-15
X-API-Migration-Guide: https://api.example.com/docs/migration-v1-to-v2

{
  "data": {...},
  "_deprecated": {
    "message": "API v1 is deprecated and will be retired on 2027-01-15",
    "sunsetDate": "2027-01-15T00:00:00Z",
    "migrationGuide": "https://api.example.com/docs/migration-v1-to-v2",
    "currentVersion": "v1",
    "latestVersion": "v2"
  }
}
```

**Response body warning:**

```json
{
  "data": {
    "id": 42,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "warnings": [
    {
      "code": "DEPRECATED_VERSION",
      "message": "You are using API v1 which will be retired on 2027-01-15",
      "severity": "warning",
      "links": {
        "migrationGuide": "https://api.example.com/docs/migration-v1-to-v2",
        "announcement": "https://api.example.com/blog/v2-release"
      }
    }
  ]
}
```

**Dashboard notification:**

```javascript
// Track which clients use deprecated versions
app.use('/v1', (req, res, next) => {
  // Log usage for monitoring
  logger.warn('Deprecated API v1 used', {
    client: req.headers['user-agent'],
    apiKey: req.headers['x-api-key'],
    endpoint: req.path,
    timestamp: new Date()
  });
  
  // Track in analytics
  analytics.track('deprecated_api_usage', {
    version: 'v1',
    endpoint: req.path,
    apiKey: req.headers['x-api-key']
  });
  
  next();
});

// Send email reminders to clients still using v1
async function notifyDeprecatedApiUsers() {
  const users = await db.query(`
    SELECT DISTINCT user_email, api_key
    FROM api_usage_logs
    WHERE version = 'v1'
      AND timestamp > NOW() - INTERVAL 30 DAYS
  `);
  
  for (const user of users) {
    await sendEmail(user.email, {
      subject: 'Action Required: Migrate to API v2',
      template: 'api-deprecation-reminder',
      data: {
        sunsetDate: '2027-01-15',
        daysRemaining: calculateDaysRemaining(),
        migrationGuide: 'https://api.example.com/docs/migration-v1-to-v2'
      }
    });
  }
}

// Run weekly
schedule.every('1 week').do(notifyDeprecatedApiUsers);
```

### Phase 3: Sunset (Retirement)

**Gradual sunset:**

```javascript
// Reduce rate limits for deprecated version
app.use('/v1', rateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 10  // Reduced from 100
}));

// Add delay to deprecated endpoints (soft sunset)
app.use('/v1', (req, res, next) => {
  const daysUntilSunset = calculateDaysUntilSunset('2027-01-15');
  
  if (daysUntilSunset < 30) {
    // Add 500ms delay in last 30 days
    setTimeout(next, 500);
  } else if (daysUntilSunset < 60) {
    // Add 200ms delay in last 60 days
    setTimeout(next, 200);
  } else {
    next();
  }
});

// Final sunset - return 410 Gone
app.use('/v1', (req, res) => {
  res.status(410).json({
    error: 'Gone',
    message: 'API v1 has been retired as of 2027-01-15',
    sunset: true,
    retiredDate: '2027-01-15T00:00:00Z',
    currentVersion: 'v2',
    migrationGuide: 'https://api.example.com/docs/migration-v1-to-v2',
    links: {
      latestApi: 'https://api.example.com/v2'
    }
  });
});
```

---

## Migration Guide Structure

### Comprehensive Migration Documentation

```markdown
# Migration Guide: API v1 to v2

## Overview

API v2 introduces breaking changes to improve flexibility and consistency.
This guide will help you migrate from v1 to v2.

## Timeline

- **v2 Released:** January 15, 2026
- **v1 Deprecated:** July 15, 2026 (6 months notice)
- **v1 Sunset:** January 15, 2027 (12 months notice)

## Breaking Changes

### 1. User Name Field Split

**v1 Response:**
```json
{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com"
}
```

**v2 Response:**
```json
{
  "id": 42,
  "firstName": "John",
  "lastName": "Doe",
  "email": "john@example.com"
}
```

**Migration:**
```javascript
// Before (v1)
const fullName = user.name;

// After (v2)
const fullName = `${user.firstName} ${user.lastName}`;
```

### 2. Date Format Change

**v1:** Custom format `"2026-01-15 10:00:00"`
**v2:** ISO 8601 `"2026-01-15T10:00:00Z"`

**Migration:**
```javascript
// Before (v1)
const date = new Date(user.createdAt.replace(' ', 'T'));

// After (v2)
const date = new Date(user.createdAt);  // Standard ISO 8601
```

### 3. Endpoint Changes

| v1 Endpoint | v2 Endpoint | Notes |
|-------------|-------------|-------|
| `GET /user-profile` | `GET /profile` | Renamed |
| `POST /user` | `POST /users` | Made consistent |
| `GET /search` | `POST /search` | Method changed for complex queries |

## New Features in v2

### Pagination
v2 adds cursor-based pagination for better performance.

```javascript
// v1 (offset-based)
GET /users?page=2&limit=20

// v2 (cursor-based)
GET /users?cursor=xyz&limit=20
```

### Field Selection
v2 supports sparse fieldsets.

```javascript
GET /users?fields=id,firstName,lastName,email
```

## Code Examples

### JavaScript/TypeScript

```typescript
// v1 Client
class ApiClientV1 {
  async getUser(id: number) {
    const response = await fetch(`https://api.example.com/v1/users/${id}`);
    const user = await response.json();
    return {
      id: user.id,
      fullName: user.name,
      email: user.email
    };
  }
}

// v2 Client
class ApiClientV2 {
  async getUser(id: number) {
    const response = await fetch(`https://api.example.com/v2/users/${id}`);
    const user = await response.json();
    return {
      id: user.id,
      fullName: `${user.firstName} ${user.lastName}`,
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email
    };
  }
}
```

### Python

```python
# v1 Client
class ApiClientV1:
    def get_user(self, user_id):
        response = requests.get(f'https://api.example.com/v1/users/{user_id}')
        user = response.json()
        return {
            'id': user['id'],
            'full_name': user['name'],
            'email': user['email']
        }

# v2 Client
class ApiClientV2:
    def get_user(self, user_id):
        response = requests.get(f'https://api.example.com/v2/users/{user_id}')
        user = response.json()
        return {
            'id': user['id'],
            'full_name': f"{user['firstName']} {user['lastName']}",
            'first_name': user['firstName'],
            'last_name': user['lastName'],
            'email': user['email']
        }
```

## Testing Your Migration

### 1. Test in Staging
Use our staging environment: `https://api-staging.example.com/v2`

### 2. Gradual Rollout
Migrate endpoints one at a time:

```javascript
// Progressive migration
const API_V1 = 'https://api.example.com/v1';
const API_V2 = 'https://api.example.com/v2';

// Migrate users endpoint first
const usersApi = API_V2;  // ‚Üê Change this
const ordersApi = API_V1;  // Still on v1

async function getUser(id) {
  return fetch(`${usersApi}/users/${id}`);
}

async function getOrders(id) {
  return fetch(`${ordersApi}/orders/${id}`);
}
```

### 3. Monitor Errors
Track errors during migration:

```javascript
try {
  const user = await api.v2.getUser(42);
} catch (error) {
  // Log error
  logger.error('v2 API error', { error, endpoint: '/users/42' });
  
  // Fallback to v1 temporarily
  const user = await api.v1.getUser(42);
  
  // Alert team
  alerting.notify('v2 migration issue', { error });
}
```

## Support

- **Documentation:** https://api.example.com/docs/v2
- **Migration Support:** support@example.com
- **Slack Channel:** #api-v2-migration
- **Office Hours:** Tuesdays 2-3pm PST

## FAQ

**Q: Can I use both v1 and v2 simultaneously?**
A: Yes! Mix and match as you migrate.

**Q: What happens if I don't migrate by the sunset date?**
A: v1 will return 410 Gone errors. Plan your migration now!

**Q: Can the sunset date be extended?**
A: Only in exceptional circumstances. Contact us early if needed.

**Q: How do I test v2 without affecting production?**
A: Use our staging environment or feature flags.
```

---

## Client Notification Strategies

### 1. In-Response Warnings

```javascript
function addDeprecationWarning(req, res, next) {
  const version = getApiVersion(req);
  
  if (version === 'v1') {
    // Add to response body
    const originalJson = res.json.bind(res);
    res.json = function(data) {
      return originalJson({
        ...data,
        _meta: {
          apiVersion: 'v1',
          deprecated: true,
          sunsetDate: '2027-01-15T00:00:00Z',
          message: 'Please upgrade to v2. See https://api.example.com/docs/migration',
          daysRemaining: calculateDaysRemaining('2027-01-15')
        }
      });
    };
  }
  
  next();
}

app.use('/v1', addDeprecationWarning);
```

### 2. Email Campaigns

```javascript
// Weekly digest of deprecated API usage
async function sendWeeklyDigest() {
  const usage = await db.query(`
    SELECT 
      u.email,
      u.company_name,
      COUNT(*) as requests,
      array_agg(DISTINCT endpoint) as endpoints
    FROM api_usage_logs aul
    JOIN users u ON u.api_key = aul.api_key
    WHERE aul.version = 'v1'
      AND aul.timestamp > NOW() - INTERVAL 7 DAYS
    GROUP BY u.email, u.company_name
  `);
  
  for (const user of usage) {
    await sendEmail(user.email, {
      subject: `Your app uses deprecated API v1 (${user.requests} requests last week)`,
      template: 'weekly-deprecation-digest',
      data: {
        companyName: user.company_name,
        requestCount: user.requests,
        endpoints: user.endpoints,
        sunsetDate: '2027-01-15',
        daysRemaining: calculateDaysRemaining(),
        migrationGuide: 'https://api.example.com/docs/migration-v1-to-v2',
        topEndpoints: user.endpoints.slice(0, 5)
      }
    });
  }
}
```

### 3. Dashboard Indicators

```javascript
// API Dashboard showing version usage
GET /api/dashboard

Response:
{
  "apiKey": "key-abc-123",
  "usage": {
    "v1": {
      "requests": 15000,
      "percentage": 30,
      "status": "deprecated",
      "warning": "v1 will be retired in 45 days"
    },
    "v2": {
      "requests": 35000,
      "percentage": 70,
      "status": "current"
    }
  },
  "recommendations": [
    {
      "type": "migration",
      "severity": "high",
      "message": "Migrate remaining 30% of requests from v1 to v2",
      "endpoints": [
        "/v1/users (8000 requests)",
        "/v1/orders (5000 requests)"
      ]
    }
  ]
}
```

### 4. Webhook Notifications

```javascript
// Send webhook when deprecated version usage exceeds threshold
async function checkDeprecatedUsage() {
  const threshold = 1000; // requests per day
  
  const usage = await db.query(`
    SELECT api_key, COUNT(*) as requests
    FROM api_usage_logs
    WHERE version = 'v1'
      AND timestamp > NOW() - INTERVAL 1 DAY
    GROUP BY api_key
    HAVING COUNT(*) > ${threshold}
  `);
  
  for (const record of usage) {
    const webhookUrl = await getWebhookUrl(record.api_key);
    
    if (webhookUrl) {
      await fetch(webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          event: 'api.deprecation.warning',
          apiKey: record.api_key,
          version: 'v1',
          requests: record.requests,
          threshold: threshold,
          sunsetDate: '2027-01-15',
          message: 'High usage of deprecated API detected'
        })
      });
    }
  }
}
```

### 5. Status Page Announcements

```markdown
# API Status Page

## Upcoming Changes

### API v1 Deprecation
**Posted:** January 15, 2026
**Impact:** All API v1 users
**Action Required:** Yes

API v1 will be retired on January 15, 2027 (12 months from now).
Please migrate to v2 before this date.

**Timeline:**
- Now: v2 available, v1 still supported
- July 15, 2026: v1 officially deprecated
- January 15, 2027: v1 sunset (will return 410 Gone)

**Resources:**
- [Migration Guide](https://api.example.com/docs/migration-v1-to-v2)
- [V2 Documentation](https://api.example.com/docs/v2)
- [Support](mailto:support@example.com)
```

---

## Backward Compatibility Strategies

### Strategy 1: Additive Changes Only

Make changes that don't break existing clients.

```javascript
// ‚úÖ Backward compatible: Add new field
// v1 response
{
  "id": 42,
  "name": "John Doe"
}

// v1.1 response (added field)
{
  "id": 42,
  "name": "John Doe",
  "avatar": "https://..."  // New field, old clients ignore it
}

// ‚ùå Breaking change: Remove field
// v2 response
{
  "id": 42,
  "firstName": "John",
  "lastName": "Doe"
  // "name" removed - breaks old clients!
}
```

### Strategy 2: Dual-Write Pattern

Write to both old and new fields.

```javascript
// Database has both name and firstName/lastName
app.post('/v1/users', (req, res) => {
  const user = {
    name: req.body.name,
    // Also store split names for v2
    firstName: req.body.name.split(' ')[0],
    lastName: req.body.name.split(' ').slice(1).join(' ')
  };
  
  db.users.create(user);
  
  // Return v1 format
  res.json({
    id: user.id,
    name: user.name
  });
});

app.post('/v2/users', (req, res) => {
  const user = {
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    // Also store combined name for v1
    name: `${req.body.firstName} ${req.body.lastName}`
  };
  
  db.users.create(user);
  
  // Return v2 format
  res.json({
    id: user.id,
    firstName: user.firstName,
    lastName: user.lastName
  });
});
```

### Strategy 3: Expand-Contract Pattern

1. **Expand:** Add new fields alongside old fields
2. **Migrate:** Update clients to use new fields
3. **Contract:** Remove old fields

```javascript
// Phase 1: Expand (both fields present)
{
  "id": 42,
  "name": "John Doe",        // Old field
  "firstName": "John",        // New field
  "lastName": "Doe"           // New field
}

// Phase 2: Migrate clients
// (6-12 months)

// Phase 3: Contract (remove old field in new major version)
{
  "id": 42,
  "firstName": "John",
  "lastName": "Doe"
  // "name" removed
}
```

---

## Version Discovery

Let clients discover which versions are available.

```javascript
// GET / or GET /versions
app.get('/', (req, res) => {
  res.json({
    name: 'MyAPI',
    versions: [
      {
        version: 'v1',
        status: 'deprecated',
        released: '2024-01-15',
        deprecated: '2026-07-15',
        sunset: '2027-01-15',
        documentation: 'https://api.example.com/docs/v1'
      },
      {
        version: 'v2',
        status: 'current',
        released: '2026-01-15',
        documentation: 'https://api.example.com/docs/v2',
        features: ['cursor-pagination', 'field-selection', 'better-errors']
      },
      {
        version: 'v3',
        status: 'beta',
        released: null,
        documentation: 'https://api.example.com/docs/v3-beta',
        features: ['graphql-support', 'webhooks', 'batch-operations']
      }
    ],
    currentVersion: 'v2',
    latestVersion: 'v2',
    links: {
      documentation: 'https://api.example.com/docs',
      statusPage: 'https://status.example.com',
      migration: 'https://api.example.com/docs/migration'
    }
  });
});

// OPTIONS on versioned endpoint
app.options('/v2/users', (req, res) => {
  res.set({
    'API-Version': 'v2',
    'API-Version-Status': 'current',
    'API-Supported-Versions': 'v1, v2',
    'API-Deprecated-Versions': 'v1',
    'Link': '<https://api.example.com/docs/v2>; rel="documentation"'
  });
  res.status(200).end();
});
```

---

## Best Practices

### 1. Use Major Versions Only in URI

```http
‚úÖ Good:
/v1/users
/v2/users
/v3/users

‚ùå Bad:
/v1.2.3/users  (too granular)
/v1.5/users    (confusing)
/version-2/users  (verbose)
```

### 2. Support Versions for At Least 12 Months

```
Release v2: January 2026
Deprecate v1: July 2026 (6 months)
Sunset v1: January 2027 (12 months total)
```

### 3. Document Everything

- Release notes
- Migration guides
- Breaking changes
- Timeline
- Code examples

### 4. Provide Migration Tools

```javascript
// Migration validation tool
GET /api/v1/validate-migration

Response:
{
  "compatible": false,
  "issues": [
    {
      "endpoint": "GET /users/:id",
      "field": "name",
      "issue": "Field 'name' removed in v2",
      "migration": "Use 'firstName' and 'lastName' instead",
      "example": {
        "v1": {"name": "John Doe"},
        "v2": {"firstName": "John", "lastName": "Doe"}
      }
    }
  ],
  "migrationGuide": "https://api.example.com/docs/migration"
}
```

### 5. Monitor Version Usage

```javascript
// Analytics dashboard
{
  "totalRequests": 1000000,
  "byVersion": {
    "v1": {
      "requests": 300000,
      "percentage": 30,
      "uniqueClients": 150,
      "trend": "declining"
    },
    "v2": {
      "requests": 700000,
      "percentage": 70,
      "uniqueClients": 450,
      "trend": "growing"
    }
  },
  "migrationProgress": {
    "completed": 75,
    "inProgress": 15,
    "notStarted": 10
  }
}
```

---

## Common Mistakes

### Mistake 1: No Migration Notice

```javascript
// ‚ùå Bad: Surprise breaking changes
// No warning, just shut down v1 immediately

// ‚úÖ Good: 6-12 months notice
// Announce, deprecate, then sunset
```

### Mistake 2: Vague Documentation

```markdown
‚ùå Bad:
"The user endpoint has changed. Please update your code."

‚úÖ Good:
"User name field split into firstName and lastName.

Before (v1):
{
  "name": "John Doe"
}

After (v2):
{
  "firstName": "John",
  "lastName": "Doe"
}

Migration:
const fullName = `${user.firstName} ${user.lastName}`;
"
```

### Mistake 3: No Backward Compatibility Period

```javascript
// ‚ùå Bad: Force immediate migration
// v2 released, v1 removed same day

// ‚úÖ Good: Run both versions simultaneously
// v2 released, v1 supported for 12 months
```

### Mistake 4: Unclear Version Selection

```http
‚ùå Bad: Magic version selection
GET /users  (which version?)

‚úÖ Good: Explicit version
GET /v2/users  (clear version)
```

---

## Summary

### Versioning Strategy Recommendations

**For most APIs:**
- Use **URI versioning** (`/v1/users`) - most common and practical
- **Major versions only** in URI (v1, v2, v3)
- **12-month deprecation period** minimum
- **Clear migration guides** with code examples

### Deprecation Timeline Template

```
0 months: Announce v2, v1 still supported
6 months: Mark v1 as deprecated
9 months: Send migration reminders
11 months: Final warnings
12 months: Sunset v1 (return 410 Gone)
```

### Communication Checklist

- ‚úÖ Release announcement (blog, email)
- ‚úÖ Deprecation headers in responses
- ‚úÖ Dashboard warnings
- ‚úÖ Email campaigns (monthly)
- ‚úÖ Migration documentation
- ‚úÖ Code examples in multiple languages
- ‚úÖ Staging environment for testing
- ‚úÖ Support channels for help
- ‚úÖ Status page updates
- ‚úÖ Sunset countdown

### Key Principles

1. **Never surprise users** - Give ample notice
2. **Make migration easy** - Provide guides and examples
3. **Support overlap period** - Run versions simultaneously
4. **Monitor adoption** - Track who still uses old versions
5. **Be flexible** - Extend deadlines if needed (rarely)

---

## Next Steps

Now that you understand API versioning, explore:
- Error handling and consistent error formats
- API documentation with OpenAPI/Swagger
- Deprecation automation tools
- Client SDK generation
- API governance and policies
- Breaking change analysis tools
