# 5.2 Authorization

## Overview

Authorization determines what an authenticated user is allowed to do. While authentication verifies identity ("Who are you?"), authorization determines permissions ("What are you allowed to do?").

**Key Principle**: Authentication comes first, then authorization.

## Core Concepts

### Authentication vs Authorization

| Aspect | Authentication | Authorization |
|--------|---------------|---------------|
| Question | "Who are you?" | "What can you do?" |
| Process | Verifies identity | Validates permissions |
| Methods | Passwords, tokens, biometrics | Roles, scopes, policies |
| Result | User identity established | Access granted or denied |
| Example | Login with username/password | Admin can delete users |

### Authorization Models

1. **Access Control Lists (ACL)** - Permissions attached to resources
2. **Role-Based Access Control (RBAC)** - Permissions attached to roles
3. **Attribute-Based Access Control (ABAC)** - Permissions based on attributes
4. **Policy-Based Access Control (PBAC)** - Permissions defined by policies

## Role-Based Access Control (RBAC)

### What is RBAC?

RBAC assigns permissions to roles rather than individual users. Users are then assigned one or more roles.

**Hierarchy**:
```
User → Role(s) → Permission(s) → Resource(s)
```

### Common Roles

```
- Super Admin / Root
  - Full system access
  - User management
  - System configuration

- Admin
  - Organization-level access
  - User management within org
  - Most CRUD operations

- Manager / Editor
  - Create and modify resources
  - Limited delete permissions
  - Team management

- User / Member
  - Read access
  - Create own resources
  - Modify own resources

- Guest / Viewer
  - Read-only access
  - Public resources only
```

### RBAC Implementation Example

**Database Schema**:
```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255)
);

-- Roles table
CREATE TABLE roles (
    id UUID PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT
);

-- User-Role association (many-to-many)
CREATE TABLE user_roles (
    user_id UUID REFERENCES users(id),
    role_id UUID REFERENCES roles(id),
    PRIMARY KEY (user_id, role_id)
);

-- Permissions table
CREATE TABLE permissions (
    id UUID PRIMARY KEY,
    resource VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT
);

-- Role-Permission association (many-to-many)
CREATE TABLE role_permissions (
    role_id UUID REFERENCES roles(id),
    permission_id UUID REFERENCES permissions(id),
    PRIMARY KEY (role_id, permission_id)
);
```

**API Response Examples**:

```json
// GET /api/v1/users/me
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "email": "john@example.com",
  "name": "John Doe",
  "roles": [
    {
      "id": "role-1",
      "name": "admin",
      "permissions": [
        "users:read",
        "users:write",
        "users:delete",
        "posts:read",
        "posts:write"
      ]
    }
  ]
}
```

### Checking Authorization

**Request Header**:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Server-Side Check**:
```javascript
// Middleware example (Node.js/Express)
function requireRole(roles) {
  return (req, res, next) => {
    const userRoles = req.user.roles;
    
    const hasRole = roles.some(role => 
      userRoles.includes(role)
    );
    
    if (!hasRole) {
      return res.status(403).json({
        error: 'Forbidden',
        message: 'Insufficient permissions'
      });
    }
    
    next();
  };
}

// Usage in route
app.delete('/api/users/:id', 
  authenticate,
  requireRole(['admin', 'super_admin']),
  deleteUser
);
```

## Permission Scopes

### What are Scopes?

Scopes define granular permissions for API access. They're commonly used with OAuth 2.0 and JWT tokens.

**Format**: Usually `resource:action` or `resource.action`

### Common Scope Patterns

```
users:read          - Read user information
users:write         - Create/update users
users:delete        - Delete users
users:*             - All user operations

posts:read          - Read posts
posts:write         - Create/update posts
posts:delete        - Delete posts

admin:*             - All admin operations
```

### Scope Implementation

**JWT Token with Scopes**:
```json
{
  "sub": "user-123",
  "email": "john@example.com",
  "scope": "users:read users:write posts:read posts:write",
  "iat": 1516239022,
  "exp": 1516242622
}
```

**OAuth 2.0 Authorization Request**:
```
GET /oauth/authorize?
  client_id=abc123&
  redirect_uri=https://app.example.com/callback&
  scope=users:read posts:read posts:write&
  response_type=code
```

**API Response with Available Scopes**:
```json
// GET /api/v1/auth/token
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "users:read users:write posts:read posts:write",
  "granted_scopes": [
    "users:read",
    "users:write", 
    "posts:read",
    "posts:write"
  ]
}
```

### Scope Checking Example

```python
# Python Flask example
from functools import wraps
from flask import request, jsonify

def require_scope(*required_scopes):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = decode_token(request.headers.get('Authorization'))
            user_scopes = token.get('scope', '').split()
            
            has_scope = any(scope in user_scopes for scope in required_scopes)
            
            if not has_scope:
                return jsonify({
                    'error': 'Insufficient scope',
                    'required': list(required_scopes),
                    'provided': user_scopes
                }), 403
                
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Usage
@app.route('/api/users/<user_id>', methods=['DELETE'])
@require_scope('users:delete', 'admin:*')
def delete_user(user_id):
    # Delete user logic
    pass
```

## Resource-Level Permissions

### What are Resource-Level Permissions?

Resource-level permissions control access to specific instances of resources, not just resource types.

**Examples**:
- User can edit their own profile, but not others'
- Document owner can delete it, collaborators can only edit
- Team members can view team resources, outsiders cannot

### Ownership-Based Authorization

**Pattern**: User owns a resource and has full control over it.

```javascript
// Check if user owns the resource
async function checkOwnership(req, res, next) {
  const resourceId = req.params.id;
  const userId = req.user.id;
  
  const resource = await db.findById(resourceId);
  
  if (!resource) {
    return res.status(404).json({ error: 'Resource not found' });
  }
  
  if (resource.userId !== userId) {
    return res.status(403).json({ 
      error: 'Forbidden',
      message: 'You can only modify your own resources'
    });
  }
  
  req.resource = resource;
  next();
}

// Usage
app.put('/api/posts/:id',
  authenticate,
  checkOwnership,
  updatePost
);
```

### Organization/Team-Based Authorization

**Pattern**: Resources belong to an organization, only org members can access.

```javascript
async function checkOrganizationMembership(req, res, next) {
  const resourceId = req.params.id;
  const userId = req.user.id;
  
  const resource = await db.findResourceWithOrg(resourceId);
  
  if (!resource) {
    return res.status(404).json({ error: 'Resource not found' });
  }
  
  const isMember = await db.isOrganizationMember(
    userId, 
    resource.organizationId
  );
  
  if (!isMember) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'You must be an organization member to access this resource'
    });
  }
  
  req.resource = resource;
  next();
}
```

### Hierarchical Permissions

Resources may have hierarchical relationships affecting permissions.

```javascript
// Example: Folder > Subfolder > File
async function checkHierarchicalPermission(req, res, next) {
  const fileId = req.params.id;
  const userId = req.user.id;
  
  // Get file and all parent folders
  const hierarchy = await db.getResourceHierarchy(fileId);
  
  // Check if user has permission at any level
  for (const resource of hierarchy) {
    const permission = await db.getUserPermission(userId, resource.id);
    
    if (permission && permission.includes('read')) {
      req.resource = hierarchy[0]; // The file
      return next();
    }
  }
  
  return res.status(403).json({
    error: 'Forbidden',
    message: 'No permission to access this file'
  });
}
```

## Advanced Authorization Patterns

### Attribute-Based Access Control (ABAC)

Authorization based on attributes of user, resource, and environment.

```json
// Policy example
{
  "policy": "document-access",
  "rules": [
    {
      "effect": "allow",
      "conditions": {
        "user.department": "engineering",
        "resource.classification": "internal",
        "environment.time": "business_hours"
      }
    }
  ]
}
```

### Policy-Based Authorization

Define complex rules as policies.

```javascript
// Using a policy engine
const policy = {
  resource: 'document',
  action: 'delete',
  conditions: [
    { user: { role: 'admin' } },
    { 
      and: [
        { user: { id: '${resource.ownerId}' } },
        { resource: { status: 'draft' } }
      ]
    }
  ]
};

function evaluatePolicy(user, resource, action) {
  // Policy evaluation logic
  return policyEngine.evaluate(policy, { user, resource, action });
}
```

### Time-Based Authorization

Grant temporary access to resources.

```javascript
async function checkTemporaryAccess(req, res, next) {
  const resourceId = req.params.id;
  const userId = req.user.id;
  
  const access = await db.getTemporaryAccess(userId, resourceId);
  
  if (!access) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'No access granted'
    });
  }
  
  if (new Date() > access.expiresAt) {
    return res.status(403).json({
      error: 'Forbidden',
      message: 'Access has expired'
    });
  }
  
  next();
}
```

## Authorization Responses

### Success Response (200/204)

```json
// Resource successfully accessed/modified
{
  "id": "post-123",
  "title": "My Post",
  "content": "...",
  "permissions": {
    "canEdit": true,
    "canDelete": true,
    "canShare": true
  }
}
```

### Forbidden (403)

```json
{
  "error": "Forbidden",
  "message": "You don't have permission to perform this action",
  "code": "INSUFFICIENT_PERMISSIONS",
  "required_permissions": ["users:delete"],
  "user_permissions": ["users:read", "users:write"]
}
```

### Not Found vs Forbidden

**Security consideration**: Don't reveal existence of resources user can't access.

```javascript
// Bad: Reveals resource exists
if (!resource) {
  return res.status(404).json({ error: 'Not found' });
}
if (!hasPermission) {
  return res.status(403).json({ error: 'Forbidden' });
}

// Good: Consistent 404 for unauthorized access
if (!resource || !hasPermission) {
  return res.status(404).json({ error: 'Not found' });
}
```

## Best Practices

### 1. Principle of Least Privilege

Grant minimum permissions necessary for a task.

```javascript
// Bad: Too broad
const adminRole = {
  permissions: ['*:*']  // Everything!
};

// Good: Specific permissions
const adminRole = {
  permissions: [
    'users:read',
    'users:write',
    'users:delete',
    'posts:read',
    'posts:write',
    'posts:delete',
    'settings:write'
  ]
};
```

### 2. Deny by Default

Require explicit permission grants rather than denying specific actions.

```javascript
// Default: no access
function hasPermission(user, resource, action) {
  // Must find explicit permission grant
  return user.permissions.some(p => 
    p.resource === resource && p.action === action
  );
}
```

### 3. Check Authorization on Every Request

Never assume authorization based on previous requests.

```javascript
// Bad: Checking once in session
if (req.session.isAdmin) {
  // Perform admin action
}

// Good: Check on every request
const user = await getCurrentUser(req);
if (await hasRole(user, 'admin')) {
  // Perform admin action
}
```

### 4. Include Permissions in Responses

Help clients know what actions are available.

```json
{
  "id": "doc-123",
  "title": "Project Plan",
  "content": "...",
  "_permissions": {
    "read": true,
    "write": true,
    "delete": false,
    "share": true
  }
}
```

### 5. Audit Authorization Decisions

Log all authorization checks, especially denials.

```javascript
function checkPermission(user, resource, action) {
  const hasPermission = evaluatePermission(user, resource, action);
  
  auditLog.record({
    timestamp: new Date(),
    userId: user.id,
    resource: resource,
    action: action,
    granted: hasPermission,
    reason: hasPermission ? 'permission_granted' : 'permission_denied'
  });
  
  return hasPermission;
}
```

### 6. Centralize Authorization Logic

Use middleware/decorators for consistent checks.

```javascript
// Centralized authorization middleware
function authorize(options) {
  return async (req, res, next) => {
    const authorized = await authorizationService.check({
      user: req.user,
      resource: options.resource,
      action: options.action,
      resourceId: req.params.id
    });
    
    if (!authorized) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    
    next();
  };
}

// Usage across routes
app.get('/api/posts/:id', 
  authenticate,
  authorize({ resource: 'posts', action: 'read' }),
  getPost
);

app.delete('/api/posts/:id',
  authenticate, 
  authorize({ resource: 'posts', action: 'delete' }),
  deletePost
);
```

### 7. Separate Public and Private Resources

Clear distinction between public and authenticated endpoints.

```javascript
// Public routes (no auth)
app.get('/api/public/posts', getPublicPosts);

// Authenticated routes
app.use('/api/private', authenticate);
app.get('/api/private/posts', authorize('posts:read'), getPosts);
```

### 8. Handle Permission Changes Gracefully

Invalidate tokens/sessions when permissions change.

```javascript
// When user role changes
async function updateUserRole(userId, newRole) {
  await db.updateUserRole(userId, newRole);
  
  // Invalidate existing sessions/tokens
  await sessionStore.invalidateUserSessions(userId);
  await tokenStore.revokeUserTokens(userId);
  
  // Notify user
  await notificationService.send(userId, {
    message: 'Your permissions have been updated. Please log in again.'
  });
}
```

## Common Pitfalls

### 1. Client-Side Authorization Only

**Problem**: Relying on hiding UI elements without server-side checks.

```javascript
// Bad: Only hiding button in UI
if (!user.isAdmin) {
  hideDeleteButton();
}

// Good: Server enforces authorization
app.delete('/api/users/:id', authenticate, requireAdmin, deleteUser);
```

### 2. Insecure Direct Object References

**Problem**: Not checking if user can access requested resource ID.

```javascript
// Bad: Direct access without check
app.get('/api/documents/:id', async (req, res) => {
  const doc = await db.getDocument(req.params.id);
  res.json(doc); // Anyone can access any document!
});

// Good: Check ownership/permission
app.get('/api/documents/:id', async (req, res) => {
  const doc = await db.getDocument(req.params.id);
  
  if (doc.userId !== req.user.id && !req.user.isAdmin) {
    return res.status(404).json({ error: 'Not found' });
  }
  
  res.json(doc);
});
```

### 3. Role/Permission Proliferation

**Problem**: Too many specific roles that are hard to manage.

```javascript
// Bad: Too many specific roles
const roles = [
  'user', 'power_user', 'moderator', 'admin', 
  'super_admin', 'content_editor', 'content_reviewer',
  'billing_admin', 'support_agent', 'developer'
  // ... 50 more roles
];

// Better: Fewer roles with granular permissions
const roles = {
  user: ['posts:read', 'posts:write_own'],
  moderator: ['posts:read', 'posts:write', 'posts:delete', 'users:read'],
  admin: ['posts:*', 'users:*', 'settings:*']
};
```

### 4. Mixing Authentication and Authorization

**Problem**: Confusing the two concepts in code.

```javascript
// Bad: Mixed concerns
function checkAccess(req, res, next) {
  if (!req.user) { // Authentication
    return res.status(401).json({ error: 'Unauthorized' });
  }
  if (!req.user.isAdmin) { // Authorization
    return res.status(403).json({ error: 'Forbidden' });
  }
  next();
}

// Good: Separate middleware
app.delete('/api/users/:id',
  authenticate,      // Who are you?
  requireAdmin,      // Can you do this?
  deleteUser
);
```

## Testing Authorization

### Unit Tests

```javascript
describe('Authorization', () => {
  test('admin can delete users', async () => {
    const admin = { id: 1, roles: ['admin'] };
    const result = await authorize(admin, 'users', 'delete');
    expect(result).toBe(true);
  });
  
  test('regular user cannot delete users', async () => {
    const user = { id: 2, roles: ['user'] };
    const result = await authorize(user, 'users', 'delete');
    expect(result).toBe(false);
  });
  
  test('user can edit own resources', async () => {
    const user = { id: 3, roles: ['user'] };
    const resource = { id: 'post-1', userId: 3 };
    const result = await authorizeResource(user, resource, 'edit');
    expect(result).toBe(true);
  });
});
```

### Integration Tests

```javascript
describe('POST /api/posts/:id', () => {
  test('returns 403 when user lacks permission', async () => {
    const user = await createUser({ roles: ['viewer'] });
    const post = await createPost({ userId: otherUser.id });
    
    const response = await request(app)
      .delete(`/api/posts/${post.id}`)
      .set('Authorization', `Bearer ${user.token}`)
      .expect(403);
      
    expect(response.body.error).toBe('Forbidden');
  });
});
```

## Summary

**Key Takeaways**:

1. **Authentication ≠ Authorization** - Know who the user is first, then check permissions
2. **RBAC** - Group permissions into roles for easier management
3. **Scopes** - Use granular permissions for fine-grained access control
4. **Resource-Level** - Check permissions on specific resources, not just types
5. **Deny by Default** - Require explicit permission grants
6. **Server-Side Enforcement** - Never trust client-side authorization
7. **Audit Everything** - Log authorization decisions for security and compliance
8. **Test Thoroughly** - Authorization bugs can have serious security implications

**Related Topics**:
- [5.1 Authentication Methods](5.1_Authentication_Methods.md)
- [5.3 Security Best Practices](5.3_Security_Best_Practices.md)
- [4.4 Error Handling](4.4_Error_Handling.md)
