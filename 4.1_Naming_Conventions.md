# Naming Conventions in REST API

## Introduction

Consistent naming conventions are fundamental to creating intuitive, maintainable, and professional REST APIs. Good naming makes your API self-documenting and reduces the learning curve for developers.

**Key principle:** Choose conventions once and apply them consistently across your entire API.

---

## Why Naming Conventions Matter

### Poor Naming vs Good Naming

```http
❌ Bad API (inconsistent, confusing):
GET /getUsers
GET /Products
POST /create_order
GET /user-profile
GET /api/v1/Customers

✅ Good API (consistent, clear):
GET /users
GET /products
POST /orders
GET /user-profiles
GET /api/v1/customers
```

**Impact of good naming:**
- **Reduced cognitive load** - Developers know what to expect
- **Faster onboarding** - New team members understand patterns quickly
- **Fewer bugs** - Consistent patterns reduce mistakes
- **Better maintainability** - Code is self-documenting
- **Professional appearance** - Builds trust with API consumers

---

## URI/Endpoint Naming Conventions

### 1. Use Nouns, Not Verbs

URIs should represent **resources** (nouns), not **actions** (verbs). The HTTP method represents the action.

```http
✅ Good - Resource-oriented:
GET    /users              → Retrieve users
POST   /users              → Create user
GET    /users/42           → Retrieve user 42
PUT    /users/42           → Update user 42
DELETE /users/42           → Delete user 42
GET    /products           → Retrieve products
POST   /orders             → Create order

❌ Bad - Action-oriented:
GET    /getUsers
POST   /createUser
GET    /getUserById/42
POST   /updateUser/42
POST   /deleteUser/42
GET    /getAllProducts
POST   /placeOrder
```

**Exception: Controller/Action endpoints**

Some operations don't fit CRUD and need action verbs:

```http
✅ Acceptable for non-CRUD operations:
POST /users/42/activate
POST /orders/789/cancel
POST /passwords/reset
POST /documents/123/publish
POST /servers/reboot
POST /cache/clear
```

---

### 2. Use Plural Forms for Collections

Always use plural nouns for collection resources.

```http
✅ Good - Consistent plural:
GET  /users              → List users
GET  /users/42           → Get user 42
POST /users              → Create user

GET  /products           → List products
GET  /products/123       → Get product 123

GET  /orders             → List orders
GET  /orders/789         → Get order 789

✅ Consistent pattern:
/users/{userId}
/products/{productId}
/orders/{orderId}
/categories/{categoryId}

❌ Bad - Mixed singular/plural:
GET  /user               → Confusing
GET  /user/42            → Is this "the user collection, item 42"?
POST /user               → Are we creating a user or the user collection?

GET  /product            → Inconsistent
GET  /products/123       → Mixed with plural

❌ Bad - Inconsistent:
/user/{userId}           → Singular
/products/{productId}    → Plural
```

**Why plural is better:**

```http
# Plural makes the pattern obvious:
/users                   → The users collection
/users/42                → User 42 from the users collection
/users/42/orders         → Orders of user 42
/users/42/orders/789     → Order 789 of user 42

# Singular creates ambiguity:
/user                    → One user? Which one? All users?
/user/42                 → Less clear relationship
```

**Exception: Singleton resources**

Use singular for resources that have only one instance:

```http
✅ Singular for singletons:
GET /profile             → Current user's profile (only one)
GET /settings            → Current user's settings
GET /cart                → Current user's cart
GET /session             → Current session
GET /config              → System configuration
```

---

### 3. Use Lowercase with Hyphens (kebab-case)

```http
✅ Good - kebab-case:
/user-profiles
/order-items
/shipping-addresses
/payment-methods
/shopping-carts
/product-categories
/user-preferences
/api-keys

❌ Bad - camelCase:
/userProfiles
/orderItems
/shippingAddresses

❌ Bad - PascalCase:
/UserProfiles
/OrderItems
/ShippingAddresses

❌ Bad - snake_case:
/user_profiles
/order_items
/shipping_addresses

❌ Bad - UPPERCASE:
/USER-PROFILES
/ORDER-ITEMS
```

**Why kebab-case?**

1. **Case-insensitive systems:** URLs can be case-insensitive in some systems
2. **Readability:** Hyphens provide clear word separation
3. **SEO-friendly:** Search engines treat hyphens as word separators
4. **Standard practice:** Most widely adopted convention for URLs
5. **No encoding needed:** Underscores and other characters may need encoding

**Technical note:**

```http
# RFC 3986 (URI specification) treats these as different:
/UserProfile  ≠  /userprofile  ≠  /USERPROFILE

# But many servers normalize to lowercase:
/UserProfile  →  /userprofile  (potential issue)

# kebab-case avoids these problems:
/user-profile  (always lowercase, no ambiguity)
```

---

### 4. Keep URIs Simple and Intuitive

```http
✅ Good - Clear and simple:
GET /users
GET /users/42
GET /users/42/orders
GET /products?category=electronics
GET /orders?status=pending&date=2026-01-13

❌ Bad - Too complex:
GET /api/v1/management/system/users/data/retrieve/42
GET /application/user/order/list/filter/by/status/pending
GET /get-all-products-in-category-electronics-sorted-by-price

✅ Good hierarchy:
/organizations/{orgId}/projects/{projectId}/tasks/{taskId}
(Clear 3-level hierarchy)

❌ Bad - Too deep:
/orgs/{orgId}/depts/{deptId}/teams/{teamId}/members/{memberId}/tasks/{taskId}/comments/{commentId}/replies/{replyId}
(6+ levels - use query params instead)
```

**Rule of thumb:** Maximum 2-3 levels of nesting in URI path.

---

### 5. Use Consistent Resource Hierarchy

```http
✅ Good - Logical hierarchy:
/users/42/orders
/users/42/orders/789
/users/42/orders/789/items
/users/42/addresses
/users/42/payment-methods

✅ Alternative - Flat with relationships:
/orders?userId=42
/orders/789
/order-items?orderId=789
/addresses?userId=42

❌ Bad - Inconsistent:
/users/42/orders           → Nested
/order/789/user            → Reversed relationship
/getOrderItems?order=789   → Different pattern
```

---

## Query Parameter Naming

### 1. Use Consistent Style

Choose one style and stick with it across all query parameters.

#### Option A: snake_case (Recommended)

```http
GET /products?
  category_id=5&
  min_price=100&
  max_price=500&
  sort_by=created_at&
  order_by=desc&
  page_number=2&
  page_size=20
```

**Pros:**
- Widely used in REST APIs
- Clear word separation
- Compatible with most backend languages
- No encoding needed

#### Option B: camelCase

```http
GET /products?
  categoryId=5&
  minPrice=100&
  maxPrice=500&
  sortBy=createdAt&
  orderBy=desc&
  pageNumber=2&
  pageSize=20
```

**Pros:**
- Matches JavaScript/TypeScript naming
- Consistent with JSON field names (if using camelCase)

#### Option C: kebab-case

```http
GET /products?
  category-id=5&
  min-price=100&
  max-price=500&
  sort-by=created-at&
  order-by=desc&
  page-number=2&
  page-size=20
```

**Pros:**
- Consistent with URI naming (if using kebab-case)
- Readable

**Cons:**
- Less common for query params
- Can be confused with arithmetic operators in some contexts

### 2. Common Query Parameter Names

**Pagination:**
```http
# Standard naming
?page=2&limit=20
?page=2&per_page=20
?offset=40&limit=20

# Alternative
?page_number=2&page_size=20
?skip=40&take=20
```

**Sorting:**
```http
# Single field
?sort=name
?sort_by=created_at
?order_by=name

# With direction
?sort=name&order=asc
?sort=-name          (minus for descending)
?sort=name:asc

# Multiple fields
?sort=last_name,first_name
?sort[]=last_name&sort[]=first_name
```

**Filtering:**
```http
# Basic filters
?status=active
?category=electronics
?is_featured=true

# Comparison operators
?price_gt=100        (greater than)
?price_gte=100       (greater than or equal)
?price_lt=1000       (less than)
?price_lte=1000      (less than or equal)
?price_ne=0          (not equal)

# Date filters
?created_after=2026-01-01
?created_before=2026-12-31
?created_at_gte=2026-01-01
?created_at_lte=2026-12-31

# List filters
?tags=javascript,nodejs,react
?category_in=electronics,computers
?status_not_in=archived,deleted
```

**Search:**
```http
?search=laptop
?q=laptop
?query=laptop
?keyword=laptop
```

**Field selection:**
```http
?fields=id,name,email
?select=id,name,email
?include=author,comments
?expand=related_products
```

**Miscellaneous:**
```http
?format=json
?locale=en-US
?timezone=America/New_York
?api_version=2
?pretty=true
?debug=true
```

### 3. Avoid Redundancy

```http
✅ Good:
GET /users?status=active

❌ Redundant:
GET /users?user_status=active
GET /users?users_status=active
```

---

## JSON Field Naming

### 1. Choose a Style and Be Consistent

#### Option A: camelCase (Most Common in JavaScript/JSON APIs)

```json
{
  "id": 42,
  "firstName": "John",
  "lastName": "Doe",
  "emailAddress": "john@example.com",
  "createdAt": "2026-01-13T10:00:00Z",
  "isActive": true,
  "userProfile": {
    "avatarUrl": "https://example.com/avatar.jpg",
    "dateOfBirth": "1990-01-15"
  },
  "orderHistory": [...]
}
```

**Pros:**
- Standard in JavaScript/TypeScript
- No conversion needed in JS clients
- Widely adopted
- Clean and readable

**Cons:**
- Inconsistent with Python/Ruby conventions (snake_case)
- May require conversion in backend

#### Option B: snake_case (Common in Python/Ruby APIs)

```json
{
  "id": 42,
  "first_name": "John",
  "last_name": "Doe",
  "email_address": "john@example.com",
  "created_at": "2026-01-13T10:00:00Z",
  "is_active": true,
  "user_profile": {
    "avatar_url": "https://example.com/avatar.jpg",
    "date_of_birth": "1990-01-15"
  },
  "order_history": [...]
}
```

**Pros:**
- Matches Python, Ruby, Go conventions
- Consistent with database column names
- No conversion needed in Python/Ruby backends

**Cons:**
- Requires conversion in JavaScript clients
- Less common in JSON APIs

#### Option C: PascalCase (Rare, used in .NET APIs)

```json
{
  "Id": 42,
  "FirstName": "John",
  "LastName": "Doe",
  "EmailAddress": "john@example.com",
  "CreatedAt": "2026-01-13T10:00:00Z",
  "IsActive": true
}
```

**Pros:**
- Matches C# conventions

**Cons:**
- Uncommon in REST APIs
- Looks unusual in JSON
- Not recommended unless .NET-specific API

### 2. Boolean Fields

```json
✅ Good - Use "is", "has", "can" prefixes:
{
  "isActive": true,
  "isDeleted": false,
  "hasChildren": true,
  "canEdit": true,
  "canDelete": false,
  "isVerified": true,
  "hasPermission": true
}

❌ Bad - Ambiguous:
{
  "active": true,         // Could be a status string
  "deleted": false,       // Unclear type
  "children": true,       // Confusing
  "edit": true,          // Unclear meaning
  "verified": true       // Better with "is"
}

✅ Alternative - Adjective form:
{
  "active": true,         // Acceptable if clearly boolean
  "verified": true,
  "enabled": true,
  "visible": true
}
```

### 3. Date/Time Fields

```json
✅ Good - Clear suffixes:
{
  "createdAt": "2026-01-13T10:00:00Z",
  "updatedAt": "2026-01-13T15:30:00Z",
  "deletedAt": null,
  "publishedAt": "2026-01-13T12:00:00Z",
  "expiresAt": "2026-12-31T23:59:59Z",
  "scheduledFor": "2026-01-15T09:00:00Z"
}

✅ Alternative:
{
  "createdDate": "2026-01-13",
  "createdTime": "10:00:00Z",
  "createdTimestamp": 1736764800
}

❌ Bad - Ambiguous:
{
  "created": "2026-01-13T10:00:00Z",  // Created what? Date? Time?
  "updated": "2026-01-13T15:30:00Z",
  "expires": "2026-12-31"
}
```

### 4. Collection Fields

```json
✅ Good - Plural for arrays:
{
  "users": [...],
  "products": [...],
  "orders": [...],
  "tags": ["javascript", "nodejs"],
  "comments": [...]
}

✅ Alternative - Descriptive:
{
  "userList": [...],
  "productCollection": [...],
  "orderItems": [...]
}

❌ Bad - Singular for arrays:
{
  "user": [...],           // Confusing - one user or many?
  "product": [...]
}
```

### 5. ID Fields

```json
✅ Good - Explicit:
{
  "id": 42,
  "userId": 10,
  "productId": 123,
  "categoryId": 5,
  "orderId": 789
}

✅ Alternative - With object:
{
  "user": {
    "id": 10,
    "name": "John"
  },
  "product": {
    "id": 123,
    "name": "Laptop"
  }
}

❌ Bad - Ambiguous:
{
  "id": 42,          // ID of what?
  "user": 10,        // Is this ID or object?
  "product": 123
}
```

### 6. Nested Objects

```json
✅ Good - Clear structure:
{
  "id": 42,
  "name": "John Doe",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zipCode": "10001"
  },
  "contactInfo": {
    "email": "john@example.com",
    "phone": "+1234567890"
  },
  "preferences": {
    "theme": "dark",
    "language": "en-US"
  }
}

❌ Bad - Flat with prefixes:
{
  "id": 42,
  "name": "John Doe",
  "addressStreet": "123 Main St",
  "addressCity": "New York",
  "addressState": "NY",
  "addressZipCode": "10001",
  "contactEmail": "john@example.com",
  "contactPhone": "+1234567890"
}
```

---

## HTTP Header Naming

### 1. Standard Headers (Use as-is)

```http
# Standard request headers
Content-Type: application/json
Accept: application/json
Authorization: Bearer token123
User-Agent: MyApp/1.0
Accept-Language: en-US
Accept-Encoding: gzip, deflate
If-None-Match: "etag123"
If-Modified-Since: Mon, 13 Jan 2026 10:00:00 GMT

# Standard response headers
Content-Type: application/json
Content-Length: 1234
Cache-Control: max-age=3600
ETag: "etag123"
Last-Modified: Mon, 13 Jan 2026 10:00:00 GMT
Location: /users/42
```

### 2. Custom Headers

Use `X-` prefix for custom headers (though this is deprecated in RFC 6648, it's still widely used):

```http
✅ Good - Custom headers:
X-Request-ID: req-abc-123
X-API-Key: key-xyz-789
X-Rate-Limit-Limit: 1000
X-Rate-Limit-Remaining: 850
X-Rate-Limit-Reset: 1736764800
X-Total-Count: 150
X-API-Version: 1.0
X-Response-Time: 45ms
X-Correlation-ID: corr-123-456

✅ Alternative - No X- prefix (newer standard):
Request-ID: req-abc-123
API-Key: key-xyz-789
Rate-Limit-Limit: 1000
Rate-Limit-Remaining: 850

❌ Bad - Inconsistent:
X-request-id: req-abc-123     // Inconsistent case
x-api-key: key-xyz-789        // Lowercase x
X_Rate_Limit: 1000            // Underscores
XAPIKEY: key-xyz-789          // No hyphens
```

**Convention:** Use `Title-Case-With-Hyphens` (like standard HTTP headers)

---

## Error Code Naming

### 1. Machine-Readable Error Codes

```json
✅ Good - SCREAMING_SNAKE_CASE:
{
  "error": "Validation Failed",
  "code": "VALIDATION_ERROR",
  "details": [
    {
      "field": "email",
      "code": "INVALID_EMAIL_FORMAT",
      "message": "Email format is invalid"
    },
    {
      "field": "password",
      "code": "PASSWORD_TOO_SHORT",
      "message": "Password must be at least 8 characters"
    }
  ]
}

✅ Good error codes:
AUTHENTICATION_FAILED
INVALID_TOKEN
TOKEN_EXPIRED
PERMISSION_DENIED
RESOURCE_NOT_FOUND
DUPLICATE_EMAIL
INVALID_PARAMETER
RATE_LIMIT_EXCEEDED
SERVER_ERROR
DATABASE_CONNECTION_FAILED
VALIDATION_ERROR
CONFLICT_DETECTED

❌ Bad - Inconsistent:
{
  "error": "validation failed",
  "code": "validationError",      // Wrong case
  "code": "validation-error",     // Wrong style
  "code": "ValidationError",      // Wrong style
  "code": "validation_failed_01"  // Numbers make it unclear
}
```

### 2. Namespaced Error Codes

```json
✅ Good - Categorized:
{
  "code": "AUTH.TOKEN_EXPIRED",
  "code": "AUTH.INVALID_CREDENTIALS",
  "code": "PAYMENT.CARD_DECLINED",
  "code": "PAYMENT.INSUFFICIENT_FUNDS",
  "code": "VALIDATION.INVALID_EMAIL",
  "code": "VALIDATION.REQUIRED_FIELD",
  "code": "RESOURCE.NOT_FOUND",
  "code": "RESOURCE.ALREADY_EXISTS"
}

✅ Alternative - Dotted notation:
{
  "code": "authentication.token_expired",
  "code": "payment.card_declined",
  "code": "validation.invalid_email"
}
```

---

## API Versioning Naming

### 1. URI Versioning

```http
✅ Good - Major version only:
/v1/users
/v2/users
/v3/users

✅ Good - With "api" prefix:
/api/v1/users
/api/v2/users

❌ Bad - Avoid minor versions in URI:
/v1.2/users
/v1.2.3/users
/version-1/users
/api-v1/users
```

### 2. Header Versioning

```http
✅ Good:
Accept: application/vnd.myapi.v2+json
API-Version: 2
X-API-Version: 2.1.0

❌ Bad:
Accept: application/json+v2
Version: 2
```

### 3. Query Parameter Versioning

```http
✅ Good (if you must use query params):
/users?version=2
/users?api_version=2

❌ Bad:
/users?v=2
/users?ver=2
```

---

## Consistency Across Languages

### JavaScript/TypeScript Client

```typescript
// If API uses camelCase JSON:
interface User {
  id: number;
  firstName: string;
  lastName: string;
  emailAddress: string;
  createdAt: string;
}

// If API uses snake_case JSON (need conversion):
interface UserAPI {
  id: number;
  first_name: string;
  last_name: string;
  email_address: string;
  created_at: string;
}

// Convert to camelCase for client use
function toCamelCase(user: UserAPI): User {
  return {
    id: user.id,
    firstName: user.first_name,
    lastName: user.last_name,
    emailAddress: user.email_address,
    createdAt: user.created_at
  };
}
```

### Python Backend

```python
# If API uses snake_case (natural in Python):
class User:
    def __init__(self):
        self.id = None
        self.first_name = None
        self.last_name = None
        self.email_address = None
        self.created_at = None

# If API uses camelCase (need conversion):
def to_camel_case(snake_dict):
    """Convert snake_case dict to camelCase"""
    camel_dict = {}
    for key, value in snake_dict.items():
        components = key.split('_')
        camel_key = components[0] + ''.join(x.title() for x in components[1:])
        camel_dict[camel_key] = value
    return camel_dict
```

---

## Real-World Complete Examples

### Example 1: E-commerce API

```http
# Endpoints (kebab-case URIs)
GET    /api/v1/products
GET    /api/v1/products/123
GET    /api/v1/product-categories
GET    /api/v1/shopping-carts
GET    /api/v1/user-profiles
GET    /api/v1/payment-methods
GET    /api/v1/shipping-addresses
GET    /api/v1/order-history

# Query parameters (snake_case)
GET /api/v1/products?
  category_id=5&
  min_price=100&
  max_price=500&
  is_featured=true&
  in_stock=true&
  sort_by=price&
  order_by=asc&
  page=1&
  page_size=20

# Request/Response JSON (camelCase)
POST /api/v1/orders
{
  "userId": 42,
  "items": [
    {
      "productId": 123,
      "quantity": 2,
      "pricePerUnit": 29.99
    }
  ],
  "shippingAddress": {
    "street": "123 Main St",
    "city": "New York",
    "zipCode": "10001"
  },
  "paymentMethod": {
    "type": "credit_card",
    "lastFourDigits": "4242"
  }
}

Response:
{
  "orderId": 789,
  "userId": 42,
  "orderStatus": "pending",
  "totalAmount": 69.98,
  "createdAt": "2026-01-13T10:00:00Z",
  "estimatedDelivery": "2026-01-15T18:00:00Z",
  "trackingNumber": "TRK123456789"
}

# Custom headers (Title-Case)
X-Request-ID: req-abc-123
X-API-Version: 1.0
X-Rate-Limit-Remaining: 950

# Error codes (SCREAMING_SNAKE_CASE)
{
  "error": "Validation Failed",
  "code": "VALIDATION_ERROR",
  "details": [
    {
      "field": "paymentMethod",
      "code": "INVALID_PAYMENT_METHOD",
      "message": "Payment method is invalid or expired"
    }
  ]
}
```

---

### Example 2: Social Media API

```http
# Endpoints
GET    /api/v1/users
GET    /api/v1/users/42/followers
GET    /api/v1/users/42/following
GET    /api/v1/posts
POST   /api/v1/posts
GET    /api/v1/posts/123/comments
GET    /api/v1/posts/123/likes
POST   /api/v1/posts/123/share
GET    /api/v1/direct-messages
GET    /api/v1/notifications

# Query parameters
GET /api/v1/posts?
  author_id=42&
  created_after=2026-01-01&
  has_media=true&
  sort_by=created_at&
  order_by=desc&
  include=author,comments&
  page=1&
  limit=20

# JSON Response
{
  "postId": 123,
  "authorId": 42,
  "author": {
    "userId": 42,
    "username": "john_doe",
    "displayName": "John Doe",
    "avatarUrl": "https://example.com/avatar.jpg",
    "isVerified": true
  },
  "content": "Check out this amazing sunset!",
  "mediaUrls": [
    "https://example.com/photo1.jpg"
  ],
  "likesCount": 150,
  "commentsCount": 23,
  "sharesCount": 5,
  "isLikedByCurrentUser": false,
  "createdAt": "2026-01-13T10:00:00Z",
  "updatedAt": "2026-01-13T10:05:00Z"
}
```

---

## Common Mistakes and Anti-Patterns

### Mistake 1: Mixing Naming Styles

```http
❌ Inconsistent API:
GET /user-profiles         (kebab-case)
GET /orderItems            (camelCase)
GET /payment_methods       (snake_case)
GET /ShippingAddresses     (PascalCase)

Query params:
?user_id=42&orderType=standard&shipping-method=express

JSON:
{
  "user_id": 42,
  "orderItems": [...],
  "shipping-address": {...}
}

✅ Consistent API:
GET /user-profiles
GET /order-items
GET /payment-methods
GET /shipping-addresses

Query params:
?user_id=42&order_type=standard&shipping_method=express

JSON (camelCase):
{
  "userId": 42,
  "orderItems": [...],
  "shippingAddress": {...}
}
```

### Mistake 2: Using Verbs in Resource URIs

```http
❌ Bad:
GET  /getUsers
POST /createUser
POST /updateUser/42
POST /deleteUser/42
GET  /searchProducts

✅ Good:
GET    /users
POST   /users
PUT    /users/42
DELETE /users/42
POST   /products/search  (OK for complex search)
```

### Mistake 3: Inconsistent Plurality

```http
❌ Bad:
GET /user/42
GET /users/42/order
GET /orders/789/item

✅ Good:
GET /users/42
GET /users/42/orders
GET /orders/789/items
```

### Mistake 4: Abbreviations and Acronyms

```http
❌ Bad - Inconsistent abbreviations:
GET /usr/42
GET /prod/123
GET /addr/789
GET /doc/456

✅ Good - Full words or consistent abbreviations:
GET /users/42
GET /products/123
GET /addresses/789
GET /documents/456

✅ Acceptable - Standard abbreviations:
GET /api/v1/users
GET /api/v1/ids
GET /api/v1/urls
GET /api/v1/html-content
```

### Mistake 5: Unclear Boolean Fields

```json
❌ Bad:
{
  "active": "yes",        // Should be boolean
  "deleted": 1,          // Should be boolean
  "verified": "true",    // String instead of boolean
  "enabled": "false"     // String instead of boolean
}

✅ Good:
{
  "isActive": true,
  "isDeleted": false,
  "isVerified": true,
  "isEnabled": false
}
```

### Mistake 6: Redundant Naming

```http
❌ Bad:
GET /api/users?user_status=active&user_role=admin

JSON:
{
  "userId": 42,
  "userName": "john_doe",
  "userEmail": "john@example.com"
}

✅ Good:
GET /api/users?status=active&role=admin

JSON:
{
  "id": 42,
  "name": "john_doe",
  "email": "john@example.com"
}
```

---

## Best Practices Summary

### 1. Document Your Conventions

Create an API style guide:

```markdown
# API Style Guide

## URI Conventions
- Use kebab-case: `/user-profiles`
- Plural nouns: `/users`, `/products`
- Max 2-3 nesting levels
- Lowercase only

## Query Parameters
- Use snake_case: `?sort_by=name&order_by=asc`
- Standard pagination: `?page=1&limit=20`
- Comparison operators: `_gt`, `_gte`, `_lt`, `_lte`

## JSON Fields
- Use camelCase: `{"firstName": "John"}`
- Boolean prefix: `isActive`, `hasPermission`
- Date suffix: `createdAt`, `updatedAt`

## Headers
- Custom headers: `X-Request-ID`, `X-API-Version`
- Title-Case-With-Hyphens

## Error Codes
- SCREAMING_SNAKE_CASE: `VALIDATION_ERROR`
- Namespaced: `AUTH.TOKEN_EXPIRED`
```

### 2. Use Code Generation

```yaml
# OpenAPI specification enforces consistency
openapi: 3.0.0
info:
  title: My API
  version: 1.0.0
paths:
  /users:
    get:
      summary: List users
      parameters:
        - name: status
          in: query
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
components:
  schemas:
    User:
      type: object
      properties:
        userId:           # Enforces camelCase
          type: integer
        firstName:
          type: string
        isActive:
          type: boolean
```

### 3. Automated Linting

```javascript
// ESLint rule for API naming
module.exports = {
  rules: {
    'api-naming/uri-kebab-case': 'error',
    'api-naming/json-camel-case': 'error',
    'api-naming/query-snake-case': 'warn',
    'api-naming/no-verbs-in-uri': 'error'
  }
};
```

### 4. Consistency Checklist

Before releasing your API:

- ✅ All URIs use same case (kebab-case recommended)
- ✅ All collection resources are plural
- ✅ All query parameters use same case (snake_case or camelCase)
- ✅ All JSON fields use same case (camelCase recommended)
- ✅ Boolean fields have clear prefixes (is, has, can)
- ✅ Date fields have clear suffixes (At, Date, Time)
- ✅ Error codes use SCREAMING_SNAKE_CASE
- ✅ Custom headers use X- prefix and Title-Case
- ✅ No verbs in resource URIs (except action endpoints)
- ✅ Naming conventions documented in API guide

---

## Summary

**Key Principles:**

1. **Choose once, apply everywhere** - Consistency is more important than the specific choice
2. **Be predictable** - Developers should guess correctly
3. **Follow standards** - Use HTTP conventions, RFC standards
4. **Consider your audience** - Match frontend conventions when possible
5. **Document everything** - Create a style guide

**Recommended Conventions:**

| Element | Convention | Example |
|---------|-----------|---------|
| URI paths | kebab-case | `/user-profiles` |
| Collections | Plural | `/users` |
| Singletons | Singular | `/profile` |
| Query params | snake_case | `?sort_by=name` |
| JSON fields | camelCase | `{"firstName": "John"}` |
| Booleans | is/has/can prefix | `isActive`, `hasPermission` |
| Dates | At/Date suffix | `createdAt`, `expiresAt` |
| Headers | Title-Case | `X-Request-ID` |
| Error codes | SCREAMING_SNAKE_CASE | `VALIDATION_ERROR` |
| Versions | vN | `/v1/users` |

**Remember:** Perfect consistency is more valuable than perfect naming. Pick a convention and stick with it religiously.

---

## Next Steps

Now that you understand naming conventions, explore:
- Idempotency in REST APIs
- Versioning strategies
- Error handling patterns
- API documentation best practices
- Code generation from OpenAPI specs
