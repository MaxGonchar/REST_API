# HTTP Status Codes in REST API

## Introduction

HTTP status codes are three-digit numbers that indicate the result of an HTTP request. They're the server's way of communicating what happened with a request - success, failure, or something in between.

**Structure:** Status codes are organized into five categories based on their first digit:
- **1xx** - Informational responses
- **2xx** - Success
- **3xx** - Redirection
- **4xx** - Client errors
- **5xx** - Server errors

**Key principle:** Status codes should accurately reflect what happened so clients can respond appropriately.

---

## 2xx Success Codes

These indicate that the request was received, understood, and successfully processed.

### 200 OK

**Meaning:** The request succeeded. The meaning depends on the HTTP method.

**When to use:**
- GET: Resource retrieved successfully
- PUT: Resource updated successfully
- PATCH: Resource updated successfully
- DELETE: Resource deleted and returning response body

**Examples:**

```http
GET /users/42
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "John Doe",
  "email": "john@example.com"
}
```

```http
PUT /users/42
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 42,
  "name": "Jane Doe",
  "email": "jane@example.com",
  "updatedAt": "2026-01-12T10:00:00Z"
}
```

**Real-world analogy:** You asked for something and got exactly what you expected.

---

### 201 Created

**Meaning:** Request succeeded and a new resource was created.

**When to use:**
- POST: New resource created
- PUT: New resource created (when resource didn't exist)

**Must include:** `Location` header with URI of the newly created resource

**Example:**

```http
POST /users
Content-Type: application/json

{
  "name": "Alice",
  "email": "alice@example.com"
}

Response:
HTTP/1.1 201 Created
Location: /users/43
Content-Type: application/json

{
  "id": 43,
  "name": "Alice",
  "email": "alice@example.com",
  "createdAt": "2026-01-12T10:00:00Z"
}
```

**Real-world analogy:** You submitted a form and a new record was created in the system.

---

### 202 Accepted

**Meaning:** Request accepted for processing, but processing hasn't completed yet.

**When to use:**
- Asynchronous operations
- Long-running tasks
- Batch processing
- Background jobs

**Example:**

```http
POST /reports/generate
Content-Type: application/json

{
  "type": "sales",
  "period": "2025-Q4"
}

Response:
HTTP/1.1 202 Accepted
Content-Type: application/json

{
  "jobId": "abc-123",
  "status": "processing",
  "statusUrl": "/jobs/abc-123",
  "estimatedCompletion": "2026-01-12T10:15:00Z"
}
```

**Follow-up:**
```http
GET /jobs/abc-123
HTTP/1.1 200 OK

{
  "jobId": "abc-123",
  "status": "completed",
  "result": "/reports/sales-2025-q4.pdf"
}
```

**Real-world analogy:** You dropped off dry cleaning. They accepted it, gave you a ticket, and you'll pick it up later.

---

### 204 No Content

**Meaning:** Request succeeded, but there's no content to return.

**When to use:**
- DELETE: Resource deleted successfully
- PUT/PATCH: Update successful, no need to return the resource
- POST: Action performed successfully with no data to return

**Important:** No response body. Response must not contain a body.

**Examples:**

```http
DELETE /users/42
HTTP/1.1 204 No Content
```

```http
PUT /users/42/preferences
Content-Type: application/json

{
  "theme": "dark",
  "notifications": true
}

Response:
HTTP/1.1 204 No Content
```

**Real-world analogy:** You sent a command, it worked, and there's nothing more to say.

---

### 206 Partial Content

**Meaning:** Server is delivering only part of the resource due to a range request.

**When to use:**
- Video/audio streaming
- Large file downloads with resume capability
- Paginated content at the HTTP level

**Example:**

```http
GET /videos/large-file.mp4
Range: bytes=0-1023

Response:
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/54321000
Content-Length: 1024
Content-Type: video/mp4

[binary data]
```

**Real-world analogy:** You asked for chapter 3 of a book, and that's exactly what you got (not the whole book).

---

## 3xx Redirection Codes

These indicate that further action is needed to complete the request.

### 301 Moved Permanently

**Meaning:** Resource has been permanently moved to a new URI.

**When to use:**
- API endpoint has permanently changed
- Resource location has changed forever

**Must include:** `Location` header with new URI

**Example:**

```http
GET /api/v1/users
HTTP/1.1 301 Moved Permanently
Location: /api/v2/users
```

**Client should:** Update bookmarks and use new URI for future requests.

**Real-world analogy:** A business moved to a new address permanently. They left a forwarding note.

---

### 302 Found (Temporary Redirect)

**Meaning:** Resource temporarily resides at a different URI.

**When to use:**
- Temporary maintenance
- A/B testing
- Temporary resource relocation

**Example:**

```http
GET /api/users
HTTP/1.1 302 Found
Location: /api/users-temp
```

**Client should:** Continue using the original URI for future requests.

---

### 303 See Other

**Meaning:** Response can be found at a different URI using GET.

**When to use:**
- After POST/PUT/DELETE, redirect to resource representation
- Prevent double submission

**Example:**

```http
POST /orders
Content-Type: application/json

{
  "items": [...]
}

Response:
HTTP/1.1 303 See Other
Location: /orders/789
```

**Client should:** Make a GET request to the Location URI.

**Use case:** Prevent form resubmission when user refreshes the page.

---

### 304 Not Modified

**Meaning:** Resource hasn't changed since last request (based on cache validation).

**When to use:**
- Client has cached version
- ETag or Last-Modified headers match

**No response body**

**Example:**

```http
GET /api/data
If-None-Match: "abc123"

Response:
HTTP/1.1 304 Not Modified
ETag: "abc123"
Cache-Control: max-age=3600
```

**Real-world analogy:** You asked if the document changed since you last saw it. Answer: "Nope, you already have the latest version."

---

### 307 Temporary Redirect

**Meaning:** Same as 302, but client must use the same HTTP method.

**Difference from 302:**
- 302: Browsers may change POST to GET
- 307: Method must stay the same

**Example:**

```http
POST /api/payments
HTTP/1.1 307 Temporary Redirect
Location: /api/payments-backup
```

**Client should:** Retry the POST to the new location.

---

### 308 Permanent Redirect

**Meaning:** Same as 301, but client must use the same HTTP method.

**Example:**

```http
POST /api/v1/orders
HTTP/1.1 308 Permanent Redirect
Location: /api/v2/orders
```

---

## 4xx Client Error Codes

These indicate that the client made an error.

### 400 Bad Request

**Meaning:** Server cannot process the request due to client error (malformed syntax, invalid request format).

**When to use:**
- Invalid JSON
- Missing required fields
- Invalid data format
- Malformed request

**Examples:**

```http
POST /users
Content-Type: application/json

{
  "name": "John"
  "email": "invalid"  // Missing comma, invalid email
}

Response:
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Bad Request",
  "message": "Invalid JSON syntax",
  "details": [
    {
      "field": "body",
      "issue": "Expected comma at line 3"
    }
  ]
}
```

```http
POST /users
Content-Type: application/json

{
  "name": 123,  // Should be string
  "email": "not-an-email"
}

Response:
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Bad Request",
  "message": "Validation failed",
  "details": [
    {
      "field": "name",
      "issue": "Must be a string"
    },
    {
      "field": "email",
      "issue": "Invalid email format"
    }
  ]
}
```

**Real-world analogy:** You filled out a form incorrectly, and it can't be processed.

---

### 401 Unauthorized

**Meaning:** Authentication is required and has failed or not been provided.

**When to use:**
- No authentication credentials provided
- Invalid credentials
- Expired token
- Token signature invalid

**Must include:** `WWW-Authenticate` header (recommended)

**Examples:**

```http
GET /api/profile
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="API"
Content-Type: application/json

{
  "error": "Unauthorized",
  "message": "Authentication required"
}
```

```http
GET /api/profile
Authorization: Bearer expired-token

Response:
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error="invalid_token", error_description="Token expired"
Content-Type: application/json

{
  "error": "Unauthorized",
  "message": "Token has expired",
  "expiredAt": "2026-01-12T09:00:00Z"
}
```

**Note:** Despite the name "Unauthorized", this means "unauthenticated" (not "forbidden").

**Real-world analogy:** You need to show ID to enter, but you didn't bring it (or it's expired).

---

### 403 Forbidden

**Meaning:** Server understood the request, but refuses to authorize it.

**When to use:**
- User is authenticated but lacks permissions
- Resource access is forbidden
- Account suspended
- IP blocked

**Examples:**

```http
GET /admin/users
Authorization: Bearer valid-token-for-regular-user

Response:
HTTP/1.1 403 Forbidden
Content-Type: application/json

{
  "error": "Forbidden",
  "message": "Insufficient permissions",
  "required": "admin",
  "current": "user"
}
```

```http
DELETE /users/42
Authorization: Bearer valid-token-for-user-123

Response:
HTTP/1.1 403 Forbidden
Content-Type: application/json

{
  "error": "Forbidden",
  "message": "You can only delete your own account"
}
```

**Key difference from 401:**
- 401: "I don't know who you are" (authentication issue)
- 403: "I know who you are, but you can't do this" (authorization issue)

**Real-world analogy:** You have a valid ID and got past security, but this room is off-limits to you.

---

### 404 Not Found

**Meaning:** The requested resource doesn't exist.

**When to use:**
- Resource doesn't exist
- Resource was deleted
- Endpoint doesn't exist

**Examples:**

```http
GET /users/999999
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Not Found",
  "message": "User with id 999999 not found"
}
```

```http
GET /api/nonexistent-endpoint
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Not Found",
  "message": "Endpoint not found"
}
```

**Real-world analogy:** You went to a store looking for a specific product, but they don't carry it.

---

### 405 Method Not Allowed

**Meaning:** HTTP method is not supported for this resource.

**When to use:**
- Endpoint exists but doesn't support the HTTP method

**Must include:** `Allow` header listing valid methods

**Example:**

```http
POST /users/42
HTTP/1.1 405 Method Not Allowed
Allow: GET, PUT, PATCH, DELETE
Content-Type: application/json

{
  "error": "Method Not Allowed",
  "message": "POST is not allowed on this resource",
  "allowedMethods": ["GET", "PUT", "PATCH", "DELETE"]
}
```

**Real-world analogy:** You can read and edit the document, but you can't create new documents in this folder.

---

### 406 Not Acceptable

**Meaning:** Server cannot produce a response matching the `Accept` headers.

**When to use:**
- Client requests format server doesn't support

**Example:**

```http
GET /users/42
Accept: application/xml

Response:
HTTP/1.1 406 Not Acceptable
Content-Type: application/json

{
  "error": "Not Acceptable",
  "message": "Server only supports application/json",
  "supportedFormats": ["application/json"]
}
```

---

### 408 Request Timeout

**Meaning:** Client didn't send request within the time the server was willing to wait.

**When to use:**
- Client connection timed out
- Request took too long to arrive

**Example:**

```http
HTTP/1.1 408 Request Timeout
Content-Type: application/json

{
  "error": "Request Timeout",
  "message": "Client did not send request within 30 seconds"
}
```

---

### 409 Conflict

**Meaning:** Request conflicts with current state of the server.

**When to use:**
- Version conflict (optimistic locking)
- Resource already exists
- Business rule violation
- State conflict

**Examples:**

```http
POST /users
Content-Type: application/json

{
  "username": "john",
  "email": "john@example.com"
}

Response:
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": "Conflict",
  "message": "Username 'john' already exists",
  "field": "username"
}
```

```http
PUT /users/42
If-Match: "abc123"
Content-Type: application/json

{
  "name": "John Updated"
}

Response:
HTTP/1.1 409 Conflict
ETag: "xyz789"
Content-Type: application/json

{
  "error": "Conflict",
  "message": "Resource has been modified by another user",
  "currentVersion": "xyz789",
  "providedVersion": "abc123"
}
```

**Real-world analogy:** You tried to book a seat that someone just booked a second before you.

---

### 410 Gone

**Meaning:** Resource was available but has been permanently removed.

**When to use:**
- Resource was intentionally deleted
- Resource expired and won't return
- Different from 404 (which might be temporary)

**Example:**

```http
GET /posts/old-post-123
HTTP/1.1 410 Gone
Content-Type: application/json

{
  "error": "Gone",
  "message": "This post was deleted on 2025-12-01",
  "deletedAt": "2025-12-01T10:00:00Z"
}
```

**Real-world analogy:** The store used to sell that item, but it's discontinued and will never be back.

---

### 413 Payload Too Large

**Meaning:** Request payload is larger than server is willing to process.

**When to use:**
- File upload exceeds size limit
- Request body too large

**Example:**

```http
POST /uploads
Content-Length: 52428800  // 50MB

Response:
HTTP/1.1 413 Payload Too Large
Content-Type: application/json

{
  "error": "Payload Too Large",
  "message": "File size exceeds limit",
  "maxSize": 10485760,  // 10MB
  "providedSize": 52428800
}
```

---

### 415 Unsupported Media Type

**Meaning:** Server refuses to accept the request because payload format is unsupported.

**When to use:**
- Wrong `Content-Type` header
- Unsupported data format

**Example:**

```http
POST /users
Content-Type: application/xml

<user>
  <name>John</name>
</user>

Response:
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/json

{
  "error": "Unsupported Media Type",
  "message": "Server only accepts application/json",
  "providedType": "application/xml",
  "supportedTypes": ["application/json"]
}
```

---

### 422 Unprocessable Entity

**Meaning:** Request is well-formed, but semantically incorrect (business logic validation failed).

**When to use:**
- Valid JSON/XML but business rules violated
- Semantic validation errors
- Data constraints violated

**Examples:**

```http
POST /orders
Content-Type: application/json

{
  "productId": 123,
  "quantity": -5  // Negative quantity
}

Response:
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
  "error": "Unprocessable Entity",
  "message": "Validation failed",
  "details": [
    {
      "field": "quantity",
      "issue": "Must be greater than 0",
      "provided": -5
    }
  ]
}
```

```http
POST /transfers
Content-Type: application/json

{
  "fromAccount": "123",
  "toAccount": "456",
  "amount": 1000
}

Response:
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
  "error": "Unprocessable Entity",
  "message": "Insufficient funds",
  "details": {
    "balance": 500,
    "requested": 1000,
    "required": 500
  }
}
```

**Key difference from 400:**
- 400: Request format/syntax is wrong
- 422: Request format is correct, but data doesn't make sense

**Real-world analogy:** You filled out the form correctly, but you're trying to withdraw $1000 when you only have $500.

---

### 429 Too Many Requests

**Meaning:** User has sent too many requests in a given time (rate limiting).

**When to use:**
- Rate limit exceeded
- Too many requests from IP
- API quota exceeded

**Must include:** `Retry-After` header (recommended)

**Example:**

```http
GET /api/data
HTTP/1.1 429 Too Many Requests
Retry-After: 60
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1705068000
Content-Type: application/json

{
  "error": "Too Many Requests",
  "message": "Rate limit exceeded",
  "limit": 100,
  "window": "1 hour",
  "retryAfter": 60
}
```

**Real-world analogy:** You've made too many attempts to log in. Wait a bit before trying again.

---

## 5xx Server Error Codes

These indicate that the server failed to fulfill a valid request.

### 500 Internal Server Error

**Meaning:** Server encountered an unexpected condition.

**When to use:**
- Unhandled exception
- Unexpected error
- Generic server error

**Example:**

```http
GET /users/42
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "error": "Internal Server Error",
  "message": "An unexpected error occurred",
  "requestId": "abc-123-xyz"  // For tracking/debugging
}
```

**Important:** Don't expose sensitive error details to clients.

```javascript
// ❌ Don't expose:
{
  "error": "Database connection failed",
  "stackTrace": "at DatabaseConnection.connect...",
  "config": { "dbHost": "10.0.0.5", "password": "..." }
}

// ✅ Do expose:
{
  "error": "Internal Server Error",
  "message": "An unexpected error occurred",
  "requestId": "abc-123"
}
```

**Real-world analogy:** Something broke in the kitchen, but the waiter just says "Sorry, we're having technical difficulties."

---

### 501 Not Implemented

**Meaning:** Server doesn't support the functionality required to fulfill the request.

**When to use:**
- Feature not yet implemented
- HTTP method not recognized

**Example:**

```http
CUSTOM-METHOD /api/users
HTTP/1.1 501 Not Implemented
Content-Type: application/json

{
  "error": "Not Implemented",
  "message": "CUSTOM-METHOD is not supported"
}
```

---

### 502 Bad Gateway

**Meaning:** Server acting as gateway received invalid response from upstream server.

**When to use:**
- Upstream server returned invalid response
- Proxy/gateway communication failed

**Example:**

```http
GET /api/external-data
HTTP/1.1 502 Bad Gateway
Content-Type: application/json

{
  "error": "Bad Gateway",
  "message": "Upstream service returned invalid response"
}
```

**Real-world analogy:** You called customer service, they tried to transfer you to another department, but that line is dead.

---

### 503 Service Unavailable

**Meaning:** Server is temporarily unable to handle the request.

**When to use:**
- Server overloaded
- Server maintenance
- Temporary outage

**Should include:** `Retry-After` header

**Example:**

```http
GET /api/users
HTTP/1.1 503 Service Unavailable
Retry-After: 120
Content-Type: application/json

{
  "error": "Service Unavailable",
  "message": "Server is temporarily unavailable",
  "reason": "scheduled maintenance",
  "retryAfter": 120
}
```

**Real-world analogy:** Store is closed for renovation. Come back in an hour.

---

### 504 Gateway Timeout

**Meaning:** Server acting as gateway didn't receive timely response from upstream server.

**When to use:**
- Upstream server didn't respond in time
- Timeout waiting for external service

**Example:**

```http
GET /api/slow-service
HTTP/1.1 504 Gateway Timeout
Content-Type: application/json

{
  "error": "Gateway Timeout",
  "message": "Upstream service did not respond in time",
  "timeout": 30
}
```

---

## Tricky Cases and How to Handle Them

### Case 1: Resource Doesn't Exist vs. No Permission

**Scenario:** User requests a resource that either doesn't exist OR they don't have permission to see.

**Problem:**
```http
GET /users/999  // Doesn't exist
GET /users/123  // Exists but user lacks permission
```

**Options:**

**Option A: Always return 404**
```http
HTTP/1.1 404 Not Found
```
**Pros:** Doesn't reveal resource existence
**Cons:** Less clear for debugging

**Option B: Return appropriate code**
```http
// Doesn't exist:
HTTP/1.1 404 Not Found

// No permission:
HTTP/1.1 403 Forbidden
```
**Pros:** Clear error messages
**Cons:** Reveals resource existence (security risk)

**Recommendation:** 
- **Public APIs:** Use 404 for both (security by obscurity)
- **Internal APIs:** Use accurate codes (403/404) for debugging
- **Sensitive resources:** Always 404 to prevent information disclosure

```javascript
// Implementation example
async function getUser(userId, requestingUser) {
  const user = await database.findUser(userId);
  
  if (!user) {
    return 404; // Not Found
  }
  
  if (!canAccess(requestingUser, user)) {
    // Security-sensitive: return 404
    return 404; // Pretend it doesn't exist
    
    // OR if not sensitive: return 403
    // return 403; // Forbidden
  }
  
  return user;
}
```

---

### Case 2: Validation Failed - 400 vs 422

**Scenario:** Client sent invalid data.

**Problem:** When to use 400 vs 422?

**Guidelines:**

**Use 400 when:**
- Malformed JSON/XML
- Invalid syntax
- Wrong data types
- Corrupted request

```http
POST /users
{ "name": "John"  // Missing closing brace

Response:
HTTP/1.1 400 Bad Request
{
  "error": "Invalid JSON syntax"
}
```

**Use 422 when:**
- Valid format but business rules violated
- Semantic validation failed
- Data constraints violated

```http
POST /users
{
  "name": "J",  // Too short
  "age": -5     // Negative age
}

Response:
HTTP/1.1 422 Unprocessable Entity
{
  "error": "Validation failed",
  "details": [
    { "field": "name", "issue": "Minimum 2 characters" },
    { "field": "age", "issue": "Must be positive" }
  ]
}
```

**Decision tree:**
```
Can the request be parsed?
├─ No → 400 Bad Request
└─ Yes → Does it violate business rules?
           ├─ Yes → 422 Unprocessable Entity
           └─ No → Process request
```

---

### Case 3: Partial Success in Batch Operations

**Scenario:** Batch request where some items succeed and others fail.

**Problem:** What status code to return?

**Options:**

**Option A: 200 with detailed results**
```http
POST /users/batch
[
  { "name": "John", "email": "john@example.com" },
  { "name": "Jane", "email": "invalid" },
  { "name": "Bob", "email": "bob@example.com" }
]

Response:
HTTP/1.1 200 OK
{
  "results": [
    { "status": "success", "id": 123 },
    { "status": "error", "message": "Invalid email" },
    { "status": "success", "id": 124 }
  ],
  "summary": {
    "total": 3,
    "successful": 2,
    "failed": 1
  }
}
```

**Option B: 207 Multi-Status (WebDAV)**
```http
POST /users/batch
[...]

Response:
HTTP/1.1 207 Multi-Status
{
  "responses": [
    {
      "item": 0,
      "status": 201,
      "body": { "id": 123, ... }
    },
    {
      "item": 1,
      "status": 422,
      "body": { "error": "Invalid email" }
    },
    {
      "item": 2,
      "status": 201,
      "body": { "id": 124, ... }
    }
  ]
}
```

**Recommendation:** Use 207 if supported, otherwise 200 with detailed breakdown.

---

### Case 4: Resource Creation - 200 vs 201

**Scenario:** Creating a resource via POST or PUT.

**Guidelines:**

**Use 201 Created when:**
- New resource was created
- Resource has new URI

```http
POST /users
→ HTTP/1.1 201 Created
  Location: /users/123
```

**Use 200 OK when:**
- Operation succeeded but no new resource
- Action performed without creation

```http
POST /users/42/reset-password
→ HTTP/1.1 200 OK
  { "message": "Password reset email sent" }
```

**Use 202 Accepted when:**
- Request accepted but processing async

```http
POST /reports/generate
→ HTTP/1.1 202 Accepted
  { "jobId": "abc-123", "status": "processing" }
```

---

### Case 5: Update Non-Existent Resource - 404 vs 400

**Scenario:** PUT/PATCH to a resource that doesn't exist.

**Problem:** Should return 404 or create it?

**Options:**

**Option A: Return 404**
```http
PUT /users/999
{ "name": "John" }

Response:
HTTP/1.1 404 Not Found
{ "error": "User 999 not found" }
```
**Use when:** Updates only, no implicit creation

**Option B: Create resource (upsert)**
```http
PUT /users/999
{ "name": "John" }

Response:
HTTP/1.1 201 Created
Location: /users/999
```
**Use when:** PUT supports creation at client-specified URI

**Recommendation:**
- **PUT:** Can create (upsert behavior)
- **PATCH:** Return 404 (patch can't create)

```javascript
// PUT - upsert
app.put('/users/:id', async (req, res) => {
  const user = await database.findUser(req.params.id);
  
  if (user) {
    // Update existing
    await database.updateUser(req.params.id, req.body);
    return res.status(200).json(user);
  } else {
    // Create new
    const newUser = await database.createUser(req.params.id, req.body);
    return res.status(201).json(newUser);
  }
});

// PATCH - update only
app.patch('/users/:id', async (req, res) => {
  const user = await database.findUser(req.params.id);
  
  if (!user) {
    return res.status(404).json({ error: "User not found" });
  }
  
  await database.updateUser(req.params.id, req.body);
  return res.status(200).json(user);
});
```

---

### Case 6: Duplicate Creation - 409 vs 200 vs 201

**Scenario:** Client tries to create a resource that already exists.

**Problem:** What to return?

**Options:**

**Option A: Return 409 Conflict**
```http
POST /users
{ "username": "john" }  // Already exists

Response:
HTTP/1.1 409 Conflict
{
  "error": "Conflict",
  "message": "Username already exists",
  "field": "username"
}
```
**Use when:** Duplicate is an error

**Option B: Return 200 with existing resource**
```http
POST /users
{ "username": "john" }

Response:
HTTP/1.1 200 OK
{
  "id": 42,
  "username": "john",
  "message": "User already exists"
}
```
**Use when:** Idempotent creation is acceptable

**Option C: Use PUT for idempotent creation**
```http
PUT /users/john  // Username in URL
{ "email": "john@example.com" }

Response:
HTTP/1.1 200 OK  // Or 201 if created
```

**Recommendation:**
- **POST:** Return 409 (POST should not be idempotent)
- **PUT:** Return 200/201 depending on created vs updated
- **Idempotent POST:** Document clearly and return 200

---

### Case 7: Async Operation Status - Which Code?

**Scenario:** Checking status of async operation.

**States and Codes:**

```http
// Job in progress
GET /jobs/abc-123
HTTP/1.1 200 OK
{
  "status": "processing",
  "progress": 45,
  "estimatedCompletion": "2026-01-12T11:00:00Z"
}

// Job completed successfully
GET /jobs/abc-123
HTTP/1.1 200 OK
{
  "status": "completed",
  "result": "/downloads/report.pdf"
}

// Job failed
GET /jobs/abc-123
HTTP/1.1 200 OK
{
  "status": "failed",
  "error": "Processing error",
  "details": "..."
}

// Job doesn't exist
GET /jobs/invalid
HTTP/1.1 404 Not Found
{
  "error": "Job not found"
}
```

**Key principle:** Status endpoint returns 200 with job state in body, not HTTP status for job status.

---

### Case 8: Soft Delete - 204 vs 200

**Scenario:** Resource is "deleted" but still exists in database (soft delete).

**Options:**

**Option A: Return 204**
```http
DELETE /users/42
HTTP/1.1 204 No Content
```
**Pros:** Consistent with hard delete
**Cons:** Doesn't indicate soft delete

**Option B: Return 200 with details**
```http
DELETE /users/42
HTTP/1.1 200 OK
{
  "message": "User deactivated",
  "status": "inactive",
  "deletedAt": "2026-01-12T10:00:00Z",
  "recoverable": true
}
```
**Pros:** Clear about soft delete
**Cons:** Different from hard delete

**Recommendation:** 
- If soft delete is transparent to client: 204
- If client needs to know it's soft: 200 with details

---

### Case 9: Authentication vs Authorization Error

**Scenario:** Distinguishing between authentication and authorization failures.

**Use 401 when:**
```http
// No token
GET /api/profile
HTTP/1.1 401 Unauthorized
{
  "error": "Authentication required"
}

// Invalid token
GET /api/profile
Authorization: Bearer invalid-token
HTTP/1.1 401 Unauthorized
{
  "error": "Invalid authentication credentials"
}

// Expired token
GET /api/profile
Authorization: Bearer expired-token
HTTP/1.1 401 Unauthorized
{
  "error": "Token expired"
}
```

**Use 403 when:**
```http
// Valid token but insufficient permissions
GET /admin/users
Authorization: Bearer valid-user-token
HTTP/1.1 403 Forbidden
{
  "error": "Insufficient permissions",
  "required": "admin",
  "current": "user"
}

// Valid token but account suspended
GET /api/profile
Authorization: Bearer valid-token-suspended-account
HTTP/1.1 403 Forbidden
{
  "error": "Account suspended"
}
```

**Decision tree:**
```
Is authentication valid?
├─ No → 401 Unauthorized
│       (missing, invalid, or expired credentials)
└─ Yes → Does user have permission?
         ├─ No → 403 Forbidden
         └─ Yes → Process request
```

---

### Case 10: Empty Collection - 200 vs 404

**Scenario:** GET request for collection returns no items.

**Problem:** Return 200 with empty array or 404?

**Option A: Return 200 with empty array (RECOMMENDED)**
```http
GET /users?status=inactive
HTTP/1.1 200 OK
{
  "data": [],
  "total": 0,
  "page": 1
}
```
**Pros:** Consistent response format
**Cons:** None

**Option B: Return 404**
```http
GET /users?status=inactive
HTTP/1.1 404 Not Found
{
  "error": "No users found"
}
```
**Pros:** None really
**Cons:** Inconsistent; empty is not an error

**Recommendation:** Always return 200 with empty array. Empty results are valid results, not errors.

```javascript
// ✅ Correct
app.get('/users', async (req, res) => {
  const users = await database.findUsers(req.query);
  return res.status(200).json({
    data: users, // Could be []
    total: users.length
  });
});

// ❌ Wrong
app.get('/users', async (req, res) => {
  const users = await database.findUsers(req.query);
  if (users.length === 0) {
    return res.status(404).json({ error: "No users found" });
  }
  return res.status(200).json(users);
});
```

---

## Best Practices

### 1. Be Consistent

```javascript
// ✅ Consistent error format
{
  "error": "Error type",
  "message": "Human readable message",
  "details": { /* additional info */ }
}

// Use this format for all error responses
```

### 2. Include Helpful Error Details

```javascript
// ❌ Not helpful
{
  "error": "Validation failed"
}

// ✅ Helpful
{
  "error": "Validation failed",
  "message": "Request validation failed",
  "details": [
    {
      "field": "email",
      "issue": "Invalid email format",
      "provided": "notanemail"
    },
    {
      "field": "age",
      "issue": "Must be at least 18",
      "provided": 15
    }
  ]
}
```

### 3. Don't Expose Sensitive Information

```javascript
// ❌ Exposing too much
{
  "error": "Database query failed: SELECT * FROM users WHERE password = '...'",
  "stackTrace": "at Connection.query (/app/db.js:123)",
  "config": {
    "host": "10.0.0.5",
    "password": "secret123"
  }
}

// ✅ Safe
{
  "error": "Internal Server Error",
  "message": "An unexpected error occurred",
  "requestId": "abc-123"  // For server-side debugging
}
```

### 4. Use Request IDs for Debugging

```http
GET /api/users
HTTP/1.1 500 Internal Server Error
X-Request-ID: abc-123-xyz
Content-Type: application/json

{
  "error": "Internal Server Error",
  "message": "An unexpected error occurred",
  "requestId": "abc-123-xyz"
}
```

### 5. Document Your Status Codes

```yaml
# OpenAPI/Swagger example
/users/{id}:
  get:
    responses:
      200:
        description: User found
      401:
        description: Authentication required
      403:
        description: Insufficient permissions
      404:
        description: User not found
      500:
        description: Internal server error
```

---

## Quick Reference Table

| Code | Name | When to Use | Include in Response |
|------|------|------------|---------------------|
| 200 | OK | Successful GET, PUT, PATCH | Resource data |
| 201 | Created | Resource created | Location header, resource |
| 202 | Accepted | Async processing started | Job ID, status URL |
| 204 | No Content | Successful DELETE, no data | Nothing |
| 304 | Not Modified | Resource unchanged (cache) | Headers only |
| 400 | Bad Request | Malformed request | Error details |
| 401 | Unauthorized | Authentication failed | WWW-Authenticate |
| 403 | Forbidden | No permission | Error message |
| 404 | Not Found | Resource doesn't exist | Error message |
| 409 | Conflict | State conflict | Conflict details |
| 422 | Unprocessable | Business rule violation | Validation errors |
| 429 | Too Many Requests | Rate limit exceeded | Retry-After |
| 500 | Server Error | Unexpected error | Request ID |
| 502 | Bad Gateway | Upstream failed | Error message |
| 503 | Service Unavailable | Temporary outage | Retry-After |

---

## Summary

**Choosing Status Codes:**
1. **Start with method + outcome**
   - GET succeeded → 200
   - POST created → 201
   - DELETE succeeded → 204
2. **Consider authentication/authorization**
   - Not authenticated → 401
   - No permission → 403
3. **Think about the client**
   - Client error → 4xx
   - Server error → 5xx
4. **Be specific when possible**
   - Use 422 over 400 for validation
   - Use 409 for conflicts
   - Use 429 for rate limiting

**Key Principles:**
- ✅ Be consistent across your API
- ✅ Provide helpful error messages
- ✅ Don't expose sensitive information
- ✅ Document expected status codes
- ✅ Use request IDs for debugging

---

## Next Steps

Now that you understand HTTP status codes, explore:
- Error response formats and standards
- API documentation with status codes
- Client-side error handling strategies
- Monitoring and alerting based on status codes
