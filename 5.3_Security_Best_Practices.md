# 5.3 Security Best Practices

## Overview

Security is not optional—it's a fundamental requirement for any REST API. A single security vulnerability can compromise user data, system integrity, and organizational reputation.

**Core Security Principles**:
- **Defense in Depth**: Multiple layers of security
- **Least Privilege**: Minimum necessary access
- **Fail Securely**: Default to secure state on errors
- **Security by Design**: Build security in from the start

## Always Use HTTPS

### Why HTTPS is Mandatory

HTTP transmits data in plain text, making it vulnerable to:
- **Man-in-the-Middle (MITM) attacks**: Intercepting and modifying requests/responses
- **Eavesdropping**: Reading sensitive data (passwords, tokens, personal information)
- **Session hijacking**: Stealing authentication tokens

### Implementation

**Enforce HTTPS Only**:
```javascript
// Express.js middleware to redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https' && process.env.NODE_ENV === 'production') {
    return res.redirect(`https://${req.header('host')}${req.url}`);
  }
  next();
});
```

**Set Strict-Transport-Security Header**:
```javascript
// Force HTTPS for 1 year, including subdomains
app.use((req, res, next) => {
  res.setHeader(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload'
  );
  next();
});
```

**Nginx Configuration**:
```nginx
server {
    listen 80;
    server_name api.example.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name api.example.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # HSTS header
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
}
```

### Best Practices

- ✅ Use TLS 1.2 or TLS 1.3 minimum
- ✅ Keep SSL certificates up to date
- ✅ Use strong cipher suites
- ✅ Enable HTTP/2 for better performance
- ✅ Test with SSL Labs (ssllabs.com/ssltest)
- ❌ Never mix HTTP and HTTPS content
- ❌ Don't use self-signed certificates in production

## Input Validation

### Why Validate Input

**Never trust client input.** Attackers can send malicious data to exploit vulnerabilities.

### Validation Strategies

**1. Whitelist Validation** (Preferred):
```javascript
// Only allow expected values
const allowedSortFields = ['name', 'email', 'created_at'];
const sortField = req.query.sort;

if (!allowedSortFields.includes(sortField)) {
  return res.status(400).json({
    error: 'Invalid sort field',
    allowed: allowedSortFields
  });
}
```

**2. Type Validation**:
```javascript
// Using a validation library like Joi
const Joi = require('joi');

const userSchema = Joi.object({
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(18).max(120),
  username: Joi.string().alphanum().min(3).max(30).required(),
  password: Joi.string().min(8).required(),
  website: Joi.string().uri().optional()
});

const { error, value } = userSchema.validate(req.body);
if (error) {
  return res.status(400).json({
    error: 'Validation failed',
    details: error.details.map(d => ({
      field: d.path.join('.'),
      message: d.message
    }))
  });
}
```

**3. Length Validation**:
```javascript
// Prevent resource exhaustion
function validateRequestSize(req, res, next) {
  const maxSize = 1024 * 1024; // 1MB
  
  if (req.headers['content-length'] > maxSize) {
    return res.status(413).json({
      error: 'Request too large',
      maxSize: '1MB'
    });
  }
  next();
}
```

**4. Format Validation**:
```javascript
// Validate UUIDs
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

if (!UUID_REGEX.test(req.params.id)) {
  return res.status(400).json({ error: 'Invalid ID format' });
}

// Validate dates
const dateStr = req.query.start_date;
const date = new Date(dateStr);

if (isNaN(date.getTime())) {
  return res.status(400).json({ error: 'Invalid date format' });
}
```

### Common Validation Rules

```javascript
const validationRules = {
  // Email: RFC 5322 compliant
  email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  
  // Username: alphanumeric, underscore, hyphen
  username: /^[a-zA-Z0-9_-]{3,30}$/,
  
  // Password: min 8 chars, uppercase, lowercase, digit, special char
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
  
  // Phone: international format
  phone: /^\+?[1-9]\d{1,14}$/,
  
  // URL: basic validation
  url: /^https?:\/\/.+/,
  
  // IPv4
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
};
```

## Output Sanitization

### Why Sanitize Output

Prevent sensitive data leakage and protect against injection attacks.

### Strategies

**1. Remove Sensitive Fields**:
```javascript
// Using a transform function
function sanitizeUser(user) {
  const { password, resetToken, twoFactorSecret, ...safe } = user;
  return safe;
}

app.get('/api/users/:id', async (req, res) => {
  const user = await db.getUser(req.params.id);
  res.json(sanitizeUser(user));
});
```

**2. Field Filtering**:
```javascript
// Allow clients to select fields
const allowedFields = ['id', 'name', 'email', 'avatar'];
const requestedFields = req.query.fields?.split(',') || allowedFields;

const safeFields = requestedFields.filter(f => allowedFields.includes(f));
const projection = safeFields.reduce((obj, field) => {
  obj[field] = 1;
  return obj;
}, {});

const user = await db.getUser(req.params.id, projection);
```

**3. HTML Encoding**:
```javascript
// Prevent XSS when returning user content
const escapeHtml = (unsafe) => {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
};

// For API responses in HTML format
res.send(`<div>${escapeHtml(userInput)}</div>`);
```

**4. Response Headers for Security**:
```javascript
app.use((req, res, next) => {
  // Prevent MIME type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');
  
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY');
  
  // XSS protection
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  // Content Security Policy
  res.setHeader('Content-Security-Policy', "default-src 'none'");
  
  next();
});
```

## SQL Injection Prevention

### Understanding SQL Injection

Attackers inject malicious SQL code through user input.

**Vulnerable Code**:
```javascript
// NEVER DO THIS!
const userId = req.params.id;
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query); // Vulnerable to: /api/users/1 OR 1=1
```

### Prevention Techniques

**1. Parameterized Queries** (Preferred):
```javascript
// Node.js with PostgreSQL
const userId = req.params.id;
const query = 'SELECT * FROM users WHERE id = $1';
const result = await db.query(query, [userId]);

// MySQL with prepared statements
const [rows] = await connection.execute(
  'SELECT * FROM users WHERE email = ? AND status = ?',
  [email, status]
);
```

**2. ORM/Query Builders**:
```javascript
// Using Sequelize
const user = await User.findOne({
  where: { email: req.body.email }
});

// Using Prisma
const user = await prisma.user.findUnique({
  where: { email: req.body.email }
});

// Using Knex
const users = await knex('users')
  .where('status', status)
  .where('age', '>', minAge);
```

**3. Input Validation**:
```javascript
// Validate before querying
function validateUserId(id) {
  const parsed = parseInt(id, 10);
  if (isNaN(parsed) || parsed < 1) {
    throw new Error('Invalid user ID');
  }
  return parsed;
}

const userId = validateUserId(req.params.id);
```

**4. Escape User Input** (Last Resort):
```javascript
// MySQL escaping (use parameterized queries instead!)
const mysql = require('mysql');
const escaped = mysql.escape(userInput);
```

## Cross-Site Scripting (XSS) Protection

### Types of XSS

1. **Stored XSS**: Malicious script stored in database
2. **Reflected XSS**: Script reflected from request to response
3. **DOM-based XSS**: Client-side script manipulation

### Prevention

**1. Content Security Policy**:
```javascript
res.setHeader(
  'Content-Security-Policy',
  "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:;"
);
```

**2. Encode Output**:
```javascript
// For JSON APIs, proper Content-Type prevents execution
res.setHeader('Content-Type', 'application/json');
res.json({ userInput: dangerousData }); // Safe in JSON

// For HTML responses, encode everything
const encodeHtml = require('escape-html');
res.send(`<div>${encodeHtml(userComment)}</div>`);
```

**3. Validate Content-Type**:
```javascript
app.use(express.json({
  type: 'application/json',
  verify: (req, res, buf, encoding) => {
    const contentType = req.headers['content-type'];
    if (!contentType || !contentType.includes('application/json')) {
      throw new Error('Invalid Content-Type');
    }
  }
}));
```

## CORS Configuration

### Understanding CORS

Cross-Origin Resource Sharing controls which domains can access your API.

### Secure CORS Setup

**1. Restrict Origins**:
```javascript
const cors = require('cors');

// Bad: Allow all origins
app.use(cors({ origin: '*' })); // DON'T DO THIS!

// Good: Whitelist specific origins
const allowedOrigins = [
  'https://app.example.com',
  'https://admin.example.com'
];

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, Postman)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true, // Allow cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400 // Cache preflight for 24 hours
}));
```

**2. Environment-Based Configuration**:
```javascript
const allowedOrigins = process.env.NODE_ENV === 'production'
  ? ['https://app.example.com']
  : ['http://localhost:3000', 'http://localhost:3001'];
```

**3. Dynamic Origin Validation**:
```javascript
app.use(cors({
  origin: (origin, callback) => {
    // Check against database or regex pattern
    const isAllowed = await db.isOriginWhitelisted(origin);
    callback(null, isAllowed);
  }
}));
```

## Rate Limiting

### Why Rate Limiting is Essential

Prevents:
- **Brute force attacks**: Password guessing
- **DoS attacks**: Resource exhaustion
- **API abuse**: Excessive requests
- **Data scraping**: Unauthorized data extraction

### Implementation

**1. Basic Rate Limiting**:
```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    error: 'Too many requests',
    retryAfter: 15 * 60 // seconds
  },
  standardHeaders: true, // Return rate limit info in headers
  legacyHeaders: false
});

app.use('/api/', limiter);
```

**2. Endpoint-Specific Limits**:
```javascript
// Strict limit for authentication
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 login attempts per 15 minutes
  skipSuccessfulRequests: true
});

app.post('/api/auth/login', authLimiter, loginHandler);

// Generous limit for reading
const readLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,
  max: 60 // 60 requests per minute
});

app.get('/api/posts', readLimiter, getPosts);
```

**3. User-Based Rate Limiting**:
```javascript
const rateLimitByUser = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  keyGenerator: (req) => {
    // Rate limit by user ID instead of IP
    return req.user?.id || req.ip;
  }
});
```

**4. Redis-Based Rate Limiting** (for distributed systems):
```javascript
const Redis = require('ioredis');
const RedisStore = require('rate-limit-redis');

const limiter = rateLimit({
  store: new RedisStore({
    client: new Redis({
      host: 'localhost',
      port: 6379
    })
  }),
  windowMs: 15 * 60 * 1000,
  max: 100
});
```

**5. Rate Limit Response Headers**:
```
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1640000000
Retry-After: 900

{
  "error": "Too many requests",
  "message": "Rate limit exceeded. Try again in 15 minutes.",
  "retryAfter": 900
}
```

## Sensitive Data Exposure Prevention

### Data Leakage Through URLs

**Problem**: URLs are logged everywhere (server logs, proxy logs, browser history, analytics).

**Bad Examples**:
```
❌ GET /api/reset-password?token=secret-reset-token-12345
❌ GET /api/users/search?ssn=123-45-6789
❌ GET /api/transactions?credit_card=4111111111111111
❌ GET /api/documents?api_key=abc123xyz
❌ GET /api/verify?email=user@example.com&code=123456
```

**Good Alternatives**:
```javascript
// Use POST with body for sensitive data
// ✅ POST /api/reset-password
// Body: { "token": "secret-reset-token-12345" }

// Use headers for credentials
// ✅ GET /api/users/me
// Header: Authorization: Bearer token123

// Use resource IDs instead of sensitive fields
// ✅ GET /api/users/search?query=john
// ❌ GET /api/users/search?email=john@example.com

// Return filtered search results
app.get('/api/users/search', async (req, res) => {
  const query = req.query.q;
  
  // Search internally with full data
  const users = await db.searchUsers(query);
  
  // Return only non-sensitive fields
  const safe = users.map(u => ({
    id: u.id,
    name: u.name,
    avatar: u.avatar
    // Don't expose: email, phone, address, etc.
  }));
  
  res.json(safe);
});
```

### Data in Error Messages

**Problem**: Error messages can reveal system internals and sensitive data.

**Bad Examples**:
```javascript
// ❌ Reveals database structure
res.status(500).json({
  error: "Column 'user_password_hash' doesn't exist in table 'users'"
});

// ❌ Reveals user existence
res.status(404).json({
  error: "User with email john@example.com not found"
});

// ❌ Reveals file system paths
res.status(500).json({
  error: "Cannot read file /var/www/app/secrets/config.json"
});

// ❌ Reveals validation rules
res.status(400).json({
  error: "Password must be at least 8 characters with uppercase, lowercase, digit, and special character"
});
```

**Good Examples**:
```javascript
// ✅ Generic error messages for users
res.status(500).json({
  error: "Internal server error",
  requestId: "req-12345" // For support to trace
});

// ✅ Don't reveal if user exists
res.status(401).json({
  error: "Invalid email or password" // Not "Email not found"
});

// ✅ Generic file error
res.status(500).json({
  error: "Unable to process request"
});

// ✅ Simple validation message
res.status(400).json({
  error: "Password does not meet requirements",
  code: "WEAK_PASSWORD"
  // Detailed rules only shown on registration form
});
```

**Logging Sensitive Errors Separately**:
```javascript
try {
  await processPayment(cardDetails);
} catch (error) {
  // Log full error internally
  logger.error('Payment processing failed', {
    error: error.message,
    stack: error.stack,
    userId: req.user.id,
    // DON'T log: card numbers, passwords, tokens
  });
  
  // Return generic error to client
  res.status(500).json({
    error: 'Payment processing failed',
    requestId: req.id
  });
}
```

### Sensitive Data in Responses

**Problem**: Accidentally exposing sensitive fields.

```javascript
// Bad: Returning entire user object
app.get('/api/users/:id', async (req, res) => {
  const user = await db.getUser(req.params.id);
  res.json(user); // ❌ Includes password hash, tokens, etc.
});

// Good: Explicitly select safe fields
app.get('/api/users/:id', async (req, res) => {
  const user = await db.getUser(req.params.id);
  
  const safeUser = {
    id: user.id,
    name: user.name,
    email: user.email,
    avatar: user.avatar,
    createdAt: user.createdAt
  };
  
  res.json(safeUser);
});

// Better: Use a serializer
class UserSerializer {
  static public(user) {
    return {
      id: user.id,
      name: user.name,
      avatar: user.avatar
    };
  }
  
  static private(user) {
    return {
      ...this.public(user),
      email: user.email,
      phone: user.phone
    };
  }
}

// Return based on context
const serialized = isOwner 
  ? UserSerializer.private(user)
  : UserSerializer.public(user);
```

### Mass Assignment Vulnerabilities

**Problem**: Accepting all user input without filtering.

```javascript
// Bad: Accepting any field from request
app.put('/api/users/:id', async (req, res) => {
  await db.updateUser(req.params.id, req.body);
  // ❌ Attacker could send: { "isAdmin": true, "balance": 1000000 }
});

// Good: Whitelist allowed fields
app.put('/api/users/:id', async (req, res) => {
  const allowedFields = ['name', 'email', 'avatar', 'bio'];
  
  const updates = Object.keys(req.body)
    .filter(key => allowedFields.includes(key))
    .reduce((obj, key) => {
      obj[key] = req.body[key];
      return obj;
    }, {});
  
  await db.updateUser(req.params.id, updates);
});
```

## Implementation Details Leakage

### Server Information Exposure

**Problem**: Revealing server technology makes targeted attacks easier.

**Remove Server Headers**:
```javascript
// Express: Remove X-Powered-By header
app.disable('x-powered-by');

// Or use helmet
const helmet = require('helmet');
app.use(helmet());

// Nginx: Hide version
http {
    server_tokens off;
}
```

**Headers to Remove/Modify**:
```
❌ Server: nginx/1.18.0 (Ubuntu)
❌ X-Powered-By: Express
❌ X-AspNet-Version: 4.0.30319
❌ X-AspNetMvc-Version: 5.2

✅ Server: (removed or generic)
```

### Error Stack Traces

**Problem**: Stack traces reveal file paths, frameworks, and code structure.

```javascript
// Bad: Exposing stack trace in production
app.use((err, req, res, next) => {
  res.status(500).json({
    error: err.message,
    stack: err.stack // ❌ Shows file paths and code!
  });
});

// Good: Hide internals in production
app.use((err, req, res, next) => {
  // Log full error internally
  logger.error(err.stack);
  
  // Return generic error to client
  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({
      error: 'Internal server error',
      requestId: req.id
    });
  } else {
    // In development, show details
    res.status(500).json({
      error: err.message,
      stack: err.stack
    });
  }
});
```

### API Version Information

**Problem**: Revealing specific version numbers aids targeted attacks.

```javascript
// Balanced approach
{
  "version": "2", // Major version only
  "name": "My API"
  // ❌ Don't expose: "version": "2.3.1-beta", "buildNumber": "12345"
}
```

### Debug/Development Endpoints

**Problem**: Forgetting to disable debug endpoints in production.

```javascript
// Disable debug routes in production
if (process.env.NODE_ENV !== 'production') {
  app.get('/debug/vars', (req, res) => {
    res.json(process.env);
  });
  
  app.get('/debug/routes', (req, res) => {
    res.json(app._router.stack);
  });
}

// Or check environment explicitly
app.get('/debug/info', (req, res) => {
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).json({ error: 'Not found' });
  }
  // Debug info...
});
```

### Timing Attacks

**Problem**: Response timing reveals information.

```javascript
// Bad: Early return reveals info
async function checkPassword(username, password) {
  const user = await db.findByUsername(username);
  if (!user) {
    return false; // Fast response = user doesn't exist
  }
  
  const valid = await bcrypt.compare(password, user.passwordHash);
  return valid; // Slow response = user exists
}

// Good: Constant-time comparison
async function checkPassword(username, password) {
  const user = await db.findByUsername(username);
  
  // Always hash, even if user doesn't exist
  const hashToCompare = user 
    ? user.passwordHash 
    : await bcrypt.hash('dummy', 10);
  
  const valid = await bcrypt.compare(password, hashToCompare);
  
  return user && valid;
}
```

## Additional Security Measures

### Request Size Limits

```javascript
// Prevent large payload attacks
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ limit: '10kb', extended: true }));

// Custom check
app.use((req, res, next) => {
  const contentLength = parseInt(req.headers['content-length'] || '0');
  
  if (contentLength > 1048576) { // 1MB
    return res.status(413).json({
      error: 'Payload too large',
      maxSize: '1MB'
    });
  }
  next();
});
```

### Secure Headers Checklist

```javascript
const helmet = require('helmet');

app.use(helmet({
  // Prevents MIME type sniffing
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  
  // Prevent clickjacking
  frameguard: { action: 'deny' },
  
  // Remove X-Powered-By
  hidePoweredBy: true,
  
  // Force HTTPS
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  
  // Prevent MIME sniffing
  noSniff: true,
  
  // Referrer policy
  referrerPolicy: { policy: 'same-origin' }
}));
```

### Dependency Security

```bash
# Regularly audit dependencies
npm audit
npm audit fix

# Use tools like Snyk
npm install -g snyk
snyk test
snyk monitor

# Keep dependencies updated
npm outdated
npm update
```

### Secure Password Storage

```javascript
const bcrypt = require('bcrypt');

// Hashing passwords
async function hashPassword(password) {
  const saltRounds = 12; // Adjust based on hardware
  return await bcrypt.hash(password, saltRounds);
}

// Verifying passwords
async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}

// NEVER do this:
// ❌ Storing plain text: password: "mypassword123"
// ❌ Using weak hash: md5(password)
// ❌ Using hash without salt: sha256(password)
```

### Token Security

```javascript
// JWT best practices
const jwt = require('jsonwebtoken');

// Sign with strong secret
const token = jwt.sign(
  { userId: user.id, role: user.role },
  process.env.JWT_SECRET, // Use strong random secret
  { 
    expiresIn: '1h', // Short expiration
    issuer: 'api.example.com',
    audience: 'app.example.com'
  }
);

// Verify tokens
try {
  const decoded = jwt.verify(token, process.env.JWT_SECRET, {
    issuer: 'api.example.com',
    audience: 'app.example.com'
  });
} catch (error) {
  // Token invalid, expired, or tampered
}

// Store tokens securely
// ✅ HttpOnly cookies (can't be accessed by JavaScript)
res.cookie('token', token, {
  httpOnly: true,
  secure: true, // HTTPS only
  sameSite: 'strict',
  maxAge: 3600000 // 1 hour
});

// ❌ Don't store in localStorage (vulnerable to XSS)
```

### API Key Management

```javascript
// Generate secure random API keys
const crypto = require('crypto');

function generateApiKey() {
  return crypto.randomBytes(32).toString('hex');
}

// Hash API keys before storing
async function storeApiKey(key) {
  const hash = crypto
    .createHash('sha256')
    .update(key)
    .digest('hex');
  
  await db.saveApiKeyHash(hash);
  
  // Show key once to user
  return key;
}

// Verify API keys
async function verifyApiKey(providedKey) {
  const hash = crypto
    .createHash('sha256')
    .update(providedKey)
    .digest('hex');
  
  return await db.findApiKeyHash(hash);
}
```

### Request ID for Tracing

```javascript
const { v4: uuidv4 } = require('uuid');

app.use((req, res, next) => {
  req.id = req.headers['x-request-id'] || uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
});

// Include in error responses
res.status(500).json({
  error: 'Internal server error',
  requestId: req.id // Users can provide this for support
});
```

## Security Testing

### Automated Security Tests

```javascript
// Test authentication
describe('Authentication Security', () => {
  test('rejects requests without token', async () => {
    const res = await request(app)
      .get('/api/users/me')
      .expect(401);
  });
  
  test('rejects invalid tokens', async () => {
    const res = await request(app)
      .get('/api/users/me')
      .set('Authorization', 'Bearer invalid-token')
      .expect(401);
  });
  
  test('rejects expired tokens', async () => {
    const expiredToken = generateExpiredToken();
    const res = await request(app)
      .get('/api/users/me')
      .set('Authorization', `Bearer ${expiredToken}`)
      .expect(401);
  });
});

// Test authorization
describe('Authorization Security', () => {
  test('prevents users from accessing others data', async () => {
    const user1Token = await loginAs('user1');
    const user2Id = await getUser2Id();
    
    const res = await request(app)
      .get(`/api/users/${user2Id}/private`)
      .set('Authorization', `Bearer ${user1Token}`)
      .expect(403);
  });
});

// Test input validation
describe('Input Validation', () => {
  test('rejects SQL injection attempts', async () => {
    const res = await request(app)
      .get('/api/users?id=1 OR 1=1')
      .expect(400);
  });
  
  test('rejects XSS attempts', async () => {
    const res = await request(app)
      .post('/api/comments')
      .send({ text: '<script>alert("xss")</script>' })
      .expect(400);
  });
});
```

### Security Tools

- **OWASP ZAP**: Automated security scanner
- **Burp Suite**: Web security testing
- **npm audit**: Dependency vulnerabilities
- **Snyk**: Continuous security monitoring
- **SonarQube**: Code quality and security

## Security Checklist

### Before Deployment

- [ ] All endpoints require HTTPS
- [ ] Authentication implemented for protected routes
- [ ] Authorization checks on every resource access
- [ ] Input validation on all user input
- [ ] Output sanitization for all responses
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS protection headers set
- [ ] CORS properly configured
- [ ] Rate limiting implemented
- [ ] Sensitive data not in URLs
- [ ] Error messages don't reveal internals
- [ ] Server information headers removed
- [ ] Dependencies audited and updated
- [ ] Passwords properly hashed (bcrypt, argon2)
- [ ] API keys securely stored (hashed)
- [ ] Logging doesn't include sensitive data
- [ ] Security headers configured (helmet)
- [ ] Request size limits enforced
- [ ] Debug endpoints disabled
- [ ] Security tests passing

### Monitoring

- [ ] Failed authentication attempts logged
- [ ] Authorization failures tracked
- [ ] Rate limit violations monitored
- [ ] Unusual access patterns detected
- [ ] Security alerts configured
- [ ] Regular security audits scheduled

## Common Vulnerabilities (OWASP Top 10)

1. **Broken Access Control**: Missing authorization checks
2. **Cryptographic Failures**: Weak encryption, exposed secrets
3. **Injection**: SQL, NoSQL, command injection
4. **Insecure Design**: Security not considered in architecture
5. **Security Misconfiguration**: Default configs, unnecessary features
6. **Vulnerable Components**: Outdated dependencies
7. **Authentication Failures**: Weak credentials, poor session management
8. **Data Integrity Failures**: Unverified updates, insecure deserialization
9. **Logging Failures**: Insufficient logging of security events
10. **Server-Side Request Forgery (SSRF)**: Unvalidated URLs

## Summary

**Core Security Principles**:
1. **Never trust user input** - Validate everything
2. **Always use HTTPS** - Encrypt data in transit
3. **Minimize data exposure** - Return only necessary information
4. **Hide implementation details** - Don't reveal your stack
5. **Fail securely** - Default to denying access
6. **Defense in depth** - Multiple security layers
7. **Principle of least privilege** - Minimum necessary access
8. **Monitor and audit** - Track security events

**Remember**: Security is not a one-time task—it's an ongoing process requiring regular updates, monitoring, and testing.

**Related Topics**:
- [5.1 Authentication Methods](5.1_Authentication_Methods.md)
- [5.2 Authorization](5.2_Authorization.md)
- [4.4 Error Handling](4.4_Error_Handling.md)
- [6.2 Rate Limiting](6.2_Rate_Limiting.md)
