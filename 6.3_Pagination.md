# Pagination - Handling Large Result Sets

## Introduction

**Pagination** divides large result sets into smaller, manageable chunks (pages). Instead of returning 10,000 users in one response, return 20 at a time.

**Key principle:** Break large collections into pages to improve performance, reduce bandwidth, and enhance user experience.

---

## Why Pagination?

### Without Pagination

```javascript
// Return ALL users
GET /api/users

Response:
{
  "users": [
    { "id": 1, "name": "User 1" },
    { "id": 2, "name": "User 2" },
    // ... 10,000 more users
  ]
}

// Problems:
// ❌ Huge response (megabytes)
// ❌ Slow database query
// ❌ High memory usage
// ❌ Poor user experience (long wait)
// ❌ Timeout errors
```

### With Pagination

```javascript
// Return 20 users per page
GET /api/users?page=1&limit=20

Response:
{
  "users": [
    { "id": 1, "name": "User 1" },
    // ... 19 more users
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 10000,
    "totalPages": 500
  }
}

// Benefits:
// ✅ Small, fast responses
// ✅ Better performance
// ✅ Lower memory usage
// ✅ Better UX (instant feedback)
// ✅ Works with infinite scroll
```

---

## Pagination Strategies

### 1. Offset-Based Pagination

Most common. Uses `offset` (skip) and `limit` (take).

**Request:**
```http
GET /api/users?offset=40&limit=20
```

**SQL:**
```sql
SELECT * FROM users
ORDER BY id
LIMIT 20 OFFSET 40;
```

**Implementation:**

```javascript
app.get('/api/users', async (req, res) => {
  const offset = parseInt(req.query.offset) || 0;
  const limit = parseInt(req.query.limit) || 20;
  
  // Enforce maximum limit
  const maxLimit = 100;
  const finalLimit = Math.min(limit, maxLimit);
  
  // Get users with offset
  const users = await db.users
    .find()
    .skip(offset)
    .limit(finalLimit)
    .toArray();
  
  // Get total count
  const total = await db.users.countDocuments();
  
  res.json({
    data: users,
    pagination: {
      offset,
      limit: finalLimit,
      total,
      hasMore: offset + finalLimit < total
    }
  });
});

// Examples:
// /api/users?offset=0&limit=20   → Users 0-19
// /api/users?offset=20&limit=20  → Users 20-39
// /api/users?offset=40&limit=20  → Users 40-59
```

**Response:**

```json
{
  "data": [
    { "id": 41, "name": "User 41" },
    { "id": 42, "name": "User 42" },
    // ... 18 more
  ],
  "pagination": {
    "offset": 40,
    "limit": 20,
    "total": 10000,
    "hasMore": true
  }
}
```

**Pros:**
- ✅ Simple to implement
- ✅ Can jump to any page
- ✅ Works with most databases
- ✅ Intuitive for users

**Cons:**
- ❌ Slow for large offsets (database scans all skipped rows)
- ❌ Inconsistent results if data changes (items can appear twice or be missed)
- ❌ Inefficient for deep pagination

**Example of the "missing item" problem:**

```javascript
// User requests page 2 (offset=20, limit=20)
// Response: Users 21-40

// During viewing, user 5 is deleted

// User requests page 3 (offset=40, limit=20)
// Response: Users 41-60
// BUT! User 21 is now at position 20, was already shown on page 2
// User sees duplicate or misses user 21 entirely
```

---

### 2. Page-Based Pagination

Uses `page` number instead of offset. Just syntactic sugar over offset.

**Request:**
```http
GET /api/users?page=3&limit=20
```

**Implementation:**

```javascript
app.get('/api/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  
  // Calculate offset from page
  const offset = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    db.users.find().skip(offset).limit(limit).toArray(),
    db.users.countDocuments()
  ]);
  
  const totalPages = Math.ceil(total / limit);
  
  res.json({
    data: users,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1
    }
  });
});

// Examples:
// /api/users?page=1&limit=20  → Users 0-19
// /api/users?page=2&limit=20  → Users 20-39
// /api/users?page=3&limit=20  → Users 40-59
```

**Response:**

```json
{
  "data": [
    { "id": 41, "name": "User 41" },
    // ... 19 more
  ],
  "pagination": {
    "page": 3,
    "limit": 20,
    "total": 10000,
    "totalPages": 500,
    "hasNextPage": true,
    "hasPrevPage": true
  }
}
```

**Pros/Cons:** Same as offset-based (it's the same thing)

---

### 3. Cursor-Based Pagination

Uses a unique identifier (cursor) to mark position. Most robust for changing data.

**Request:**
```http
GET /api/users?cursor=eyJpZCI6NDAsImNyZWF0ZWRfYXQiOiIyMDIyLTAxIn0&limit=20
```

**Cursor is typically:**
- Base64-encoded JSON: `{"id": 40, "created_at": "2022-01-20"}`
- Or just the last ID: `40`

**Implementation:**

```javascript
app.get('/api/users', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  const cursor = req.query.cursor;
  
  let query = {};
  
  // If cursor provided, get users after cursor
  if (cursor) {
    // Decode cursor (Base64)
    const decodedCursor = JSON.parse(
      Buffer.from(cursor, 'base64').toString('utf-8')
    );
    
    // Query: WHERE id > cursor.id
    query = { id: { $gt: decodedCursor.id } };
  }
  
  // Get limit + 1 to check if there are more
  const users = await db.users
    .find(query)
    .sort({ id: 1 })
    .limit(limit + 1)
    .toArray();
  
  // Check if there are more results
  const hasMore = users.length > limit;
  
  // Remove extra item
  const data = hasMore ? users.slice(0, limit) : users;
  
  // Generate next cursor from last item
  let nextCursor = null;
  if (hasMore && data.length > 0) {
    const lastItem = data[data.length - 1];
    nextCursor = Buffer.from(
      JSON.stringify({ id: lastItem.id })
    ).toString('base64');
  }
  
  res.json({
    data,
    pagination: {
      nextCursor,
      hasMore
    }
  });
});

// Example flow:
// Request 1: /api/users?limit=20
// Response: Users 1-20, nextCursor = "eyJpZCI6MjB9"

// Request 2: /api/users?cursor=eyJpZCI6MjB9&limit=20
// Response: Users 21-40, nextCursor = "eyJpZCI6NDB9"

// Request 3: /api/users?cursor=eyJpZCI6NDB9&limit=20
// Response: Users 41-60, nextCursor = "eyJpZCI6NjB9"
```

**Response:**

```json
{
  "data": [
    { "id": 21, "name": "User 21" },
    { "id": 22, "name": "User 22" },
    // ... 18 more
  ],
  "pagination": {
    "nextCursor": "eyJpZCI6NDB9",
    "hasMore": true
  }
}
```

**Advanced: Cursor with multiple fields**

```javascript
app.get('/api/users', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  const cursor = req.query.cursor;
  
  let query = {};
  
  if (cursor) {
    const decoded = JSON.parse(
      Buffer.from(cursor, 'base64').toString('utf-8')
    );
    
    // Query: WHERE (created_at, id) > (cursor.created_at, cursor.id)
    // This ensures stable ordering even with duplicate timestamps
    query = {
      $or: [
        { created_at: { $gt: decoded.created_at } },
        {
          created_at: decoded.created_at,
          id: { $gt: decoded.id }
        }
      ]
    };
  }
  
  const users = await db.users
    .find(query)
    .sort({ created_at: 1, id: 1 })
    .limit(limit + 1)
    .toArray();
  
  const hasMore = users.length > limit;
  const data = hasMore ? users.slice(0, limit) : users;
  
  let nextCursor = null;
  if (hasMore && data.length > 0) {
    const lastItem = data[data.length - 1];
    nextCursor = Buffer.from(
      JSON.stringify({
        created_at: lastItem.created_at,
        id: lastItem.id
      })
    ).toString('base64');
  }
  
  res.json({
    data,
    pagination: {
      nextCursor,
      hasMore
    }
  });
});
```

**Pros:**
- ✅ Consistent results even if data changes
- ✅ No duplicate or missing items
- ✅ Fast for any position (uses index)
- ✅ Perfect for infinite scroll

**Cons:**
- ❌ Can't jump to arbitrary page
- ❌ Can't show total pages
- ❌ More complex implementation
- ❌ Requires stable ordering

---

### 4. Keyset Pagination (Seek Method)

Similar to cursor, but uses visible values instead of opaque cursor.

**Request:**
```http
GET /api/users?after_id=40&limit=20
```

**Implementation:**

```javascript
app.get('/api/users', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  const afterId = parseInt(req.query.after_id);
  
  let query = {};
  
  if (afterId) {
    query = { id: { $gt: afterId } };
  }
  
  const users = await db.users
    .find(query)
    .sort({ id: 1 })
    .limit(limit + 1)
    .toArray();
  
  const hasMore = users.length > limit;
  const data = hasMore ? users.slice(0, limit) : users;
  
  res.json({
    data,
    pagination: {
      afterId: hasMore ? data[data.length - 1].id : null,
      hasMore
    }
  });
});

// Examples:
// /api/users?limit=20               → Users 1-20
// /api/users?after_id=20&limit=20   → Users 21-40
// /api/users?after_id=40&limit=20   → Users 41-60
```

**Response:**

```json
{
  "data": [
    { "id": 21, "name": "User 21" },
    // ... 19 more
  ],
  "pagination": {
    "afterId": 40,
    "hasMore": true
  }
}
```

**Pros:**
- ✅ Same as cursor-based
- ✅ Simpler (no Base64 encoding)
- ✅ Debuggable (visible IDs)

**Cons:**
- ❌ Exposes internal IDs
- ❌ Less flexible than cursor (hard to change structure)

---

### 5. Time-Based Pagination

Paginate by timestamp. Common for feeds and logs.

**Request:**
```http
GET /api/posts?before=2022-01-20T12:00:00Z&limit=20
```

**Implementation:**

```javascript
app.get('/api/posts', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  const before = req.query.before; // ISO 8601 timestamp
  
  let query = {};
  
  if (before) {
    query = { created_at: { $lt: new Date(before) } };
  }
  
  // Sort by newest first
  const posts = await db.posts
    .find(query)
    .sort({ created_at: -1 })
    .limit(limit + 1)
    .toArray();
  
  const hasMore = posts.length > limit;
  const data = hasMore ? posts.slice(0, limit) : posts;
  
  res.json({
    data,
    pagination: {
      before: hasMore ? data[data.length - 1].created_at : null,
      hasMore
    }
  });
});

// Examples:
// /api/posts?limit=20  → Latest 20 posts
// /api/posts?before=2022-01-20T12:00:00Z&limit=20  → 20 posts before that time
```

**Bidirectional:**

```javascript
app.get('/api/posts', async (req, res) => {
  const limit = parseInt(req.query.limit) || 20;
  const before = req.query.before;
  const after = req.query.after;
  
  let query = {};
  let sort = { created_at: -1 }; // Default: newest first
  
  if (before) {
    query = { created_at: { $lt: new Date(before) } };
    sort = { created_at: -1 };
  } else if (after) {
    query = { created_at: { $gt: new Date(after) } };
    sort = { created_at: 1 }; // Oldest first when going forward
  }
  
  const posts = await db.posts
    .find(query)
    .sort(sort)
    .limit(limit + 1)
    .toArray();
  
  const hasMore = posts.length > limit;
  let data = hasMore ? posts.slice(0, limit) : posts;
  
  // Reverse if going forward (after)
  if (after) {
    data = data.reverse();
  }
  
  res.json({
    data,
    pagination: {
      before: data.length > 0 ? data[0].created_at : null,
      after: data.length > 0 ? data[data.length - 1].created_at : null,
      hasMore
    }
  });
});
```

**Pros:**
- ✅ Natural for time-series data
- ✅ Works well with real-time updates
- ✅ Efficient database queries

**Cons:**
- ❌ Requires timestamp field
- ❌ Multiple items with same timestamp need tie-breaker (use ID)

---

## Pagination Metadata

### Essential Metadata

```json
{
  "data": [...],
  "pagination": {
    // Current state
    "page": 3,
    "limit": 20,
    
    // Total information
    "total": 10000,
    "totalPages": 500,
    
    // Navigation
    "hasNextPage": true,
    "hasPrevPage": true,
    "nextPage": 4,
    "prevPage": 2
  }
}
```

### Complete Metadata Example

```javascript
app.get('/api/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    db.users.find().skip(offset).limit(limit).toArray(),
    db.users.countDocuments()
  ]);
  
  const totalPages = Math.ceil(total / limit);
  
  res.json({
    data: users,
    pagination: {
      // Current page info
      page,
      limit,
      offset,
      
      // Total info
      total,
      totalPages,
      
      // Item range
      from: offset + 1,
      to: Math.min(offset + limit, total),
      
      // Navigation flags
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
      isFirstPage: page === 1,
      isLastPage: page === totalPages,
      
      // Page numbers
      nextPage: page < totalPages ? page + 1 : null,
      prevPage: page > 1 ? page - 1 : null,
      firstPage: 1,
      lastPage: totalPages
    }
  });
});
```

**Response:**

```json
{
  "data": [
    { "id": 41, "name": "User 41" },
    // ... 19 more
  ],
  "pagination": {
    "page": 3,
    "limit": 20,
    "offset": 40,
    "total": 10000,
    "totalPages": 500,
    "from": 41,
    "to": 60,
    "hasNextPage": true,
    "hasPrevPage": true,
    "isFirstPage": false,
    "isLastPage": false,
    "nextPage": 4,
    "prevPage": 2,
    "firstPage": 1,
    "lastPage": 500
  }
}
```

---

## Pagination with HATEOAS Links

Include navigation links in response.

```javascript
app.get('/api/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    db.users.find().skip(offset).limit(limit).toArray(),
    db.users.countDocuments()
  ]);
  
  const totalPages = Math.ceil(total / limit);
  const baseUrl = `${req.protocol}://${req.get('host')}${req.path}`;
  
  const links = {
    self: `${baseUrl}?page=${page}&limit=${limit}`,
    first: `${baseUrl}?page=1&limit=${limit}`,
    last: `${baseUrl}?page=${totalPages}&limit=${limit}`
  };
  
  if (page < totalPages) {
    links.next = `${baseUrl}?page=${page + 1}&limit=${limit}`;
  }
  
  if (page > 1) {
    links.prev = `${baseUrl}?page=${page - 1}&limit=${limit}`;
  }
  
  res.json({
    data: users,
    pagination: {
      page,
      limit,
      total,
      totalPages
    },
    _links: links
  });
});
```

**Response:**

```json
{
  "data": [...],
  "pagination": {
    "page": 3,
    "limit": 20,
    "total": 10000,
    "totalPages": 500
  },
  "_links": {
    "self": "/api/users?page=3&limit=20",
    "first": "/api/users?page=1&limit=20",
    "prev": "/api/users?page=2&limit=20",
    "next": "/api/users?page=4&limit=20",
    "last": "/api/users?page=500&limit=20"
  }
}
```

---

## Pagination with Link Header

Alternative: Use standard Link header (RFC 5988).

```javascript
app.get('/api/users', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  const [users, total] = await Promise.all([
    db.users.find().skip(offset).limit(limit).toArray(),
    db.users.countDocuments()
  ]);
  
  const totalPages = Math.ceil(total / limit);
  const baseUrl = `${req.protocol}://${req.get('host')}${req.path}`;
  
  // Build Link header
  const links = [];
  
  links.push(`<${baseUrl}?page=1&limit=${limit}>; rel="first"`);
  links.push(`<${baseUrl}?page=${totalPages}&limit=${limit}>; rel="last"`);
  
  if (page < totalPages) {
    links.push(`<${baseUrl}?page=${page + 1}&limit=${limit}>; rel="next"`);
  }
  
  if (page > 1) {
    links.push(`<${baseUrl}?page=${page - 1}&limit=${limit}>; rel="prev"`);
  }
  
  // Set Link header
  res.header('Link', links.join(', '));
  
  // Optional: Also include in custom headers
  res.header('X-Total-Count', total);
  res.header('X-Page', page);
  res.header('X-Per-Page', limit);
  res.header('X-Total-Pages', totalPages);
  
  res.json(users);
});
```

**Response Headers:**

```http
HTTP/1.1 200 OK
Content-Type: application/json
Link: <https://api.example.com/users?page=1&limit=20>; rel="first",
      <https://api.example.com/users?page=500&limit=20>; rel="last",
      <https://api.example.com/users?page=4&limit=20>; rel="next",
      <https://api.example.com/users?page=2&limit=20>; rel="prev"
X-Total-Count: 10000
X-Page: 3
X-Per-Page: 20
X-Total-Pages: 500

[
  { "id": 41, "name": "User 41" },
  ...
]
```

**Used by GitHub API!**

---

## Combining Pagination with Filtering and Sorting

```javascript
app.get('/api/users', async (req, res) => {
  // Pagination params
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  // Filtering params
  const status = req.query.status; // ?status=active
  const search = req.query.search; // ?search=john
  
  // Sorting params
  const sortBy = req.query.sort || 'created_at'; // ?sort=name
  const order = req.query.order === 'asc' ? 1 : -1; // ?order=asc
  
  // Build query
  const query = {};
  
  if (status) {
    query.status = status;
  }
  
  if (search) {
    query.name = { $regex: search, $options: 'i' };
  }
  
  // Execute query
  const [users, total] = await Promise.all([
    db.users
      .find(query)
      .sort({ [sortBy]: order })
      .skip(offset)
      .limit(limit)
      .toArray(),
    db.users.countDocuments(query)
  ]);
  
  const totalPages = Math.ceil(total / limit);
  
  // Build links preserving filters and sorting
  const buildUrl = (page) => {
    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
      ...(status && { status }),
      ...(search && { search }),
      ...(sortBy !== 'created_at' && { sort: sortBy }),
      ...(order === 1 && { order: 'asc' })
    });
    return `/api/users?${params.toString()}`;
  };
  
  res.json({
    data: users,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1
    },
    _links: {
      self: buildUrl(page),
      first: buildUrl(1),
      last: buildUrl(totalPages),
      ...(page < totalPages && { next: buildUrl(page + 1) }),
      ...(page > 1 && { prev: buildUrl(page - 1) })
    }
  });
});

// Example: /api/users?status=active&search=john&sort=name&order=asc&page=2&limit=10
// Returns active users with "john" in name, sorted by name ascending, page 2
```

---

## Performance Optimization

### 1. Count Query Optimization

Counting total is expensive. Cache or estimate.

```javascript
// ❌ Bad: Count on every request
const total = await db.users.countDocuments(); // Slow for large tables!

// ✅ Good: Cache count
const cacheKey = 'users:total';
let total = await redis.get(cacheKey);

if (!total) {
  total = await db.users.countDocuments();
  await redis.set(cacheKey, total, 'EX', 300); // Cache 5 minutes
}

// ✅ Better: Estimate for very large tables
const stats = await db.users.estimatedDocumentCount(); // Much faster!

// ✅ Best: Don't show total count (cursor-based pagination)
// Just show "hasMore": true/false
```

### 2. Index Optimization

Ensure indexes on pagination fields.

```javascript
// Create indexes
db.users.createIndex({ id: 1 });
db.users.createIndex({ created_at: -1, id: -1 }); // Compound for cursor pagination

// ❌ Bad: No index on sort field
db.users.find().sort({ name: 1 }).skip(1000).limit(20); // Table scan!

// ✅ Good: Index on sort field
db.users.createIndex({ name: 1 });
db.users.find().sort({ name: 1 }).skip(1000).limit(20); // Uses index
```

### 3. Avoid Deep Pagination

```javascript
// ❌ Bad: Allow unlimited offset
const offset = parseInt(req.query.offset); // User can request offset=1000000!

// ✅ Good: Limit maximum offset
const maxOffset = 10000;
const offset = Math.min(parseInt(req.query.offset) || 0, maxOffset);

if (parseInt(req.query.offset) > maxOffset) {
  return res.status(400).json({
    error: {
      code: 'OFFSET_TOO_LARGE',
      message: `Maximum offset is ${maxOffset}. Use cursor-based pagination for deep pagination.`
    }
  });
}
```

### 4. Limit Maximum Page Size

```javascript
const limit = parseInt(req.query.limit) || 20;
const maxLimit = 100;

if (limit > maxLimit) {
  return res.status(400).json({
    error: {
      code: 'LIMIT_TOO_LARGE',
      message: `Maximum limit is ${maxLimit}.`,
      maxLimit
    }
  });
}

const finalLimit = Math.min(limit, maxLimit);
```

---

## Client-Side Implementation

### React Pagination Component

```javascript
function UserList() {
  const [users, setUsers] = useState([]);
  const [pagination, setPagination] = useState({});
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);
  
  useEffect(() => {
    fetchUsers(page);
  }, [page]);
  
  const fetchUsers = async (page) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/users?page=${page}&limit=20`);
      const data = await response.json();
      setUsers(data.data);
      setPagination(data.pagination);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      
      <div className="pagination">
        <button
          onClick={() => setPage(page - 1)}
          disabled={!pagination.hasPrevPage}
        >
          Previous
        </button>
        
        <span>
          Page {pagination.page} of {pagination.totalPages}
        </span>
        
        <button
          onClick={() => setPage(page + 1)}
          disabled={!pagination.hasNextPage}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

### Infinite Scroll with Intersection Observer

```javascript
function InfiniteUserList() {
  const [users, setUsers] = useState([]);
  const [cursor, setCursor] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);
  const loaderRef = useRef(null);
  
  const fetchUsers = async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
      const url = cursor
        ? `/api/users?cursor=${cursor}&limit=20`
        : `/api/users?limit=20`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      setUsers(prev => [...prev, ...data.data]);
      setCursor(data.pagination.nextCursor);
      setHasMore(data.pagination.hasMore);
    } finally {
      setLoading(false);
    }
  };
  
  // Initial load
  useEffect(() => {
    fetchUsers();
  }, []);
  
  // Infinite scroll
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          fetchUsers();
        }
      },
      { threshold: 1.0 }
    );
    
    if (loaderRef.current) {
      observer.observe(loaderRef.current);
    }
    
    return () => observer.disconnect();
  }, [hasMore, loading, cursor]);
  
  return (
    <div>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      
      {hasMore && (
        <div ref={loaderRef} className="loader">
          {loading ? 'Loading...' : 'Scroll for more'}
        </div>
      )}
    </div>
  );
}
```

### Load More Button

```javascript
function LoadMoreUserList() {
  const [users, setUsers] = useState([]);
  const [cursor, setCursor] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);
  
  const loadMore = async () => {
    setLoading(true);
    try {
      const url = cursor
        ? `/api/users?cursor=${cursor}&limit=20`
        : `/api/users?limit=20`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      setUsers(prev => [...prev, ...data.data]);
      setCursor(data.pagination.nextCursor);
      setHasMore(data.pagination.hasMore);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    loadMore();
  }, []);
  
  return (
    <div>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      
      {hasMore && (
        <button onClick={loadMore} disabled={loading}>
          {loading ? 'Loading...' : 'Load More'}
        </button>
      )}
    </div>
  );
}
```

---

## Real-World Examples

### GitHub API

```http
GET https://api.github.com/users/octocat/repos?page=2&per_page=30

Response Headers:
Link: <https://api.github.com/users/octocat/repos?page=3&per_page=30>; rel="next",
      <https://api.github.com/users/octocat/repos?page=5&per_page=30>; rel="last",
      <https://api.github.com/users/octocat/repos?page=1&per_page=30>; rel="first",
      <https://api.github.com/users/octocat/repos?page=1&per_page=30>; rel="prev"

[
  { "id": 1, "name": "repo1" },
  { "id": 2, "name": "repo2" },
  ...
]
```

### Twitter API (Cursor-Based)

```http
GET https://api.twitter.com/2/tweets/search/recent?max_results=10

{
  "data": [
    { "id": "1234567890", "text": "Hello" },
    ...
  ],
  "meta": {
    "newest_id": "1234567890",
    "oldest_id": "1234567880",
    "result_count": 10,
    "next_token": "b26v89c19zqg8o3fosdk..."
  }
}

// Next page:
GET https://api.twitter.com/2/tweets/search/recent?max_results=10&next_token=b26v89c19zqg8o3fosdk...
```

### Stripe API (Starting After)

```http
GET https://api.stripe.com/v1/customers?limit=10

{
  "object": "list",
  "url": "/v1/customers",
  "has_more": true,
  "data": [
    { "id": "cus_123", "email": "user@example.com" },
    ...
  ]
}

// Next page:
GET https://api.stripe.com/v1/customers?limit=10&starting_after=cus_123
```

---

## Testing Pagination

```javascript
describe('User Pagination', () => {
  beforeEach(async () => {
    // Create 50 test users
    const users = Array.from({ length: 50 }, (_, i) => ({
      id: i + 1,
      name: `User ${i + 1}`,
      created_at: new Date()
    }));
    await db.users.insertMany(users);
  });
  
  afterEach(async () => {
    await db.users.deleteMany({});
  });
  
  it('should return first page with default limit', async () => {
    const response = await request(app)
      .get('/api/users');
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveLength(20);
    expect(response.body.data[0].id).toBe(1);
    expect(response.body.pagination.page).toBe(1);
    expect(response.body.pagination.total).toBe(50);
  });
  
  it('should return second page', async () => {
    const response = await request(app)
      .get('/api/users?page=2&limit=20');
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveLength(20);
    expect(response.body.data[0].id).toBe(21);
    expect(response.body.pagination.page).toBe(2);
  });
  
  it('should return last page with remaining items', async () => {
    const response = await request(app)
      .get('/api/users?page=3&limit=20');
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveLength(10); // 50 total, 20+20+10
    expect(response.body.data[0].id).toBe(41);
    expect(response.body.pagination.hasNextPage).toBe(false);
  });
  
  it('should include pagination metadata', async () => {
    const response = await request(app)
      .get('/api/users?page=2&limit=20');
    
    expect(response.body.pagination).toMatchObject({
      page: 2,
      limit: 20,
      total: 50,
      totalPages: 3,
      hasNextPage: true,
      hasPrevPage: true
    });
  });
  
  it('should include navigation links', async () => {
    const response = await request(app)
      .get('/api/users?page=2&limit=20');
    
    expect(response.body._links).toHaveProperty('self');
    expect(response.body._links).toHaveProperty('first');
    expect(response.body._links).toHaveProperty('last');
    expect(response.body._links).toHaveProperty('next');
    expect(response.body._links).toHaveProperty('prev');
  });
  
  it('should enforce maximum limit', async () => {
    const response = await request(app)
      .get('/api/users?limit=1000');
    
    expect(response.status).toBe(400);
    expect(response.body.error.code).toBe('LIMIT_TOO_LARGE');
  });
  
  it('should work with cursor-based pagination', async () => {
    // First page
    const first = await request(app)
      .get('/api/users?limit=20');
    
    expect(first.body.data).toHaveLength(20);
    expect(first.body.pagination.hasMore).toBe(true);
    
    const cursor = first.body.pagination.nextCursor;
    
    // Second page
    const second = await request(app)
      .get(`/api/users?cursor=${cursor}&limit=20`);
    
    expect(second.body.data).toHaveLength(20);
    expect(second.body.data[0].id).toBe(21);
  });
});
```

---

## Best Practices

### 1. Always Provide Pagination

```javascript
// ✅ Good: Paginate by default
GET /api/users → Returns 20 users with pagination

// ❌ Bad: Return all by default
GET /api/users → Returns 10,000 users!
```

### 2. Use Reasonable Defaults

```javascript
// ✅ Good: Sensible defaults
const limit = parseInt(req.query.limit) || 20;
const maxLimit = 100;

// ❌ Bad: No defaults or too large
const limit = parseInt(req.query.limit); // undefined if not provided
const limit = parseInt(req.query.limit) || 1000; // Too large
```

### 3. Include Total Count (If Needed)

```javascript
// ✅ Good for page-based: Include total
{
  "data": [...],
  "pagination": {
    "total": 10000,
    "totalPages": 500
  }
}

// ✅ Good for cursor-based: Skip total (expensive)
{
  "data": [...],
  "pagination": {
    "nextCursor": "...",
    "hasMore": true
  }
}
```

### 4. Consistent Response Structure

```javascript
// ✅ Good: Consistent structure
{
  "data": [...],
  "pagination": {...}
}

// ❌ Bad: Inconsistent
// Sometimes: { "users": [...], "page": 1 }
// Other times: { "items": [...], "meta": {...} }
```

### 5. Preserve Query Parameters

```javascript
// ✅ Good: Links preserve filters and sorting
GET /api/users?status=active&sort=name&page=2
{
  "_links": {
    "next": "/api/users?status=active&sort=name&page=3"
  }
}

// ❌ Bad: Links lose filters
{
  "_links": {
    "next": "/api/users?page=3" // Lost status and sort!
  }
}
```

### 6. Use Cursor for Infinite Scroll

```javascript
// ✅ Good: Cursor pagination for infinite scroll
// Consistent results, no duplicates/missing items

// ❌ Bad: Offset pagination for infinite scroll
// Items can be duplicated or missed if data changes
```

### 7. Optimize for Performance

```javascript
// ✅ Good: Index pagination fields
db.users.createIndex({ id: 1 });
db.users.createIndex({ created_at: -1 });

// ✅ Good: Limit deep pagination
if (offset > 10000) {
  return error('Use cursor pagination for deep pages');
}

// ✅ Good: Cache total count
const total = await getCachedCount('users');
```

---

## Common Mistakes

### Mistake 1: No Default Limit

```javascript
// ❌ Bad: No limit
const limit = parseInt(req.query.limit);
const users = await db.users.find().limit(limit); // limit=undefined → all users!

// ✅ Good: Default limit
const limit = parseInt(req.query.limit) || 20;
```

### Mistake 2: No Maximum Limit

```javascript
// ❌ Bad: User can request unlimited
const limit = parseInt(req.query.limit) || 20;
const users = await db.users.find().limit(limit); // User sets limit=999999!

// ✅ Good: Enforce maximum
const limit = Math.min(parseInt(req.query.limit) || 20, 100);
```

### Mistake 3: Missing Total Count

```javascript
// ❌ Bad: No way to know total pages
{
  "data": [...],
  "page": 2
}

// ✅ Good: Include total
{
  "data": [...],
  "pagination": {
    "page": 2,
    "total": 10000,
    "totalPages": 500
  }
}
```

### Mistake 4: Offset Pagination for Real-Time Data

```javascript
// ❌ Bad: Offset for real-time feeds
GET /api/posts?offset=20&limit=20
// New posts arrive → duplicates or missing posts

// ✅ Good: Cursor for real-time feeds
GET /api/posts?cursor=abc123&limit=20
// Consistent results even with new data
```

### Mistake 5: Not Including Navigation Links

```javascript
// ❌ Bad: Client must build URLs
{
  "data": [...],
  "page": 2,
  "totalPages": 500
}
// Client: "How do I get page 3?"

// ✅ Good: Provide navigation links
{
  "data": [...],
  "_links": {
    "next": "/api/users?page=3",
    "prev": "/api/users?page=1"
  }
}
```

---

## Comparison Matrix

| Feature | Offset | Page | Cursor | Keyset | Time |
|---------|--------|------|--------|--------|------|
| **Implementation** | Simple | Simple | Medium | Medium | Medium |
| **Jump to page** | ✅ | ✅ | ❌ | ❌ | ❌ |
| **Show total pages** | ✅ | ✅ | ❌ | ❌ | ❌ |
| **Consistent results** | ❌ | ❌ | ✅ | ✅ | ✅ |
| **Performance (deep)** | ❌ | ❌ | ✅ | ✅ | ✅ |
| **Infinite scroll** | ⚠️ | ⚠️ | ✅ | ✅ | ✅ |
| **Real-time data** | ❌ | ❌ | ✅ | ✅ | ✅ |
| **Database support** | ✅ | ✅ | ✅ | ✅ | ⚠️ |

**Legend:**
- ✅ Good
- ⚠️ Partial/OK
- ❌ Poor

**Recommendations:**
- **Offset/Page:** Simple CRUD apps, admin dashboards, known dataset size
- **Cursor:** Infinite scroll, real-time feeds, large datasets, mobile apps
- **Keyset:** Same as cursor, but simpler (if you don't mind exposing IDs)
- **Time:** Activity feeds, logs, chronological data

---

## Summary

### Key Concepts

- **Pagination** = Breaking large collections into pages
- **Purpose** = Performance, UX, resource management
- **Metadata** = Total, page info, navigation flags

### Strategies

1. **Offset-Based** = `?offset=40&limit=20` (simple, inconsistent)
2. **Page-Based** = `?page=3&limit=20` (sugar over offset)
3. **Cursor-Based** = `?cursor=abc&limit=20` (consistent, no total)
4. **Keyset** = `?after_id=40&limit=20` (like cursor, simpler)
5. **Time-Based** = `?before=2022-01-20&limit=20` (for time series)

### Best Practices

✅ Always paginate collections
✅ Use reasonable defaults (limit=20)
✅ Enforce maximum limit (100)
✅ Include comprehensive metadata
✅ Provide navigation links (HATEOAS)
✅ Preserve filters in pagination links
✅ Use cursor for infinite scroll
✅ Index pagination fields
✅ Limit deep pagination
✅ Cache total count

### When to Use What

- **Admin dashboards** → Page-based
- **Infinite scroll** → Cursor-based
- **Activity feeds** → Time-based or cursor
- **Search results** → Page-based or cursor
- **Mobile apps** → Cursor-based (data changes frequently)

---

## Next Steps

Explore related topics:
- Caching strategies for paginated data
- Rate limiting to protect pagination endpoints
- Combining pagination with filtering and sorting
- GraphQL pagination (relay-style connections)
- Database optimization for pagination queries
