# Idempotency in REST API

## Introduction

**Idempotency** is a critical property in distributed systems where making the same request multiple times produces the same result as making it once. In REST APIs, idempotency ensures reliability, enables safe retries, and prevents unintended side effects.

**Key principle:** An idempotent operation can be called multiple times without changing the result beyond the initial application.

---

## What is Idempotency?

### Definition

**Idempotent:** Multiple identical requests have the same effect as a single request.

```
Request 1: Changes state from A to B
Request 2: State remains B (same result)
Request 3: State remains B (same result)
Request N: State remains B (same result)
```

**Mathematical analogy:**
```
f(f(x)) = f(x)

Example:
abs(abs(-5)) = abs(-5) = 5  ✅ Idempotent
abs(-5) = 5
abs(5) = 5

counter++ is NOT idempotent:
f(0) = 1
f(1) = 2
f(2) = 3  ❌ Different results each time
```

### Real-World Analogy

**Idempotent (Light Switch to "ON"):**
```
State: OFF
Action: Turn ON  → Light is ON
Action: Turn ON  → Light is ON (no change)
Action: Turn ON  → Light is ON (no change)
```

**Not Idempotent (Toggle Switch):**
```
State: OFF
Action: Toggle → Light is ON
Action: Toggle → Light is OFF
Action: Toggle → Light is ON  ← Different results
```

---

## Safe vs Idempotent

Two related but distinct concepts:

### Safe Methods

**Safe:** The operation does NOT modify resources (read-only).

```
Safe methods:
✅ GET     - Read data (no changes)
✅ HEAD    - Read headers (no changes)
✅ OPTIONS - Read metadata (no changes)
```

**Characteristics:**
- No side effects on server state
- Can be cached
- Can be prefetched
- Can be called millions of times safely

### Idempotent Methods

**Idempotent:** Multiple identical requests produce the same result.

```
Idempotent methods:
✅ GET     - Always returns same data (safe + idempotent)
✅ PUT     - Always results in same final state
✅ DELETE  - Always results in resource being gone
✅ HEAD    - Always returns same headers (safe + idempotent)
✅ OPTIONS - Always returns same options (safe + idempotent)

Not idempotent:
❌ POST    - Each call may create new resource
```

### Venn Diagram

```
┌─────────────────────────────────────────┐
│  SAFE METHODS                           │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │  GET, HEAD, OPTIONS             │   │
│  │                                 │   │
│  │  (Safe + Idempotent)            │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  IDEMPOTENT METHODS (not safe)          │
│                                         │
│  PUT, DELETE, PATCH*                    │
│                                         │
│  (Change state, but idempotent)         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  NON-IDEMPOTENT METHODS                 │
│                                         │
│  POST                                   │
│                                         │
│  (Each call may have different effect)  │
└─────────────────────────────────────────┘

*PATCH can be idempotent or not, depending on implementation
```

---

## HTTP Methods and Idempotency

### GET - Safe + Idempotent

```http
# Call 1
GET /users/42
Response: {"id": 42, "name": "John", "balance": 100}

# Call 2 (same result)
GET /users/42
Response: {"id": 42, "name": "John", "balance": 100}

# Call N (same result)
GET /users/42
Response: {"id": 42, "name": "John", "balance": 100}
```

**Properties:**
- ✅ Safe (no modifications)
- ✅ Idempotent (same result every time)
- ✅ Cacheable
- ✅ Can be retried without concern

**Exception:** If the underlying resource changes between calls, GET returns different data, but this doesn't violate idempotency because GET itself doesn't cause the change.

---

### POST - NOT Idempotent

```http
# Call 1 - Creates user with ID 42
POST /users
{"name": "John", "email": "john@example.com"}
Response: 201 Created
{"id": 42, "name": "John", "email": "john@example.com"}

# Call 2 - Creates DIFFERENT user with ID 43
POST /users
{"name": "John", "email": "john@example.com"}
Response: 201 Created
{"id": 43, "name": "John", "email": "john@example.com"}

# Call 3 - Creates ANOTHER user with ID 44
POST /users
{"name": "John", "email": "john@example.com"}
Response: 201 Created
{"id": 44, "name": "John", "email": "john@example.com"}
```

**Properties:**
- ❌ Not safe (creates resources)
- ❌ Not idempotent (each call creates new resource)
- ❌ Not cacheable
- ❌ Risky to retry without safeguards

**Why it matters:**
```http
# Network failure scenario
POST /payments
{"amount": 100, "cardNumber": "4242..."}

# Request sent, but network fails before response received
# Client doesn't know if payment succeeded
# Retry? Risk of double charge!

# This is why POST is dangerous without idempotency keys
```

---

### PUT - Idempotent

```http
# Call 1 - Updates user
PUT /users/42
{"name": "John Doe", "email": "john@example.com"}
Response: 200 OK
{"id": 42, "name": "John Doe", "email": "john@example.com"}

# Call 2 - Same request, same final state
PUT /users/42
{"name": "John Doe", "email": "john@example.com"}
Response: 200 OK
{"id": 42, "name": "John Doe", "email": "john@example.com"}

# Call N - Same final state
PUT /users/42
{"name": "John Doe", "email": "john@example.com"}
Response: 200 OK
{"id": 42, "name": "John Doe", "email": "john@example.com"}
```

**Properties:**
- ❌ Not safe (modifies resource)
- ✅ Idempotent (same final state)
- ❌ Not cacheable
- ✅ Safe to retry

**Key insight:** PUT replaces entire resource with provided data, so multiple identical PUTs result in the same final state.

**Important:** PUT creates resource if it doesn't exist:

```http
# Resource doesn't exist
PUT /users/42
{"name": "John", "email": "john@example.com"}
Response: 201 Created

# Retry - resource exists, updates it
PUT /users/42
{"name": "John", "email": "john@example.com"}
Response: 200 OK

# Both result in same final state - idempotent!
```

---

### DELETE - Idempotent

```http
# Call 1 - Deletes user
DELETE /users/42
Response: 204 No Content

# Call 2 - User already deleted
DELETE /users/42
Response: 204 No Content  (or 404 Not Found)

# Call N - Same result
DELETE /users/42
Response: 204 No Content  (or 404 Not Found)
```

**Properties:**
- ❌ Not safe (modifies state)
- ✅ Idempotent (resource is gone)
- ❌ Not cacheable
- ✅ Safe to retry

**Response options for subsequent DELETEs:**

**Option 1: Always 204 (Recommended)**
```http
DELETE /users/42
Response: 204 No Content  (first time)

DELETE /users/42
Response: 204 No Content  (subsequent - still idempotent)
```

**Option 2: 404 for non-existent**
```http
DELETE /users/42
Response: 204 No Content  (first time)

DELETE /users/42
Response: 404 Not Found   (subsequent - resource doesn't exist)
```

Both are valid! Option 1 is more strictly idempotent (same response code).

---

### PATCH - Conditionally Idempotent

PATCH can be idempotent or not, depending on the operation.

#### Idempotent PATCH (Set operations)

```http
# Call 1
PATCH /users/42
{"name": "John Doe"}
Response: 200 OK
{"id": 42, "name": "John Doe", "email": "john@example.com"}

# Call 2 - Same final state
PATCH /users/42
{"name": "John Doe"}
Response: 200 OK
{"id": 42, "name": "John Doe", "email": "john@example.com"}
```

**Idempotent operations:**
- Set field to value: `{"status": "active"}`
- Replace field: `{"email": "new@example.com"}`

#### Non-Idempotent PATCH (Increment operations)

```http
# Call 1
PATCH /users/42
{"balance": {"$increment": 10}}
Response: 200 OK
{"id": 42, "name": "John", "balance": 110}

# Call 2 - Different result!
PATCH /users/42
{"balance": {"$increment": 10}}
Response: 200 OK
{"id": 42, "name": "John", "balance": 120}  ← Changed!

# Call 3 - Different again!
PATCH /users/42
{"balance": {"$increment": 10}}
Response: 200 OK
{"id": 42, "name": "John", "balance": 130}  ← Changed!
```

**Non-idempotent operations:**
- Increment: `{"count": {"$increment": 1}}`
- Append to array: `{"tags": {"$push": "new-tag"}}`
- Relative changes: `{"price": {"$multiply": 1.1}}`

**Best practice:** Use PUT for idempotent updates, PATCH for partial updates where you understand the idempotency implications.

---

### HEAD - Safe + Idempotent

```http
# Call 1
HEAD /users/42
Response: 200 OK
Content-Type: application/json
ETag: "abc123"

# Call N - Same headers
HEAD /users/42
Response: 200 OK
Content-Type: application/json
ETag: "abc123"
```

Same properties as GET (safe + idempotent), but no body.

---

### OPTIONS - Safe + Idempotent

```http
# Call 1
OPTIONS /users/42
Response: 200 OK
Allow: GET, PUT, PATCH, DELETE

# Call N - Same options
OPTIONS /users/42
Response: 200 OK
Allow: GET, PUT, PATCH, DELETE
```

---

## Why Idempotency Matters

### 1. Network Failures

```
Client                    Network                    Server
   |                         |                          |
   |------- POST /orders --->|                          |
   |                         |------- POST /orders ---->|
   |                         |                          | (processes request)
   |                         |<------ 201 Created ------|
   |<- Connection timeout ---|                          |
   |                         X (response lost)
   |
   | Did it succeed? Should I retry?
   | If I retry POST, will I create duplicate order?
```

**With idempotent methods (PUT, DELETE):**
```
Client                    Network                    Server
   |                         |                          |
   |------- PUT /users/42 -->|                          |
   |                         |------- PUT /users/42 --->|
   |                         |                          | (processes request)
   |                         |<------ 200 OK -----------|
   |<- Connection timeout ---|                          |
   |                         X (response lost)
   |
   |------- PUT /users/42 -->| (retry safely!)          |
   |                         |------- PUT /users/42 --->|
   |                         |                          | (same final state)
   |                         |<------ 200 OK -----------|
   |<------ 200 OK ----------|                          |
```

### 2. Duplicate Requests

**Scenario:** User clicks "Submit" button multiple times

```javascript
// Without idempotency protection
button.addEventListener('click', () => {
  fetch('/api/orders', {
    method: 'POST',
    body: JSON.stringify(orderData)
  });
});

// User clicks 3 times (impatient)
// Result: 3 orders created! ❌
```

**With idempotency key:**
```javascript
button.addEventListener('click', () => {
  const idempotencyKey = generateKey(); // Generate once
  
  fetch('/api/orders', {
    method: 'POST',
    headers: {
      'Idempotency-Key': idempotencyKey
    },
    body: JSON.stringify(orderData)
  });
});

// User clicks 3 times
// Result: 1 order created ✅
// Subsequent requests return cached response
```

### 3. Retry Logic

```javascript
// Safe retry for idempotent methods
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;
      
      // Retry on network errors or 5xx
      if (response.status >= 500) {
        await sleep(1000 * Math.pow(2, i)); // Exponential backoff
        continue;
      }
      
      return response; // Don't retry 4xx errors
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(1000 * Math.pow(2, i));
    }
  }
}

// Safe for GET, PUT, DELETE
await fetchWithRetry('/api/users/42', {
  method: 'PUT',
  body: JSON.stringify(userData)
});

// Dangerous for POST without idempotency key!
await fetchWithRetry('/api/orders', {
  method: 'POST',
  body: JSON.stringify(orderData)
  // This could create multiple orders!
});
```

### 4. Load Balancers and Proxies

```
Client                 Load Balancer           Server 1    Server 2
   |                         |                     |           |
   |------ POST /orders ---->|                     |           |
   |                         |--- POST /orders --->|           |
   |                         |                     | (timeout) |
   |                         |--- POST /orders ----|---------->|
   |                         |                     |           | (success)
   |<------ 201 Created -----|<----- 201 ---------|-----------|
   
# Without idempotency: Both servers process request = 2 orders created!
# With idempotency key: Second server checks cache = 1 order created ✅
```

---

## Implementing Idempotency for POST

### Idempotency Keys

Use a unique key to identify duplicate requests.

#### Client-Side Implementation

```javascript
// Generate idempotency key
function generateIdempotencyKey() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  // Or use UUID: crypto.randomUUID()
}

// Make idempotent POST request
async function createOrder(orderData) {
  const idempotencyKey = generateIdempotencyKey();
  
  const response = await fetch('/api/orders', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Idempotency-Key': idempotencyKey
    },
    body: JSON.stringify(orderData)
  });
  
  return response.json();
}

// Retry with same key
async function createOrderWithRetry(orderData, maxRetries = 3) {
  const idempotencyKey = generateIdempotencyKey();
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Idempotency-Key': idempotencyKey  // Same key for retries!
        },
        body: JSON.stringify(orderData)
      });
      
      if (response.ok) return response.json();
      if (response.status >= 500) continue; // Retry server errors
      throw new Error(`Request failed: ${response.status}`);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(1000 * Math.pow(2, i));
    }
  }
}
```

#### Server-Side Implementation

```javascript
// Express.js example
const express = require('express');
const app = express();

// In-memory cache (use Redis in production)
const idempotencyCache = new Map();

app.post('/api/orders', async (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  if (!idempotencyKey) {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'Idempotency-Key header is required'
    });
  }
  
  // Check if request was already processed
  const cachedResponse = idempotencyCache.get(idempotencyKey);
  if (cachedResponse) {
    console.log('Returning cached response for:', idempotencyKey);
    return res.status(cachedResponse.status).json(cachedResponse.body);
  }
  
  try {
    // Process the order
    const order = await createOrder(req.body);
    
    // Cache the response
    const response = {
      status: 201,
      body: order
    };
    idempotencyCache.set(idempotencyKey, response);
    
    // Set cache expiration (24 hours)
    setTimeout(() => {
      idempotencyCache.delete(idempotencyKey);
    }, 24 * 60 * 60 * 1000);
    
    res.status(201).json(order);
  } catch (error) {
    // Don't cache errors (except for validation errors)
    if (error.name === 'ValidationError') {
      const response = {
        status: 422,
        body: { error: 'Validation Failed', details: error.details }
      };
      idempotencyCache.set(idempotencyKey, response);
      return res.status(422).json(response.body);
    }
    
    res.status(500).json({ error: 'Internal Server Error' });
  }
});
```

#### Using Database for Idempotency

```javascript
// More robust: Store idempotency keys in database
async function processIdempotentRequest(idempotencyKey, requestData, processFunc) {
  const db = getDatabase();
  
  // Start transaction
  const transaction = await db.transaction();
  
  try {
    // Check if key exists
    const existing = await transaction.query(
      'SELECT response, status_code FROM idempotency_keys WHERE key = ?',
      [idempotencyKey]
    );
    
    if (existing.length > 0) {
      // Return cached response
      await transaction.commit();
      return {
        status: existing[0].status_code,
        body: JSON.parse(existing[0].response)
      };
    }
    
    // Process the request
    const result = await processFunc(requestData);
    
    // Store the result with idempotency key
    await transaction.query(
      'INSERT INTO idempotency_keys (key, response, status_code, created_at) VALUES (?, ?, ?, NOW())',
      [idempotencyKey, JSON.stringify(result), 201]
    );
    
    await transaction.commit();
    
    return {
      status: 201,
      body: result
    };
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}

// Usage
app.post('/api/orders', async (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  if (!idempotencyKey) {
    return res.status(400).json({ error: 'Idempotency-Key required' });
  }
  
  try {
    const result = await processIdempotentRequest(
      idempotencyKey,
      req.body,
      async (data) => {
        // Your business logic
        return await createOrder(data);
      }
    );
    
    res.status(result.status).json(result.body);
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Cleanup old keys (run periodically)
async function cleanupOldKeys() {
  await db.query(
    'DELETE FROM idempotency_keys WHERE created_at < DATE_SUB(NOW(), INTERVAL 24 HOUR)'
  );
}
```

---

## Idempotency Patterns

### Pattern 1: Natural Idempotency (Upsert)

Use unique business identifiers instead of auto-generated IDs.

```javascript
// Instead of:
POST /orders
{"items": [...], "userId": 42}
→ Creates new order with ID 123

POST /orders
{"items": [...], "userId": 42}
→ Creates duplicate order with ID 124  ❌

// Use natural keys:
PUT /orders/order-2026-01-13-user-42
{"items": [...], "userId": 42}
→ Creates or updates order

PUT /orders/order-2026-01-13-user-42
{"items": [...], "userId": 42}
→ Updates same order (idempotent)  ✅
```

### Pattern 2: Client-Generated IDs

Client generates unique ID (UUID).

```javascript
// Client generates UUID
const orderId = crypto.randomUUID();

PUT /orders/${orderId}
{"items": [...], "userId": 42}
→ Creates order with client-provided ID

// Retry with same ID
PUT /orders/${orderId}
{"items": [...], "userId": 42}
→ Updates same order (idempotent)  ✅
```

### Pattern 3: Conditional Requests

Use ETags or version numbers.

```javascript
// Initial state
GET /users/42
Response:
{
  "id": 42,
  "name": "John",
  "version": 5
}
ETag: "version-5"

// Update with condition
PUT /users/42
If-Match: "version-5"
{"name": "John Doe"}

// If another request updated in between:
Response: 412 Precondition Failed
{
  "error": "Resource was modified",
  "currentVersion": 6
}

// Client refetches and retries
GET /users/42  (get latest version)
PUT /users/42
If-Match: "version-6"
{"name": "John Doe"}
Response: 200 OK
```

### Pattern 4: Token-Based Idempotency

One-time tokens for sensitive operations.

```javascript
// Get operation token
POST /payments/prepare
{"amount": 100, "currency": "USD"}

Response: 200 OK
{
  "token": "payment-token-abc123",
  "expiresAt": "2026-01-13T10:15:00Z"
}

// Execute with token (can only be used once)
POST /payments
{
  "token": "payment-token-abc123",
  "cardNumber": "4242..."
}
Response: 200 OK

// Retry with same token
POST /payments
{
  "token": "payment-token-abc123",
  "cardNumber": "4242..."
}
Response: 400 Bad Request
{
  "error": "Token already used",
  "originalPaymentId": "pay-xyz-789"
}
```

---

## Edge Cases and Gotchas

### 1. Partial Failures

```javascript
// Operation that involves multiple steps
POST /orders
{
  "items": [...],
  "payment": {...}
}

// What if:
// 1. Order created ✅
// 2. Payment processed ✅
// 3. Network fails before response sent ❌

// Retry:
POST /orders (with same idempotency key)

// Server must:
// - Check if order already exists (by idempotency key)
// - Return existing order (don't charge again!)
// - Return 201 or 200? (201 for original, 200 for retry?)
```

**Solution:** Store operation state with idempotency key.

```javascript
const operation = await getIdempotencyOperation(key);

if (operation) {
  if (operation.status === 'completed') {
    return operation.result;
  }
  if (operation.status === 'processing') {
    // Wait or return 409 Conflict
    return { status: 409, message: 'Request is being processed' };
  }
  if (operation.status === 'failed') {
    // Retry the operation
    return processOperation();
  }
}
```

### 2. Time-Based Operations

```javascript
// NOT idempotent: Uses current time
POST /scheduled-tasks
{
  "executeAt": "now + 1 hour"  ❌
}

// Call 1 at 10:00 → Schedules for 11:00
// Call 2 at 10:05 → Schedules for 11:05  (different!)

// Idempotent: Use absolute time
POST /scheduled-tasks
{
  "executeAt": "2026-01-13T11:00:00Z"  ✅
}

// Call 1 → Schedules for 11:00
// Call 2 → Schedules for 11:00  (same!)
```

### 3. Random Values

```javascript
// NOT idempotent: Generates random password
POST /users
{
  "email": "user@example.com",
  "generatePassword": true  ❌
}

// Call 1 → Creates user with password "abc123"
// Call 2 → Creates user with password "xyz789"  (different!)

// Idempotent: Client provides password
POST /users
{
  "email": "user@example.com",
  "password": "user-provided-password"  ✅
}
```

### 4. External API Calls

```javascript
// Dangerous: External API called on each request
POST /orders
{
  "items": [...],
  "payment": {...}
}

// Server:
async function createOrder(data) {
  const order = await db.createOrder(data);
  await externalPaymentAPI.charge(data.payment);  ❌ Called every time!
  await externalInventoryAPI.reserve(data.items);  ❌ Called every time!
  return order;
}

// Solution: Track external call results
async function createOrderIdempotent(idempotencyKey, data) {
  const state = await getOperationState(idempotencyKey);
  
  if (!state) {
    state = await initializeOperation(idempotencyKey);
  }
  
  if (!state.orderCreated) {
    const order = await db.createOrder(data);
    await updateState(idempotencyKey, { orderCreated: true, orderId: order.id });
  }
  
  if (!state.paymentProcessed) {
    await externalPaymentAPI.charge(data.payment);
    await updateState(idempotencyKey, { paymentProcessed: true });
  }
  
  if (!state.inventoryReserved) {
    await externalInventoryAPI.reserve(data.items);
    await updateState(idempotencyKey, { inventoryReserved: true });
  }
  
  return await getOrder(state.orderId);
}
```

### 5. Timestamp Fields

```javascript
// Server adds timestamps
POST /posts
{
  "title": "My Post",
  "content": "..."
}

// Server:
function createPost(data) {
  return db.insert({
    ...data,
    createdAt: new Date()  // Different each time!
  });
}

// Solution: Use idempotency key timestamp or stored value
function createPostIdempotent(key, data) {
  const existing = cache.get(key);
  if (existing) return existing;
  
  const timestamp = extractTimestamp(key) || new Date();
  const post = db.insert({
    ...data,
    createdAt: timestamp  // Same timestamp for retries
  });
  
  cache.set(key, post);
  return post;
}
```

---

## Testing Idempotency

### Unit Tests

```javascript
describe('PUT /users/:id', () => {
  it('should be idempotent', async () => {
    const userData = {
      name: 'John Doe',
      email: 'john@example.com'
    };
    
    // First request
    const response1 = await request(app)
      .put('/users/42')
      .send(userData)
      .expect(200);
    
    // Second request (identical)
    const response2 = await request(app)
      .put('/users/42')
      .send(userData)
      .expect(200);
    
    // Third request (identical)
    const response3 = await request(app)
      .put('/users/42')
      .send(userData)
      .expect(200);
    
    // All responses should be identical
    expect(response1.body).toEqual(response2.body);
    expect(response2.body).toEqual(response3.body);
    
    // Verify database state
    const user = await db.users.findById(42);
    expect(user.name).toBe('John Doe');
    expect(user.email).toBe('john@example.com');
  });
});

describe('DELETE /users/:id', () => {
  it('should be idempotent', async () => {
    // Create user
    await db.users.create({ id: 42, name: 'John' });
    
    // First delete
    await request(app)
      .delete('/users/42')
      .expect(204);
    
    // Second delete (should not fail)
    await request(app)
      .delete('/users/42')
      .expect(204); // or 404, both acceptable
    
    // Verify user is gone
    const user = await db.users.findById(42);
    expect(user).toBeNull();
  });
});
```

### Idempotency Key Tests

```javascript
describe('POST /orders with idempotency key', () => {
  it('should not create duplicate orders', async () => {
    const orderData = {
      items: [{ productId: 123, quantity: 2 }],
      userId: 42
    };
    const idempotencyKey = 'test-key-123';
    
    // First request
    const response1 = await request(app)
      .post('/orders')
      .set('Idempotency-Key', idempotencyKey)
      .send(orderData)
      .expect(201);
    
    const orderId1 = response1.body.id;
    
    // Second request with same key
    const response2 = await request(app)
      .post('/orders')
      .set('Idempotency-Key', idempotencyKey)
      .send(orderData)
      .expect(201); // or 200
    
    const orderId2 = response2.body.id;
    
    // Should return same order
    expect(orderId1).toBe(orderId2);
    expect(response1.body).toEqual(response2.body);
    
    // Verify only one order was created
    const orders = await db.orders.findByUserId(42);
    expect(orders).toHaveLength(1);
  });
  
  it('should create different orders with different keys', async () => {
    const orderData = {
      items: [{ productId: 123, quantity: 2 }],
      userId: 42
    };
    
    // First request
    const response1 = await request(app)
      .post('/orders')
      .set('Idempotency-Key', 'key-1')
      .send(orderData)
      .expect(201);
    
    // Second request with different key
    const response2 = await request(app)
      .post('/orders')
      .set('Idempotency-Key', 'key-2')
      .send(orderData)
      .expect(201);
    
    // Should create different orders
    expect(response1.body.id).not.toBe(response2.body.id);
    
    // Verify two orders were created
    const orders = await db.orders.findByUserId(42);
    expect(orders).toHaveLength(2);
  });
});
```

### Concurrent Request Tests

```javascript
describe('Concurrent idempotent requests', () => {
  it('should handle concurrent identical requests', async () => {
    const orderData = {
      items: [{ productId: 123, quantity: 2 }],
      userId: 42
    };
    const idempotencyKey = 'concurrent-test-key';
    
    // Send 5 identical requests concurrently
    const promises = Array(5).fill(null).map(() =>
      request(app)
        .post('/orders')
        .set('Idempotency-Key', idempotencyKey)
        .send(orderData)
    );
    
    const responses = await Promise.all(promises);
    
    // All should succeed
    responses.forEach(res => {
      expect([200, 201]).toContain(res.status);
    });
    
    // All should return same order ID
    const orderIds = responses.map(res => res.body.id);
    const uniqueIds = [...new Set(orderIds)];
    expect(uniqueIds).toHaveLength(1);
    
    // Verify only one order in database
    const orders = await db.orders.findByUserId(42);
    expect(orders).toHaveLength(1);
  });
});
```

---

## Best Practices

### 1. Make Safe Methods Actually Safe

```javascript
// ❌ Bad: GET with side effects
app.get('/users/:id/increment-views', (req, res) => {
  db.users.incrementViews(req.params.id);  // Modifies data!
  const user = db.users.findById(req.params.id);
  res.json(user);
});

// ✅ Good: Use POST for actions with side effects
app.post('/users/:id/views', (req, res) => {
  db.users.incrementViews(req.params.id);
  res.status(204).send();
});
```

### 2. Require Idempotency Keys for Critical Operations

```javascript
// Require idempotency key for payments, orders, etc.
app.post('/payments', (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  if (!idempotencyKey) {
    return res.status(400).json({
      error: 'Bad Request',
      message: 'Idempotency-Key header is required for payment operations'
    });
  }
  
  // Process payment...
});
```

### 3. Set Appropriate Cache Duration

```javascript
// Short-lived operations: 24 hours
const IDEMPOTENCY_TTL = 24 * 60 * 60 * 1000;

// Financial operations: 30-90 days
const PAYMENT_IDEMPOTENCY_TTL = 90 * 24 * 60 * 60 * 1000;

// Balance retention vs storage costs
```

### 4. Return Same Status Code

```javascript
// ✅ Good: Same response for retries
POST /orders (first time)
Response: 201 Created

POST /orders (with same idempotency key)
Response: 201 Created (same status code)

// ⚠️  Acceptable but less consistent:
POST /orders (first time)
Response: 201 Created

POST /orders (with same idempotency key)
Response: 200 OK (different status, but same body)
```

### 5. Document Idempotent Behavior

```yaml
# OpenAPI/Swagger
paths:
  /orders:
    post:
      summary: Create order
      description: |
        Creates a new order. This endpoint is idempotent when using
        the Idempotency-Key header. Subsequent requests with the same
        key will return the original response without creating a new order.
      parameters:
        - name: Idempotency-Key
          in: header
          required: true
          schema:
            type: string
          description: |
            Unique key to ensure idempotency. Use a UUID v4.
            Keys are valid for 24 hours.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '201':
          description: Order created
        '200':
          description: Order already exists (idempotency key match)
```

### 6. Handle Idempotency Key Conflicts

```javascript
// Different request body with same key = error
app.post('/orders', async (req, res) => {
  const key = req.headers['idempotency-key'];
  const cached = cache.get(key);
  
  if (cached) {
    // Verify request body matches
    if (!deepEqual(cached.requestBody, req.body)) {
      return res.status(422).json({
        error: 'Idempotency Key Conflict',
        message: 'Same idempotency key used with different request body'
      });
    }
    
    return res.status(cached.status).json(cached.response);
  }
  
  // Process new request...
});
```

---

## Common Mistakes

### Mistake 1: Assuming POST is Idempotent

```javascript
// ❌ Wrong: Treating POST as idempotent
async function createUser(userData) {
  const response = await fetch('/api/users', {
    method: 'POST',
    body: JSON.stringify(userData)
  });
  
  if (!response.ok) {
    // Retry without idempotency key = duplicate users!
    return createUser(userData);
  }
  
  return response.json();
}

// ✅ Correct: Use idempotency key
async function createUser(userData, idempotencyKey) {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Idempotency-Key': idempotencyKey
    },
    body: JSON.stringify(userData)
  });
  
  if (!response.ok && response.status >= 500) {
    // Safe to retry with same key
    return createUser(userData, idempotencyKey);
  }
  
  return response.json();
}
```

### Mistake 2: Side Effects in GET Requests

```javascript
// ❌ Bad: GET with side effects
app.get('/products/:id', (req, res) => {
  db.products.incrementViewCount(req.params.id);  // Not idempotent!
  const product = db.products.findById(req.params.id);
  res.json(product);
});

// ✅ Good: Separate tracking endpoint
app.get('/products/:id', (req, res) => {
  const product = db.products.findById(req.params.id);
  res.json(product);
});

app.post('/products/:id/views', (req, res) => {
  db.products.incrementViewCount(req.params.id);
  res.status(204).send();
});
```

### Mistake 3: Not Handling Concurrent Requests

```javascript
// ❌ Bad: Race condition
app.post('/orders', async (req, res) => {
  const key = req.headers['idempotency-key'];
  
  // Check cache
  if (cache.has(key)) {
    return res.json(cache.get(key));
  }
  
  // Process order (takes time)
  const order = await createOrder(req.body);
  
  // Cache result
  cache.set(key, order);
  
  res.json(order);
});

// Two concurrent requests with same key:
// Both check cache (miss), both create order = duplicate!

// ✅ Good: Use locking
app.post('/orders', async (req, res) => {
  const key = req.headers['idempotency-key'];
  
  const lock = await acquireLock(key);
  
  try {
    if (cache.has(key)) {
      return res.json(cache.get(key));
    }
    
    const order = await createOrder(req.body);
    cache.set(key, order);
    
    res.json(order);
  } finally {
    await lock.release();
  }
});
```

### Mistake 4: Caching Errors

```javascript
// ❌ Bad: Caching all responses
app.post('/orders', async (req, res) => {
  const key = req.headers['idempotency-key'];
  
  if (cache.has(key)) {
    return res.json(cache.get(key));
  }
  
  try {
    const order = await createOrder(req.body);
    cache.set(key, { status: 201, body: order });
    res.status(201).json(order);
  } catch (error) {
    // Don't cache transient errors!
    cache.set(key, { status: 500, error });  ❌
    res.status(500).json({ error: error.message });
  }
});

// ✅ Good: Only cache successful responses and validation errors
app.post('/orders', async (req, res) => {
  const key = req.headers['idempotency-key'];
  
  if (cache.has(key)) {
    const cached = cache.get(key);
    return res.status(cached.status).json(cached.body);
  }
  
  try {
    const order = await createOrder(req.body);
    cache.set(key, { status: 201, body: order });
    res.status(201).json(order);
  } catch (error) {
    if (error.name === 'ValidationError') {
      // Cache validation errors (deterministic)
      cache.set(key, { status: 422, body: error.details });
      return res.status(422).json(error.details);
    }
    
    // Don't cache transient errors (network, timeout, etc.)
    res.status(500).json({ error: 'Internal Server Error' });
  }
});
```

---

## Summary

### Idempotency Matrix

| Method | Safe | Idempotent | Can Retry | Notes |
|--------|------|------------|-----------|-------|
| GET | ✅ | ✅ | ✅ | Always safe to retry |
| HEAD | ✅ | ✅ | ✅ | Same as GET |
| OPTIONS | ✅ | ✅ | ✅ | Describes endpoint |
| PUT | ❌ | ✅ | ✅ | Replaces resource |
| DELETE | ❌ | ✅ | ✅ | Removes resource |
| PATCH | ❌ | ⚠️ | ⚠️ | Depends on operation |
| POST | ❌ | ❌ | ❌ | Use idempotency keys |

### Key Takeaways

1. **Safe ≠ Idempotent:** GET is both, PUT is only idempotent
2. **POST requires extra care:** Use idempotency keys for critical operations
3. **PATCH can be tricky:** Set operations are idempotent, increment operations are not
4. **Always handle retries:** Network failures happen, design for them
5. **Test thoroughly:** Unit tests, concurrent requests, partial failures
6. **Document behavior:** Make idempotency guarantees clear in API docs

### Implementation Checklist

- ✅ Safe methods (GET, HEAD, OPTIONS) have no side effects
- ✅ PUT and DELETE are truly idempotent
- ✅ POST operations support idempotency keys for critical operations
- ✅ Idempotency keys are stored and checked properly
- ✅ Concurrent requests with same key handled correctly
- ✅ Only appropriate responses are cached (not transient errors)
- ✅ Cache expiration set appropriately
- ✅ Clients can safely retry failed requests
- ✅ Documentation clearly explains idempotency behavior

---

## Next Steps

Now that you understand idempotency, explore:
- Versioning strategies for API evolution
- Error handling patterns and recovery
- Rate limiting and throttling
- Distributed systems and CAP theorem
- Event sourcing and idempotent event processing
- Testing strategies for distributed systems
